---
import * as Icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHeader,
  TableRow,
} from "~/components/starwind/table";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "~/components/starwind/tabs";
import {
  Abstract,
  Definition,
  Exercise,
  Explanation,
  More,
  Solution,
  Tip,
} from "~/components/ui/callouts";
import CodeBlock from "~/components/ui/code/CodeBlock.astro";
import InlineCode from "~/components/ui/code/InlineCode.astro";
import ShellBlock from "~/components/ui/code/ShellBlock.astro";
import List from "~/components/ui/list/List.astro";
import ListItem from "~/components/ui/list/ListItem.astro";
import Cons from "~/components/ui/procons/Cons.astro";
import ProCons from "~/components/ui/procons/ProCons.astro";
import Pros from "~/components/ui/procons/Pros.astro";
import {
  AuthorList,
  Book,
  OfficialDocs,
  References,
  WebPage,
} from "~/components/ui/references";
import Gato from "~/fragments/notes/type-fundamentals/basics/Gato.astro";
import InitializeKotlinApplicationBash from "~/fragments/notes/type-fundamentals/basics/InitializeKotlinApplicationBash.astro";
import InitializeKotlinApplicationPs1 from "~/fragments/notes/type-fundamentals/basics/InitializeKotlinApplicationPs1.astro";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";

const title = "Kotlin: Un lenguaje pragmático y moderno";
---

<NotesLayout
  title={title}
  git={{
    user: "r8vnhill",
    repo: "intro-kt",
  }}
  timeMultiplier={1.2}
>
  <Gato />
  <Abstract>
    <p>
      Kotlin es un lenguaje moderno que destaca por su <strong
        >pragmatismo</strong
      >,
      <strong>claridad</strong> y un fuerte <strong
        >enfoque en la seguridad</strong
      >. En los últimos años ha ganado gran popularidad gracias a su capacidad
      para combinar de forma eficaz los paradigmas de
      <strong>programación orientada a objetos</strong> y <strong
        >programación funcional</strong
      >, todo dentro de una sintaxis concisa y expresiva.
    </p>
    <p>
      En este curso exploraremos Kotlin como una herramienta para el <strong
        >diseño e implementación de bibliotecas de software reutilizables</strong
      >. Su interoperabilidad con Java, su modelo seguro frente a valores nulos,
      el soporte para
      <strong>funciones de extensión</strong>, <strong>corrutinas</strong> y otras
      características modernas lo convierten en una excelente opción para construir
      componentes <strong>modulares</strong>,
      <strong>mantenibles</strong> y <strong>multiplataforma</strong>.
    </p>
    <p>
      Esta primera lección ofrece una <strong
        >introducción al lenguaje y a su filosofía</strong
      >. Veremos cómo se escribe en Kotlin, en qué se diferencia de otros
      lenguajes, y qué ventajas ofrece a quienes buscan escribir código <strong
        >expresivo</strong
      >, <strong>seguro</strong> y <strong>pragmático</strong> desde el comienzo.
    </p>
    <p>
      A través de ejemplos simples y comparaciones prácticas, comenzaremos a
      sentar las bases que guiarán el resto del curso.
    </p>
  </Abstract>

  <section title="¿Qué aprenderás en este módulo?">
    <Heading headingLevel="h2" Icon={Icons.BookOpen}>
      ¿Qué aprenderás en este módulo?
    </Heading>

    <p>
      En este módulo introductorio conocerás los fundamentos esenciales de
      Kotlin y cómo aplicarlos para crear software reutilizable y expresivo. A
      lo largo de estas lecciones:
    </p>

    <List>
      <ListItem icon={Icons.Compass}>
        Descubrirás qué es Kotlin, cuál es su filosofía y por qué es una
        excelente opción para construir bibliotecas modernas.
      </ListItem>
      <ListItem icon={Icons.Code}>
        Aprenderás a declarar funciones y variables, y a diferenciar entre
        valores mutables e inmutables.
      </ListItem>
      <ListItem icon={Icons.SplitHorizontal}>
        Comprenderás la diferencia entre expresiones y declaraciones, y cómo
        aprovecharla para escribir código más claro y conciso.
      </ListItem>
      <ListItem icon={Icons.FlowArrow}>
        Explorarás estructuras de control como condicionales, ciclos y rangos, y
        su sintaxis idiomática en Kotlin.
      </ListItem>
      <ListItem icon={Icons.PlayCircle}>
        Verás cómo funciona el <strong>punto de entrada</strong> de un programa Kotlin
        y cómo ejecutar tu primer proyecto con Gradle.
      </ListItem>
    </List>

    <p class="mt-4">
      Este módulo sentará las bases conceptuales y prácticas para lo que sigue:
      técnicas para diseñar bibliotecas reutilizables, seguras y fáciles de
      mantener.
    </p>
  </section>

  <section title="Objetivos de aprendizaje">
    <Heading headingLevel="h2" Icon={Icons.Target}
      >Objetivos de aprendizaje</Heading
    >

    <p>Al finalizar este módulo, serás capaz de:</p>

    <List>
      <ListItem icon={Icons.BookOpenText}>
        Explicar qué es Kotlin, cuál es su filosofía y por qué es una excelente
        opción para desarrollar bibliotecas reutilizables y multiplataforma.
      </ListItem>
      <ListItem icon={Icons.CodeSimple}>
        Declarar funciones y variables, comprendiendo la diferencia entre <InlineCode
          code={`val`}
          lang="kotlin"
        /> y <InlineCode code={`var`} lang="kotlin" />, así como el uso de tipos
        básicos.
      </ListItem>
      <ListItem icon={Icons.GitBranch}>
        Utilizar expresiones condicionales para modelar decisiones de forma
        clara, concisa e idiomática.
      </ListItem>
      <ListItem icon={Icons.Repeat}>
        Aplicar ciclos y rangos para recorrer colecciones y estructuras
        repetitivas siguiendo las convenciones del lenguaje.
      </ListItem>
      <ListItem icon={Icons.Terminal}>
        Identificar la estructura general de un programa en Kotlin y su punto de
        entrada.
      </ListItem>
      <ListItem icon={Icons.TextAa}>
        Emplear interpolación de cadenas para construir mensajes dinámicos de
        manera expresiva.
      </ListItem>
    </List>

    <p class="mt-4">
      Estos objetivos te permitirán construir una base sólida para abordar temas
      más avanzados como tipos algebraicos, control de flujo funcional y diseño
      orientado a la composición.
    </p>
  </section>

  <section title="¿Qué es Kotlin?">
    <Heading headingLevel="h2" Icon={Icons.Cat}>¿Qué es Kotlin?</Heading>

    <p>
      <strong>Kotlin</strong> es un lenguaje de programación <strong
        >moderno y multiplataforma</strong
      > desarrollado por <strong>JetBrains</strong>. Combina características de
      la <strong>programación orientada a objetos</strong> y de la <strong
        >programación funcional</strong
      >, y se destaca por su <strong>sintaxis concisa</strong>, su <strong
        >enfoque en la seguridad</strong
      > y su capacidad para compilar a múltiples plataformas:
    </p>

    <List>
      <ListItem icon={Icons.Globe}>
        <strong>JavaScript (JS)</strong> y <strong>WebAssembly (WASM)</strong> para
        ejecución en navegadores.
      </ListItem>
      <ListItem icon={Icons.Stack}>
        <strong>Java Virtual Machine (JVM)</strong> para aplicaciones de servidor
        y desarrollo en Android.
      </ListItem>
      <ListItem icon={Icons.Cpu}>
        <strong>LLVM</strong> para aplicaciones nativas en escritorio, iOS y sistemas
        embebidos.
      </ListItem>
    </List>

    <p class="mt-4">
      En este curso nos enfocaremos en <strong>Kotlin sobre la JVM</strong>, la
      plataforma más consolidada del ecosistema. Sin embargo, los conceptos que
      aprenderás son altamente <strong>transferibles</strong> a las demás plataformas
      compatibles y aplicables en muchos otros <strong
        >lenguajes modernos</strong
      >.
    </p>
  </section>

  <section title="A Taste of Kotlin">
    <Heading headingLevel="h2" Icon={Icons.Code}> A Taste of Kotlin </Heading>

    <p>
      A continuación, te mostramos un ejemplo sencillo en Kotlin para que te
      familiarices con su sintaxis expresiva y concisa:
    </p>

    <CodeBlock
      icon={Icons.Kotlin}
      code={`
        data class Person(
            val name: String,
            val age: Int? = null
        )

        fun main() {
            val persons = listOf(
                Person("Harrier Du Bois"),
                Person("Kim Kitsuragi", age = 43)
            )
            val youngest = persons.minByOrNull { it.age ?: Int.MAX_VALUE }
            println("The youngest is: $youngest")
        }
        // Output: The youngest is: Person(name=Kim Kitsuragi, age=43)
      `}
      lang="kotlin"
      ><span slot="title">Primer programa: filtrar y mostrar datos</span
      ></CodeBlock
    >

    <Explanation>
      <List>
        <ListItem icon={Icons.Users}>
          Se define una <InlineCode code="data class" lang="kotlin" /> llamada <InlineCode
            code="Person"
            lang="kotlin"
          />
          con dos propiedades: <InlineCode code="name" lang="kotlin" /> de tipo <InlineCode
            code="String"
            lang="kotlin"
          />
          y <InlineCode code="age" lang="kotlin" /> de tipo <InlineCode
            code="Int?"
            lang="kotlin"
          /> (puede ser nulo).
        </ListItem>

        <ListItem icon={Icons.SlidersHorizontal}>
          La propiedad <InlineCode code="age" lang="kotlin" /> tiene un valor por
          defecto (<InlineCode code="null" lang="kotlin" />), lo que permite
          omitirla al crear una instancia.
        </ListItem>

        <ListItem icon={Icons.ListBullets}>
          Se crea una lista inmutable con <InlineCode
            code="listOf"
            lang="kotlin"
          />, que contiene dos objetos <InlineCode
            code="Person"
            lang="kotlin"
          />.
        </ListItem>

        <ListItem icon={Icons.PencilSimple}>
          En la segunda instancia se utiliza una <strong
            >asignación nombrada</strong
          > (<InlineCode code="age = 43" lang="kotlin" />) para mayor claridad y
          legibilidad.
        </ListItem>

        <ListItem icon={Icons.ArrowDown}>
          Se emplea <InlineCode code="minByOrNull" lang="kotlin" /> junto con el
          operador Elvis (<InlineCode code="?:" lang="kotlin" />) para ignorar
          los valores nulos y encontrar la persona más joven.
        </ListItem>

        <ListItem icon={Icons.Warning}>
          Si todas las edades fueran nulas, se usa <InlineCode
            code="Int.MAX_VALUE"
            lang="kotlin"
          /> como valor de reemplazo para evitar errores.
        </ListItem>

        <ListItem icon={Icons.TextAa}>
          Finalmente, se imprime el resultado usando <strong
            >interpolación de cadenas</strong
          >.
        </ListItem>
      </List>
    </Explanation>
  </section>

  <section title="Filosofía de Kotlin">
    <Heading headingLevel="h2" Icon={Icons.BracketsAngle}
      >Filosofía de Kotlin</Heading
    >

    <p>
      Kotlin fue diseñado con el propósito de hacer la programación más
      sencilla, segura y expresiva, sin renunciar a la flexibilidad ni a la
      potencia. En lugar de introducir ideas experimentales o radicales, adopta
      prácticas consolidadas de otros lenguajes modernos y las integra de forma
      coherente y pragmática.
    </p>
    <p>Entre sus principios fundamentales se encuentran:</p>
    <List>
      <ListItem icon={Icons.Wrench}>
        <strong>Pragmatismo</strong>: resuelve problemas reales de forma
        efectiva, priorizando la practicidad sobre las restricciones
        artificiales.
      </ListItem>
      <ListItem icon={Icons.AlignLeft}>
        <strong>Concisión y legibilidad</strong>: su sintaxis reduce la
        verbosidad sin sacrificar claridad.
      </ListItem>
      <ListItem icon={Icons.ShieldCheck}>
        <strong>Seguridad</strong>: previene errores comunes en tiempo de
        compilación —como las referencias nulas— y fomenta un código más
        robusto.
      </ListItem>
      <ListItem icon={Icons.Eye}>
        <strong>Claridad intencional</strong>: promueve un estilo en el que la
        intención del código es explícita y fácil de comprender para otras
        personas.
      </ListItem>
    </List>
  </section>

  <section
    title="Beneficios y limitaciones de Kotlin en el desarrollo de bibliotecas de software"
  >
    <Heading headingLevel="h2" Icon={Icons.Scales}>
      Beneficios y limitaciones de Kotlin en el desarrollo de bibliotecas de
      software
    </Heading>

    <ProCons>
      <Pros>
        <List>
          <ListItem icon={Icons.ArrowsLeftRight}>
            <strong>Interoperabilidad con Java</strong> → Kotlin se integra sin fricciones
            con el ecosistema Java, lo que permite reutilizar bibliotecas existentes
            y adoptar el lenguaje de forma gradual, incluso en bases de código heredadas.
          </ListItem>
          <ListItem icon={Icons.Feather}>
            <strong>Sintaxis concisa y expresiva</strong> → Reduce la repetición
            de código, mejora la legibilidad y facilita el mantenimiento. Favorece
            el diseño de APIs limpias y DSLs orientadas a usabilidad.
          </ListItem>
          <ListItem icon={Icons.ShieldCheck}>
            <strong>Seguridad frente a nulls</strong> → Su sistema de tipos previene
            errores comunes como <InlineCode
              code="NullPointerException"
              lang="kotlin"
            />, reforzando la robustez de las APIs y facilitando contratos más
            confiables.
          </ListItem>
          <ListItem icon={Icons.PuzzlePiece}>
            <strong>Funciones de extensión</strong> → Permiten ampliar funcionalidades
            sin modificar clases originales, fomentando una arquitectura modular
            y extensible — ideal para bibliotecas reutilizables.
          </ListItem>
          <ListItem icon={Icons.Devices}>
            <strong>Compatibilidad multiplataforma</strong> → Posibilita crear bibliotecas
            que funcionan en JVM, JS y Native, promoviendo la reutilización de código
            entre diferentes entornos. Requiere seguir ciertas restricciones de API
            común.
          </ListItem>
          <ListItem icon={Icons.SpinnerGap}>
            <strong>Corrutinas integradas</strong> → Facilitan la programación asíncrona
            con una sintaxis clara y eficiente, lo que permite exponer APIs no bloqueantes
            en bibliotecas como clientes HTTP o SDKs.
          </ListItem>
          <ListItem icon={Icons.Terminal}>
            <strong>Facilidad para crear DSLs</strong> → Permite construir APIs idiomáticas,
            expresivas y personalizables, ideales para bibliotecas de configuración,
            testing o transformación de datos.
          </ListItem>
        </List>
      </Pros>
      <Cons>
        <List>
          <ListItem icon={Icons.WarningCircle}>
            <strong>Falta de algunas abstracciones avanzadas</strong> → Kotlin aún
            no ofrece soporte completo para conceptos como los <em
              >Higher-Kinded Types (HKT)</em
            > ni mecanismos como los
            <em>implicits</em> de Scala. Esta omisión es <strong
              >intencional</strong
            >: prioriza la claridad y la utilidad práctica. No obstante, ya se
            exploran propuestas como los <a
              href="https://kotlinlang.org/docs/whatsnew22.html#preview-of-context-parameters"
              >context parameters</a
            >, que podrían habilitar nuevos patrones funcionales sin comprometer
            legibilidad.
          </ListItem>
          <ListItem icon={Icons.Scan}>
            <strong>Ausencia de pattern matching exhaustivo</strong> → Kotlin no
            cuenta con un sistema de <em>pattern matching</em> tan expresivo como
            Scala, Rust o Haskell. Aunque <InlineCode
              code="when"
              lang="kotlin"
            /> y las jerarquías selladas permiten cierto control, no existe una sintaxis
            declarativa para hacer match de estructuras anidadas ni extraer múltiples
            valores simultáneamente.
          </ListItem>
        </List>
      </Cons>
    </ProCons>
    <p>
      Kotlin es una excelente opción para diseñar bibliotecas modernas, seguras
      y expresivas. Su enfoque pragmático lo convierte en una herramienta
      poderosa para la reutilización de código. Sin embargo, su decisión de no
      incluir ciertas abstracciones avanzadas puede limitar algunos estilos de
      diseño altamente genéricos o funcionales.
    </p>
    <p>
      A lo largo del curso aprenderás a <strong
        >sacar el máximo provecho de Kotlin</strong
      > en el diseño de bibliotecas, aprovechando sus fortalezas y <strong
        >encontrando soluciones pragmáticas cuando el lenguaje no provee una
        abstracción directamente</strong
      >.
    </p>
  </section>

  <section title="¿Qué distingue una expresión de una declaración?">
    <Heading headingLevel="h2" Icon={Icons.CodeBlock}>
      ¿Qué distingue una expresión de una declaración?
    </Heading>

    <p>
      En Kotlin, es importante distinguir entre <strong>expresiones</strong> y <strong
        >declaraciones</strong
      >, ya que cumplen funciones diferentes dentro de un programa. Esta
      distinción —también presente en lenguajes como Rust— <strong
        >favorece un estilo de programación más seguro y predecible</strong
      >.
    </p>
    <Definition headingLevel="h3">
      <span slot="title">Expresión</span>
      <p>
        Una <strong>expresión</strong> produce un valor y puede combinarse con otras.
        En Kotlin, esto incluye desde constantes hasta funciones anónimas. También
        lo son operaciones aritméticas, operadores lógicos y llamadas a funciones.
      </p>
    </Definition>
    <Definition headingLevel="h3">
      <span slot="title">Declaración</span>
      <p>
        Las <strong>declaraciones</strong> son instrucciones que <strong
          >realizan una acción</strong
        >. En general, <strong>no se usan por su valor</strong>, y no pueden
        combinarse con otras expresiones. Ejemplos comunes son la definición de
        variables, bucles o funciones.
      </p>
    </Definition>
    <p>
      Una diferencia clave con lenguajes como <strong
        >Java, C o JavaScript</strong
      > es que en esos lenguajes <strong
        >las asignaciones son expresiones</strong
      >, lo que puede llevar a errores como <InlineCode
        code="if (x = 5)"
        lang="c"
      /> cuando en realidad se quería comparar (<InlineCode
        code="if (x == 5)"
        lang="c"
      />). En Kotlin, <strong>las asignaciones son declaraciones</strong>, lo
      que impide este tipo de ambigüedades y permite que el compilador detecte
      errores más fácilmente.
    </p>
    <p>A continuación, una tabla con ejemplos representativos:</p>
    <Table>
      <TableCaption
        >Ejemplos de expresiones y declaraciones en Kotlin</TableCaption
      >
      <TableHeader>
        <TableRow>
          <TableCell>Ejemplo</TableCell>
          <TableCell>¿Expresión o declaración?</TableCell>
          <TableCell>¿Devuelve valor?</TableCell>
        </TableRow>
      </TableHeader>
      <TableBody>
        <TableRow>
          <TableCell>
            <InlineCode code="val x = 5" lang="kotlin" />
          </TableCell>
          <TableCell>Declaración</TableCell>
          <TableCell>No</TableCell>
        </TableRow>
        <TableRow>
          <TableCell>
            <InlineCode code="5" lang="kotlin" />
          </TableCell>
          <TableCell>Expresión</TableCell>
          <TableCell
            >Sí, el valor <InlineCode code="5" lang="kotlin" /></TableCell
          >
        </TableRow>
        <TableRow>
          <TableCell>
            <InlineCode code="if (a > b) a else b" lang="kotlin" />
          </TableCell>
          <TableCell>Expresión</TableCell>
          <TableCell
            >Sí, el valor de <InlineCode code="a" lang="kotlin" /> o <InlineCode
              code="b"
              lang="kotlin"
            /></TableCell
          >
        </TableRow>
        <TableRow>
          <TableCell>
            <InlineCode code="fun greet() { println() }" lang="kotlin" />
          </TableCell>
          <TableCell>Declaración</TableCell>
          <TableCell>No</TableCell>
        </TableRow>
      </TableBody>
    </Table>
    <Tip>
      <span slot="title">En resumen</span>
      <p>
        <List>
          <ListItem icon={Icons.ArrowElbowRight}>
            Las <strong>expresiones</strong> devuelven un valor y pueden ser combinadas
            con otras expresiones.
          </ListItem>
          <ListItem icon={Icons.Play}>
            Las <strong>declaraciones</strong> ejecutan acciones y no devuelven un
            valor, por lo que no pueden ser combinadas con otras expresiones.
          </ListItem>
        </List>
      </p>
    </Tip>
    <p>
      Esta diferencia <strong
        >promueve una programación más expresiva, segura y menos propensa a
        errores sutiles</strong
      >.
    </p>
  </section>
  <section title="Interpolación de cadenas">
    <Heading headingLevel="h2" Icon={Icons.CurrencyDollar}>
      Interpolación de cadenas
    </Heading>
    <p>
      La interpolación de cadenas —también conocida como string templates— es
      una característica de Kotlin que permite insertar valores o expresiones
      directamente dentro de un <InlineCode code="String" lang="kotlin" /> usando
      el símbolo <InlineCode code="$" lang="kotlin" />.
    </p>
    <p>
      Para insertar una variable, basta con escribir <InlineCode
        code="$variable"
        lang="kotlin"
      />. En el caso de expresiones, se deben usar llaves: <InlineCode
        code="${expresión}"
        lang="kotlin"
      />.
    </p>
    <section title="Ejemplo">
      <Heading headingLevel="h3" Icon={Icons.Sword}>Ejemplo</Heading>
      <p>
        En el siguiente ejemplo, mostramos el estado de un personaje según sus
        puntos de vida (<InlineCode code="hp" lang="kotlin" />):
      </p>
      <CodeBlock
        icon={Icons.Kotlin}
        code={`
          val name = "Leif"
          val hp = 24

          println("Unit: $name | Status: \${if (hp <= 0) "defeated" else "active"}")
        `}
        lang="kotlin"
        ><span slot="title">Interpolación de cadenas en acción</span></CodeBlock
      >
      <p>Esto imprimirá:</p>
      <CodeBlock
        icon={Icons.Terminal}
        code={`Unit: Leif | Status: active`}
        lang="plaintext"><span slot="title">Salida en consola</span></CodeBlock
      >
      <p>
        Gracias a la interpolación de cadenas, podemos construir mensajes
        dinámicos de forma <strong>más clara, concisa y expresiva</strong>,
        evitando la concatenación manual con operadores como <InlineCode
          code="+"
          lang="kotlin"
        />.
      </p>
      <p>
        Además, las expresiones interpoladas se evalúan <strong
          >en el momento en que se construye la cadena</strong
        >, lo que aporta claridad y eficiencia sin sobrecostos innecesarios.
      </p>
      <Tip>
        <span slot="title">Sin prefijos especiales</span>
        <p>
          A diferencia de otros lenguajes, como <strong>Scala</strong> (<InlineCode
            code=`s"Hola, $nombre"`
            lang="scala"
          />) o <strong>Python</strong> (<InlineCode
            code=`f"Hola, {nombre}"`
            lang="py"
          />), Kotlin <strong>no requiere prefijos</strong> como <InlineCode
            code="s"
            lang="scala"
          /> o <InlineCode code="f" lang="py" /> para habilitar la interpolación.
        </p>
        <p>
          En Kotlin, <strong
            >todas las cadenas admiten interpolación de forma nativa</strong
          >, lo que las hace más simples, legibles y menos propensas a errores.
        </p>
      </Tip>
      <More>
        <span slot="title">
          ¿Qué es un <InlineCode code="StringBuilder" lang="kotlin" />?
        </span>
        <p>
          Cuando interpolamos cadenas en Kotlin, el compilador genera código que
          usa internamente un
          <strong><InlineCode code="StringBuilder" lang="kotlin" /></strong>,
          una clase optimizada para construir texto de forma eficiente <strong
            >sin crear múltiples objetos intermedios</strong
          >.
        </p>
        <p>
          Esto es relevante porque en Kotlin (y en Java), las cadenas (<InlineCode
            code="String"
            lang="kotlin"
          />) son <strong>inmutables</strong>: cada vez que concatenas con <InlineCode
            code="+"
            lang="kotlin"
          />, se crea una nueva instancia, lo cual puede degradar el rendimiento
          en operaciones repetidas o dentro de bucles.
        </p>
        <p>
          Un <InlineCode code="StringBuilder" lang="kotlin" />, en cambio,
          permite <strong>modificar la cadena en memoria</strong>, agregando,
          insertando o eliminando texto sin copiar constantemente.
        </p>
        <p>Por ejemplo, esta interpolación:</p>
        <CodeBlock
          icon={Icons.Kotlin}
          code={`
            val name = "Leif"
            val status = "active"
            val message = "Unit: $name | Status: $status"
          `}
          lang="kotlin"
          ><span slot="title">Interpolación de cadenas</span></CodeBlock
        >
        <p>Se traduce internamente a algo similar a esto:</p>
        <CodeBlock
          icon={Icons.Kotlin}
          code={`
            val name = "Leif"
            val status = "active"
            val sb = StringBuilder()
            sb.append("Unit: ")
            sb.append(name)
            sb.append(" | Status: ")
            sb.append(status)
            val message = sb.toString()
          `}
          lang="kotlin"
          ><span slot="title">Traducción interna usando StringBuilder</span
          ></CodeBlock
        >
        <p>
          Gracias a esta conversión, la interpolación en Kotlin es <strong
            >más legible</strong
          > que la concatenación manual y <strong>más eficiente</strong> que usar
          <InlineCode code="+" lang="kotlin" /> repetidamente.
        </p>
      </More>
    </section>
  </section>
  <section title="Crear tu primer proyecto Kotlin con Gradle">
    <Heading headingLevel="h2" Icon={null}
      >Crear tu primer proyecto Kotlin con Gradle</Heading
    >
    <p>
      Antes de comenzar a escribir código Kotlin, necesitamos configurar un
      entorno de desarrollo funcional. En esta sección aprenderás cómo <strong
        >crear un proyecto Kotlin básico desde la terminal utilizando Gradle</strong
      >, el sistema de construcción que usaremos durante el curso.
    </p>
    <p>
      Gradle es una herramienta de automatización de construcción flexible y
      ampliamente utilizada en el ecosistema Kotlin y Java. Nos permitirá
      compilar, probar y empaquetar nuestras aplicaciones y bibliotecas de forma
      reproducible.
    </p>
    <p class="mb-4">
      Te proporcionamos instrucciones específicas para Windows, Linux y macOS:
    </p>
    <Tabs defaultValue="windows">
      <TabsList>
        <TabsTrigger value="windows">Windows (PowerShell)</TabsTrigger>
        <TabsTrigger value="macos">macOS (Bash)</TabsTrigger>
        <TabsTrigger value="linux">Linux (Bash)</TabsTrigger>
      </TabsList>
      <TabsContent value="windows">
        <InitializeKotlinApplicationPs1 />
      </TabsContent>
      <TabsContent value="macos">
        <InitializeKotlinApplicationBash os="macos" />
      </TabsContent>
      <TabsContent value="linux">
        <InitializeKotlinApplicationBash os="linux" />
      </TabsContent>
    </Tabs>
    <p class="mt-4">
      Por ahora, crearemos una <strong>aplicación de consola</strong> para probar
      nuestro código. Más adelante aprenderemos a utilizar Gradle para construir
      <strong>bibliotecas de software</strong> reutilizables.
    </p>
    <p>
      Una vez creado el proyecto, puedes abrirlo con <strong
        >IntelliJ IDEA</strong
      >, <strong>Fleet</strong> u otro editor. Aún no necesitas comprender a fondo
      la estructura del proyecto, pero es útil tener en cuenta sus directorios principales:
    </p>
    <List>
      <ListItem icon={Icons.FolderOpen}>
        El código fuente está en <InlineCode
          code="app/src/main/kotlin"
          lang="bash"
        />.
      </ListItem>
      <ListItem icon={Icons.Flask}>
        Las pruebas se ubican en <InlineCode
          code="app/src/test/kotlin"
          lang="bash"
        />.
      </ListItem>
    </List>
    <p>
      Si estás usando IntelliJ IDEA y tienes disponible la herramienta <InlineCode
        code="idea"
        lang="bash"
      /> en tu terminal, puedes abrir el proyecto con el siguiente comando:
    </p>
    <ShellBlock code="idea intro-kt" lang="bash">
      <span slot="title">Abrir proyecto en IntelliJ IDEA</span>
    </ShellBlock>
    <Explanation>
      Este comando abre el proyecto actual en IntelliJ IDEA, siempre que tengas
      habilitado el <a
        href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html"
        target="_blank"
        rel="noopener noreferrer">Command Line Launcher</a
      > (<InlineCode code="idea" lang="bash" />). Puedes activarlo desde el menú <InlineCode
        code="Tools > Create Command-line Launcher"
        lang="plaintext"
      />.
    </Explanation>
  </section>
  <section title="Ejercicio">
    <Exercise headingLevel="h2">
      <Fragment slot="title"> Un “Hello, World” con sentido </Fragment>
      <p>
        Ya creaste tu primer proyecto en Kotlin. Ahora es momento de <strong
          >darle voz propia</strong
        >.
      </p>
      <p>
        Tu tarea es <strong>explorar la estructura del proyecto</strong>,
        encontrar el <strong>punto de entrada del programa</strong> y modificarlo
        para que imprima un mensaje <strong
          >auténtico y significativo para ti</strong
        >.
      </p>
      <p>
        No se trata de un simple <InlineCode
          code=`"Hello, World"`
          lang="kotlin"
        />, sino de una frase que te represente. Algunas ideas:
      </p>
      <List>
        <ListItem icon={Icons.GameController}>
          Una línea de tu videojuego favorito
        </ListItem>
        <ListItem icon={Icons.Quotes}> Una cita que te inspira </ListItem>
        <ListItem icon={Icons.Smiley}> Un meme que te haga reír </ListItem>
        <ListItem icon={Icons.Pencil}>
          Una frase que hayas escrito tú mismx
        </ListItem>
      </List>
      <ShellBlock code="./gradlew :app:run" lang="bash">
        <span slot="title">Ejecutar el programa</span>
      </ShellBlock>
      <p>
        Si todo está bien configurado, tu mensaje aparecerá en la consola ✨
      </p>
      <Tip>
        <Fragment slot="title">Recuerda</Fragment>
        <p>
          No necesitas crear clases nuevas ni preocuparte por la estructura
          ideal. Simplemente disfruta de escribir tu primer programa en Kotlin.
        </p>
      </Tip>
      <Solution>
        <CodeBlock
          code={`
            package org.example

            class App {
                // [!code focus:2]
                val greeting: String
                    get() = "Ladies and Gentlemen, I give you Rose Red's killer..."
            }

            fun main() {
                println(App().greeting)
            }
          `}
          lang="kotlin"
          icon={Icons.Kotlin}
        >
          <a
            slot="source"
            href="https://gitlab.com/r8vnhill/intro-kt/-/blob/main/app/src/main/kotlin/org/example/App.kt?ref_type=heads"
            target="_blank"
            rel="noopener noreferrer">app/src/main/kotlin/org/example/App.kt</a
          >
        </CodeBlock>
      </Solution>
    </Exercise>
  </section>
  <ConclusionsLayout>
    <Fragment slot="conclusions">
      <p>
        En esta lección asentaste una base práctica de Kotlin: lo conociste como
        lenguaje <strong>pragmático</strong>, exploraste su sintaxis clara, la
        diferencia entre <strong>expresiones</strong> y <strong
          >declaraciones</strong
        >, y viste cómo la <strong>interpolación de cadenas</strong> mejora la legibilidad.
        Además, dejaste listo un proyecto con <strong>Gradle</strong>
        para ejecutar y evolucionar tus ejercicios.
      </p>
      <p>
        Con esto ya puedes leer y escribir pequeños programas idiomáticos y
        tienes el entorno de trabajo funcionando para continuar con temas más
        profundos.
      </p>
    </Fragment>
    <Fragment slot="key-points">
      <ListItem icon={Icons.Compass}>
        Kotlin prioriza <strong>claridad</strong> y <strong>seguridad</strong>
        sin sacrificar productividad.
      </ListItem>
      <ListItem icon={Icons.SplitHorizontal}>
        <strong>Expresiones</strong> producen valor; <strong
          >declaraciones</strong
        > ejecutan acciones.
      </ListItem>
      <ListItem icon={Icons.TextAa}>
        La <strong>interpolación</strong> (<InlineCode code="$" lang="kotlin" />
        / <InlineCode code="${...}" lang="kotlin" />) evita concatenaciones
        verbosas y se traduce eficientemente.
      </ListItem>
      <ListItem icon={Icons.Terminal}>
        Con <strong>Gradle</strong> puedes crear y ejecutar un proyecto base reproducible.
      </ListItem>
    </Fragment>
    <p slot="takeaways">
      La “caja de herramientas” inicial para seguir construyendo: un entorno que
      compila, un primer contacto con la <strong>filosofía del lenguaje</strong>
      y hábitos que nos acompañarán todo el curso: preferir la <strong
        >intencionalidad</strong
      > sobre la astucia, elegir construcciones <strong>expresivas</strong> y cuidar
      la <strong>legibilidad</strong> de las APIs.
    </p>
  </ConclusionsLayout>
  <References>
    <Fragment slot="recommended">
      <Book
        chapter="Kotlin: what and why"
        pages={[3, 16]}
        bookTitle="Kotlin in Action"
      >
        <AuthorList
          slot="authors"
          authors={[
            {
              lastName: "Jemerov",
              firstName: "Dmitry",
              url: "https://www.yole.page",
            },
            { lastName: "Isakova", firstName: "Svetlana" },
          ]}
        />
        <Fragment slot="description">
          Este capítulo introductorio presenta a Kotlin como un lenguaje
          moderno, conciso, seguro y pragmático que se integra perfectamente con
          Java. Explica sus principales características —como la inferencia de
          tipos, el soporte para programación funcional y orientada a objetos, y
          la interoperabilidad total con bibliotecas Java— y muestra cómo Kotlin
          se adapta a distintos contextos: desde el desarrollo de aplicaciones
          Android hasta servicios del lado del servidor. También se discuten su
          filosofía (pragmatismo, seguridad, concisión e interoperabilidad), las
          herramientas disponibles (REPL, plug-ins para IntelliJ y Eclipse,
          playground online), y mecanismos como el convertidor Java→Kotlin para
          facilitar su adopción. El libro está principalmente orientado a
          estudiantes con conocimientos básicos de Java que buscan transicionar
          a un lenguaje más moderno y expresivo.
        </Fragment>
      </Book>
    </Fragment>
  </References>
</NotesLayout>
 