---
import * as icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Note, Tip } from "~/components/ui/callouts";
import { InlineKotlin, KotlinBlock } from "~/components/ui/code";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, References, WebPage } from "~/components/ui/references";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Lógica de negocio y lógica de aplicación">
  <Abstract>
    <p>
      En la lección anterior entendimos que <strong
        >una biblioteca es, en esencia, una API</strong
      >: un conjunto de funciones, tipos y abstracciones diseñadas para ser
      reutilizadas en distintos contextos. Pero surge una pregunta clave: <strong
        >¿qué ponemos dentro de la biblioteca y qué dejamos fuera?</strong
      >
    </p>
    <p>
      La respuesta está en distinguir entre <strong>lógica de negocio</strong>
      —las reglas e invariantes que definen el dominio y permanecen estables— y
      <strong>lógica de aplicación</strong> —la capa que traduce, coordina y adapta
      esas reglas a un entorno tecnológico concreto (frameworks, bases de datos,
      interfaces, protocolos).
    </p>
    <p>
      Comprender esta separación es fundamental para construir bibliotecas
      reutilizables, mantenibles y resistentes al cambio tecnológico.
    </p>
  </Abstract>

  <NotesSection id="business-logic">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Cube}>
      Lógica de negocio
    </Heading>

    <p>
      La <strong>lógica de negocio</strong> (business logic), a veces también llamada
      <strong>core</strong> del sistema, representa las
      <strong
        >reglas, invariantes y operaciones fundamentales del dominio</strong
      >
      que queremos modelar. Es lo que permanece estable incluso si cambiamos la interfaz
      de usuario, el framework web o la forma en que desplegamos el sistema.
    </p>

    <List>
      <ListItem icon={icons.Target}>
        Define el <strong>qué</strong> hace el sistema, no el <strong
          >cómo</strong
        > se presenta o ejecuta.
      </ListItem>
      <ListItem icon={icons.Gear}>
        Vive en la biblioteca, porque es lo que buscamos <strong
          >reutilizar, probar y mantener aislado</strong
        > de los detalles externos.
      </ListItem>
    </List>

    <NotesSection id="example-business-logic">
      <Heading headingLevel="h3" Icon={icons.ShoppingCart}>
        Ejemplo: Sistema de pedidos en un e-commerce
      </Heading>

      <p>
        Si estamos construyendo un sistema de pedidos en un e-commerce, la
        lógica de negocio define reglas como:
      </p>

      <List>
        <ListItem icon={icons.Package}>
          Un pedido debe tener al menos un ítem.
        </ListItem>
        <ListItem icon={icons.CreditCard}>
          No se puede despachar un pedido que no esté pagado.
        </ListItem>
        <ListItem icon={icons.Truck}>
          El cálculo del total considera descuentos y envío.
        </ListItem>
      </List>

      <Tip>
        La lógica de negocio no depende de si la aplicación es web, móvil o de
        línea de comandos:
        <strong> cambian las interfaces, pero las reglas se mantienen</strong>.
      </Tip>
    </NotesSection>
  </NotesSection>

  <NotesSection id="app-logic">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Play}>
      Lógica de aplicación
    </Heading>

    <p>
      La <strong>lógica de aplicación</strong> se refiere al
      <strong>entorno donde la lógica de negocio se usa y coordina</strong>.
      Incluye los detalles de frameworks, almacenamiento, presentación y
      orquestación de acciones. A diferencia de la lógica de negocio, suele
      cambiar con mayor frecuencia porque depende de tecnologías y protocolos.
    </p>

    <List>
      <ListItem icon={icons.Users}>
        Define el <strong>cómo</strong> interactúan las personas usuarias o sistemas
        externos con la lógica de negocio.
      </ListItem>
      <ListItem icon={icons.AppWindow}>
        No pertenece a la biblioteca: vive en un servicio, aplicación o
        interfaz.
      </ListItem>
    </List>

    <NotesSection id="example-app-logic">
      <Heading headingLevel="h3" Icon={icons.Cloud}>
        Ejemplo: Backend web para e-commerce
      </Heading>

      <p>
        Si seguimos con el ejemplo del sistema de pedidos, la lógica de
        aplicación se encarga de:
      </p>

      <List>
        <ListItem icon={icons.Download}>
          Recibir una solicitud HTTP para crear un pedido.
        </ListItem>
        <ListItem icon={icons.Code}>
          Convertir la entrada JSON a objetos de negocio (<code>Order</code>, <code
            >Item</code
          >).
        </ListItem>
        <ListItem icon={icons.PlayCircle}>
          Llamar a las funciones de la lógica de negocio.
        </ListItem>
        <ListItem icon={icons.Database}>
          Guardar el resultado en una base de datos.
        </ListItem>
        <ListItem icon={icons.Upload}>
          Responder con un código HTTP apropiado.
        </ListItem>
      </List>
    </NotesSection>
  </NotesSection>
  <NotesSection id="library-contains-business-logic">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Books}>
      La biblioteca contiene la lógica de negocio
    </Heading>

    <p>Al separar estas dos capas, queda claro qué debe ir en la biblioteca:</p>

    <List>
      <ListItem icon={icons.Cube}>
        La <strong>biblioteca</strong> implementa la <strong
          >lógica de negocio</strong
        >.
      </ListItem>
      <ListItem icon={icons.AppWindow}>
        La <strong>aplicación</strong> integra esa lógica con tecnologías concretas
        (frameworks web, CLI, UI, etc.).
      </ListItem>
    </List>

    <p>Esto trae beneficios:</p>

    <List>
      <ListItem icon={icons.Repeat}>
        <strong>Reutilización</strong>: la misma lógica de negocio puede usarse
        en una app web, móvil o un script de automatización.
      </ListItem>
      <ListItem icon={icons.Check}>
        <strong>Pruebas más simples</strong>: es posible verificar reglas del
        negocio sin depender de HTTP, bases de datos o UI.
      </ListItem>
      <ListItem icon={icons.Wrench}>
        <strong>Mantenibilidad</strong>: los cambios en frameworks o detalles
        técnicos no afectan las reglas del dominio.
      </ListItem>
      <ListItem icon={icons.ArrowsLeftRight}>
        <strong>Portabilidad</strong>: si mañana cambiamos de framework, la
        lógica de negocio sigue siendo válida.
      </ListItem>
    </List>

    <Note class="mt-4">
      Aunque la distinción suele ser clara, la línea entre lógica de negocio y
      lógica de aplicación puede ser difusa en ciertos escenarios. Por ejemplo,
      la interacción con una base de datos normalmente pertenece a la lógica de
      aplicación. Sin embargo, podríamos diseñar una biblioteca que modele <em
        >cómo</em
      > se consulta o persiste información, siempre a través de <strong
        >abstracciones</strong
      >. La conexión concreta a la base de datos (drivers, pools, transacciones)
      sigue ocurriendo en la capa de aplicación.
    </Note>
  </NotesSection>

  <NotesSection id="real-example">
    <Heading slot="heading" headingLevel="h2" Icon={icons.PlayCircle}>
      Ejemplo real
    </Heading>

    <p>
      La misma función de <strong>lógica de negocio</strong> se usa desde dos contextos
      de <strong>lógica de aplicación</strong>: una API REST y una interfaz de
      usuario. Observa cómo las reglas viven en la biblioteca, y la
      orquestación/delivery vive en la aplicación.
    </p>

    <p>
      Para ilustrar esto usaremos <strong>Ktor</strong> (un framework ligero para
      crear servidores en Kotlin) y <strong>Compose</strong> (un toolkit para construir
      interfaces declarativas). Podríamos haber usado otras alternativas, como Spring
      Boot o Micronaut en lugar de Ktor, o JavaFX en lugar de Compose. El punto clave
      es que las tecnologías de aplicación pueden cambiar, mientras que la lógica
      de negocio permanece en la biblioteca.
    </p>

    <KotlinBlock
      code={`
        fun createOrder(products: Set<Pair<String, Int>>): Map<String, Int> {
            require(products.isNotEmpty()) {
              "Un pedido debe tener al menos un ítem."
            }
            return products.toMap()
        }
      `}
    >
      <Fragment slot="title">
        <strong>Lógica de negocio:</strong> valida las reglas e implementa el dominio.
      </Fragment>
    </KotlinBlock>

    <KotlinBlock
      code={`
        post("/orders") {
            // Lógica de aplicación:
            // 1) Recibir datos externos (JSON: {"skuA": 2, "skuB": 1})
            val body: Map<String, Int> = call.receive()

            // 2) Convertir entrada a tipos del dominio
            val products: Set<Pair<String, Int>> =
                body.entries.map { it.key to it.value }.toSet()

            // 3) Invocar la lógica de negocio
            val order: Map<String, Int> = createOrder(products)

            // 4) Responder (p. ej., 201 + contenido)
            call.respond(order)
        }
      `}
    >
      <Fragment slot="title">
        <strong>Lógica de aplicación (API REST):</strong> adapta HTTP↔️dominio y
        delega en <InlineKotlin code={`createOrder`} />.
      </Fragment>
    </KotlinBlock>

    <KotlinBlock
      code={`
        @Composable
        fun OrderScreen() {
            // Lógica de aplicación (UI):
            // Preparar entrada desde la vista (ejemplo minimal)
            val selectedProducts: Set<Pair<String, Int>> =
                setOf("skuA" to 2, "skuB" to 1)

            // Delegar la regla de negocio al core
            val order: Map<String, Int> = createOrder(selectedProducts)

            // Mostrar resultado (presentación)
            val totalItems = order.values.sum()
            Text(text = "Pedido creado · ítems: $totalItems")
        }
      `}
    >
      <Fragment slot="title">
        <strong>Lógica de aplicación (UI):</strong> obtiene datos de la vista, llama
        a <InlineKotlin code={`createOrder`} /> y presenta el resultado.
      </Fragment>
    </KotlinBlock>

    <Tip class="mt-3">
      Las reglas del dominio se mantienen en la función de la biblioteca. La
      aplicación solo <em>traduce</em> entradas/salidas (HTTP, UI) y orquesta el
      flujo. Cambiar Ktor por otro framework web, o Compose por otro toolkit de UI,
      no afecta la validez de <InlineKotlin code={`createOrder`} />.
    </Tip>
  </NotesSection>

  <ConclusionsLayout>
    <Fragment slot="conclusions">
      <p>
        La distinción entre <strong>lógica de negocio</strong> y
        <strong>lógica de aplicación</strong> nos entrega una brújula clara para
        decidir qué debe vivir en una biblioteca y qué pertenece a la aplicación.
        La primera concentra las reglas del dominio y se mantiene estable, mientras
        que la segunda traduce y orquesta esas reglas en entornos concretos como
        APIs, interfaces gráficas o servicios en la nube.
      </p>
      <p>
        Esta separación no solo favorece la <strong>reutilización</strong>,
        <strong>pruebas más simples</strong> y <strong>portabilidad</strong>,
        sino que también nos prepara para el siguiente paso: preguntarnos
        <em>cómo representamos esas reglas e invariantes en código</em>. Es aquí
        donde entran en juego los <strong>modelos de dominio</strong>.
      </p>
    </Fragment>

    <Fragment slot="key-points">
      <ListItem icon={icons.Cube}>
        La biblioteca implementa la lógica de negocio: reglas, invariantes y
        operaciones fundamentales del dominio.
      </ListItem>
      <ListItem icon={icons.AppWindow}>
        La aplicación implementa la lógica de aplicación: frameworks, UI, bases
        de datos y orquestación de acciones.
      </ListItem>
      <ListItem icon={icons.Repeat}>
        Separar ambas capas aumenta la reutilización, la mantenibilidad y la
        portabilidad de las soluciones.
      </ListItem>
      <ListItem icon={icons.Check}>
        Esta división abre paso a diseñar modelos de dominio más expresivos,
        precisos y alineados con las necesidades reales.
      </ListItem>
    </Fragment>

    <Fragment slot="takeaways">
      <p>
        El gran aprendizaje es que <strong
          >las bibliotecas deben capturar el corazón del dominio</strong
        >, mientras que la aplicación se adapta al contexto tecnológico. Con
        esta base clara, estamos listxs para explorar cómo dar forma a esas
        reglas a través de <strong>modelos de dominio</strong>: estructuras de
        datos y tipos que representan con precisión el mundo que queremos
        modelar.
      </p>
    </Fragment>
  </ConclusionsLayout>

  <References>
    <Fragment slot="recommended">
      <WebPage
        title="Qué es la lógica de negocio en programación y cómo distinguirla de la lógica de aplicación y de pantalla"
        url="https://albertcapdevila.net/logica-negocio-programacion/"
      >
        <AuthorList
          slot="author"
          authors={[
            {
              firstName: "Albert",
              lastName: "Capdevila",
              url: "https://albertcapdevila.net/",
            },
          ]}
        />
        <Fragment slot="description">
          Explica cómo diferenciar tres tipos de lógica en un sistema de
          software: <strong>lógica de negocio</strong> (reglas e invariantes del
          dominio), <strong>lógica de aplicación</strong> (coordinación técnica y
          persistencia) y <strong>lógica de pantalla</strong> (decisiones de interfaz).
          A través de ejemplos claros, como facturas y gestión de stock, muestra
          cómo ubicar cada tipo de lógica en la arquitectura y cómo esta separación
          favorece la comunicación en el equipo y la mantenibilidad del código.
        </Fragment>
      </WebPage>
    </Fragment>
  </References>
</NotesLayout>
