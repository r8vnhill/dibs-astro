---
import * as icons from "~/assets/img/icons";
import { P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Definition, Explanation, Important, Tip } from "~/components/ui/callouts";
import CodeBlock from "~/components/ui/code/CodeBlock.astro";
import InlineCode from "~/components/ui/code/InlineCode.astro";
import NushellInline from "~/components/ui/code/nushell/NushellInline.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { List, ListItem } from "~/components/ui/list";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Nushell: comparación para quienes vienen de PowerShell"
    description="Cómo se ve el scripting en Nushell si ya dominas PowerShell: pipeline de registros, tablas por defecto y comandos orientados a datos."
>
    <Abstract>
        <P>
            Esta nota compara <b>Nushell</b> con lo que ya viste en <b>PowerShell</b>. No repite fundamentos: asume que
            ya leíste la lección original y que comprendes conceptos como variables, pipelines y composición.
        </P>
        <P>
            Aquí verás <b>cómo se expresan esas mismas ideas en Nushell</b> y en qué escenarios Nushell puede resultar
            más conveniente, sobre todo cuando trabajas con datos tabulares y formatos estructurados.
        </P>
    </Abstract>

    <NotesSection id="h2-nushell-pipeline">
        <Heading headingLevel="h2" Icon={icons.FlowArrow} slot="heading">
            Pipeline y datos estructurados en Nushell
        </Heading>

        <Definition>
            <Fragment slot="title">¿Qué fluye por el pipeline?</Fragment>

            <P>
                En Nushell <b>fluyen filas (registros) y tablas</b>. Muchos comandos emiten tablas con columnas 
                tipadas; filtrar, ordenar y proyectar columnas es natural y conciso.
            </P>
        </Definition>

        <Explanation>
            <P>
                Listar archivos y quedarte con los nombres de los <Mono>*.md</Mono> más recientes:
            </P>

            <CodeBlock lang="nu" icon={icons.FileText} title="Filtrar y proyectar en tablas" code={`
ls | where type == File | where name ends-with '.md' | sort-by modified -r | get name
`} />

            <P class="mt-3">
                Abrir un JSON y consultar campos anidados es directo porque Nushell <b>parsea a registros</b>:
            </P>

            <CodeBlock lang="nu" icon={icons.BracketsCurly} title="Abrir y consultar JSON" code={`
open package.json | get scripts.build
`} />
        </Explanation>
    </NotesSection>

    <NotesSection id="h2-nushell-rutas">
        <Heading headingLevel="h2" Icon={icons.FolderOpen} slot="heading">
            Rutas y portabilidad
        </Heading>

        <P>
            Para construir rutas portables, usa <NushellInline code="path join" /> en lugar de concatenar strings:
        </P>

        <CodeBlock lang="nu" icon={icons.FolderOpen} title="Construir rutas portables" code={`
let scripts = (path join 'dibs' 'scripts')
mkdir $scripts
`} />

        <Tip>
            <span slot="title">Redirección silenciosa</span>
            Si querés ocultar salida en la terminal, podés usar <InlineCode code="> /dev/null" /> en sistemas Unix, o 
            directamente confiar en comandos que no emiten salida cuando todo salió bien (muchos subcomandos de Nushell son silenciosos por defecto).
        </Tip>
    </NotesSection>

    <NotesSection id="h2-nushell-ventajas">
        <Heading headingLevel="h2" Icon={icons.Sparkle} slot="heading">
            ¿Qué ofrece Nushell que puede resultarte útil?
        </Heading>

        <List class="mt-2">
            <ListItem icon={icons.Table}>
                <b>Tablas primero</b>: la salida de muchos comandos ya es tabular. Operaciones como <Mono>where</Mono>, <Mono>get</Mono>,
                <Mono>select</Mono> y <Mono>group-by</Mono> son concisas y consistentes.
            </ListItem>
            <ListItem icon={icons.BracketsCurly} class="mt-2">
                <b>Soporte nativo para formatos</b>: <Mono>open</Mono> detecta <Mono>.json</Mono>, <Mono>.toml</Mono>, 
                <Mono>.csv</Mono>, etc., y los convierte a datos estructurados listos para consultar.
            </ListItem>
            <ListItem icon={icons.ChartBar} class="mt-2">
                <b>Trabajo con datos</b>: con paquetes opcionales como <Mono>dfr</Mono> (basado en Polars) podés 
                realizar transformaciones de tipo dataframe directamente desde el shell.
            </ListItem>
        </List>

        <Important>
            <span slot="title">¿Hay algo que se pueda en Nushell y no en PowerShell?</span>
            En la práctica, ambos shells son muy capaces. Nushell destaca por su <b>UX tabular integrada</b> y por 
            su <b>línea de comandos centrada en datos estructurados</b> desde el diseño —lo que simplifica ciertos
            flujos con JSON/CSV/Parquet sin escribir código adicional. PowerShell, por su parte, se apoya en <Mono>.NET</Mono>
            y su ecosistema, ofreciendo integración profunda con APIs y tipos del runtime.
        </Important>
    </NotesSection>

    <NotesSection id="h2-nushell-ejemplos">
        <Heading headingLevel="h2" Icon={icons.Terminal} slot="heading">
            Ejemplos rápidos en Nushell
        </Heading>

        <CodeBlock lang="nu" icon={icons.Clock} title="Tiempo total de archivos .log" code={`
ls *.log | get size | math sum
`} />

        <CodeBlock lang="nu" icon={icons.MagnifyingGlass} title="Buscar texto en archivos y devolver coincidencias" code={`
rg -n "error" | lines | where $it != "" | first 5
`} />

        <CodeBlock lang="nu" icon={icons.ArrowRight} title="Convertir CSV a JSON" code={`
open data.csv | to json
`} />
    </NotesSection>

    <NotesSection id="h2-nushell-cierre">
        <Heading headingLevel="h2" Icon={icons.Check} slot="heading">
            Cierre
        </Heading>

        <P>
            Si ya venís de PowerShell, Nushell te resultará familiar en espíritu: pipelines expresivos, comandos
            composables y foco en automatizar. La diferencia es de énfasis: Nushell optimiza <b>consultar y transformar
            datos</b> en la propia terminal.
        </P>
    </NotesSection>
</NotesLayout>
