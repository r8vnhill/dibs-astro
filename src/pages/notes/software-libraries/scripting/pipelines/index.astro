---
import * as icons from "~/assets/img/icons";
import { P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Info,
    More,
    Question,
    Solution,
    Tip,
    Warning,
} from "~/components/ui/callouts";
import { CodeBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { Mono } from "~/components/ui/font";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import { List, ListItem } from "~/components/ui/list";
import { References, WebPage } from "~/components/ui/references";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Pipelines I: PowerShell declarativo"
    description="Cómo mapear conceptos conocidos (FP, method chaining y SQL) al pipeline de PowerShell: una sintaxis declarativa para componer transformaciones."
    timeMultiplier={2}
>
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-pipeline-intuition">
        <Heading headingLevel="h2" Icon={icons.ArrowsMerge}>
            Pensar en pasos: de colecciones al pipeline de PowerShell
        </Heading>

        <P>
            Antes de hablar del <B>pipeline</B> de PowerShell, pensemos en una idea más simple:
            <B>procesar una colección paso a paso</B>.
        </P>

        <P>
            En muchos lenguajes, cuando tienes una colección de datos, aplicas una secuencia de
            operaciones:
            <I>filtrar</I>, <I>transformar</I>, <I>eliminar duplicados</I>, <I>limitar
                resultados</I>. Cada paso toma el resultado del anterior.
        </P>

        <Definition>
            <Fragment slot="title">Transformaciones encadenadas</Fragment>
            <P>
                Una <B>transformación</B> recibe una colección de entrada y produce otra colección
                de salida. Al encadenarlas, describes <I>qué</I> quieres hacer con los datos, no
                <I>cómo</I> recorrerlos elemento por elemento.
            </P>
        </Definition>

        <Info>
            <span slot="title">El mismo problema, expresado como pasos</span>

            <CodeBlock
                lang="scala"
                code={`
                    users
                        .filter(_.active)
                        .map(_.email)
                        .distinct
                        .take(10)
                `}
            >
                <Fragment slot="title">Colecciones con operaciones encadenadas (Scala)</Fragment>
            </CodeBlock>

            <CodeBlock
                lang="python"
                code={`list(
    islice(
        dict.fromkeys(
            map(
                lambda u: u.email,
                filter(lambda u: u.active, users)
            )
        ),
        10
    )
)`}
            >
                <Fragment slot="title"
                >Colecciones con funciones de orden superior (Python)</Fragment>
            </CodeBlock>

            <CodeBlock
                lang="sql" code={`SELECT DISTINCT email
FROM users
WHERE active = TRUE
LIMIT 10;`}
            >
                <Fragment slot="title">Consulta declarativa (SQL)</Fragment>
            </CodeBlock>
        </Info>

        <P>
            Aunque la sintaxis cambia, la <B>idea es siempre la misma</B>:
        </P>

        <List>
            <ListItem icon={icons.Funnel}>
                Quedarse solo con los elementos que cumplen una condición.
            </ListItem>
            <ListItem icon={icons.CursorText}>
                Extraer un dato relevante de cada elemento.
            </ListItem>
            <ListItem icon={icons.Copy}>
                Eliminar duplicados.
            </ListItem>
            <ListItem icon={icons.ArrowDown}>
                Tomar solo una cantidad limitada de resultados.
            </ListItem>
        </List>

        <More>
            <span slot="title">¿Dónde entra PowerShell?</span>

            <P>
                El <B>pipeline de PowerShell</B> es otra forma de expresar exactamente esta misma
                idea, pero en lugar de encadenar métodos o funciones, <B>conecta comandos</B>.
            </P>

            <P>
                Cada comando:
            </P>

            <List>
                <ListItem icon={icons.Cube}>
                    recibe <B>objetos</B> como entrada,
                </ListItem>
                <ListItem icon={icons.ArrowRight}>
                    procesa uno a uno,
                </ListItem>
                <ListItem icon={icons.ArrowElbowRight}>
                    y envía el resultado al siguiente comando.
                </ListItem>
            </List>

            <P>
                Esa conexión se escribe con el operador <Mono>|</Mono>, que puedes leer como
                <I>“pasa el resultado a…”</I>.
            </P>
        </More>

        <Info>
            <span slot="title">El mismo flujo expresado como pipeline</span>

            <PowerShellBlock
                code={`Import-Csv users.csv |
Where-Object { $_.active -eq 'true' } |
Select-Object -ExpandProperty email |
Sort-Object -Unique |
Select-Object -First 10`}
            >
                <Fragment slot="title">Pipeline en PowerShell</Fragment>
            </PowerShellBlock>
        </Info>

        <Explanation>
            <List>
                <ListItem icon={icons.Pipe}>
                    <B><Mono>|</Mono> conecta pasos:</B> no es “texto”, son objetos que fluyen entre
                    comandos.
                </ListItem>
                <ListItem icon={icons.Funnel}>
                    <B>Filtrar temprano:</B> igual que en SQL o FP, reduces trabajo en los pasos
                    siguientes.
                </ListItem>
                <ListItem icon={icons.Stack}>
                    <B>Procesamiento incremental:</B> PowerShell no necesita cargar todo en memoria
                    para empezar a trabajar.
                </ListItem>
                <ListItem icon={icons.FileText}>
                    <B>La salida final decide el formato:</B> solo al final conviertes a texto,
                    archivo o reporte.
                </ListItem>
            </List>
        </Explanation>
    </NotesSection>

    <NotesSection id="h2-por-que-declarativa">
        <Heading headingLevel="h2" Icon={icons.Tag}>
            ¿Por qué queremos una sintaxis declarativa?
        </Heading>

        <p class="mb-2">
            Ahora que entendemos por qué el procesamiento en streaming es valioso, veamos cómo
            PowerShell lo aplica a su modelo de ejecución: el <I>pipeline</I>.
        </p>

        <p class="mb-2">
            El operador de <I>pipeline</I> (<PowerShellInline code="|" />) conecta comandos pasando
            <B>objetos</B> de uno a otro. A diferencia de otros shells que encadenan texto,
            PowerShell transmite <I>instancias con propiedades</I>
            (por ejemplo, <PowerShellInline code="FileInfo" />), lo que permite filtrar, transformar
            y exportar datos sin parseo frágil. El pipeline opera en <I>streaming</I>: cada objeto
            se envía al siguiente comando apenas está disponible, permitiendo trabajar con grandes
            volúmenes sin cargar todo en memoria.
        </p>

        <Definition headingLevel="h4">
            <Fragment slot="title">Ventajas prácticas</Fragment>
            <List>
                <ListItem icon={icons.FileText}>
                    <B>Legibilidad:</B> el flujo se lee como una historia (fuente → filtro →
                    transformación → orden → límite → salida).
                </ListItem>
                <ListItem icon={icons.Pipe}>
                    <B>Composición:</B> cambias una etapa sin reescribir todo el procedimiento.
                </ListItem>
                <ListItem icon={icons.Gear}>
                    <B>Optimizable:</B> filtrar temprano y cortar (<PowerShellInline
                        code="-First"
                    />) reduce trabajo (igual que un optimizador empuja <I>WHERE</I> hacia abajo).
                </ListItem>
                <ListItem icon={icons.ListChecks}>
                    <B>Razonable y testeable:</B> cada etapa tiene contrato claro (entrada →
                    salida), con menos estado mutable.
                </ListItem>
            </List>
        </Definition>
        <Tip headingLevel="h4">
            <span slot="title">SQL como espejo</span>
            <P>
                SQL funciona porque describe <I>qué</I> quieres y delega el <I>cómo</I> al motor. En
                pipelines buscamos el mismo beneficio: un vocabulario de transformaciones para
                <B>reordenar</B>, <B>cortar temprano</B>, <B>instrumentar</B> y <B>componer</B> sin
                ensuciar la intención.
            </P>
        </Tip>

        <PowerShellBlock
            code={`
                Get-ChildItem -Path $HOME -Recurse -File |
                    Where-Object { $_.Length -gt 0 } |
                    Sort-Object Length -Descending |
                    Select-Object FullName, Length -First 10 |
                    Export-Csv "top10.csv" -NoTypeInformation
            `}
        >
            <Fragment slot="title">
                Top 10 archivos más grandes en tu carpeta de usuario
            </Fragment>
        </PowerShellBlock>

        <Explanation>
            <p class="mb-2">
                Este flujo recorre archivos, descarta los de longitud cero, los ordena por tamaño,
                toma los 10 mayores y los exporta a CSV. Observa cómo cada comando asume una <I
                >responsabilidad única</I> y clara:
            </p>

            <List>
                <ListItem icon={icons.FolderOpen}>
                    <PowerShellInline code="Get-ChildItem -Recurse -File" /> emite objetos
                    <PowerShellInline code="FileInfo" /> de forma secuencial (<I>streaming</I>).
                </ListItem>

                <ListItem icon={icons.Funnel}>
                    <PowerShellInline code="Where-Object { $_.Length -gt 0 }" /> filtra <B
                    >temprano</B> para reducir lo que fluye.
                </ListItem>

                <ListItem icon={icons.ArrowsDownUp}>
                    <PowerShellInline code="Sort-Object Length -Descending" /> ordena por una
                    propiedad sin convertir a texto.
                </ListItem>

                <ListItem icon={icons.ListChecks}>
                    <PowerShellInline code="Select-Object ... -First 10" /> limita el flujo tras
                    obtener lo necesario, sin cargar todo en memoria.
                </ListItem>

                <ListItem icon={icons.FileText}>
                    <PowerShellInline code='Export-Csv "top10.csv"' /> materializa el resultado en
                    formato CSV (Comma-Separated Values) en el directorio actual. Puedes ver el
                    archivo con VSCode usando
                    <PowerShellInline code="code top10.csv" />.
                </ListItem>
            </List>
        </Explanation>

        <Warning>
            <Fragment slot="title">
                Cuidado con cortar el pipeline demasiado pronto
            </Fragment>

            <p class="mb-1">
                Cmdlets de formato (<PowerShellInline code="Format-Table" />, <PowerShellInline
                    code="Format-List"
                />) producen <I>objetos de formato</I>, no datos reales. Si los usas en medio del
                flujo, los siguientes comandos no verán las propiedades originales.
            </p>
            <p>
                Evita usarlos hasta el final del pipeline —prefiere <PowerShellInline
                    code="Select-Object"
                /> o
                <PowerShellInline code="Out-File" /> si necesitas preparar la salida antes.
            </p>
        </Warning>

        <NotesSection id="h3-declarative-chaining">
            <Heading headingLevel="h3" Icon={icons.Pipe}>
                Del pipeline al method chaining (Scala) y a SQL
            </Heading>

            <p class="mb-2">
                La idea central del pipeline es la misma que en la <B>programaci¢n funcional</B> y
                en APIs de <B>method chaining</B>: construir un flujo como una <B>composici¢n de
                    pasos peque¤os</B>. Cada paso recibe una entrada, produce una salida, y el
                siguiente paso decide qu‚ hacer con ella.
            </p>

            <p class="mb-2">
                Lo valioso no es solo el streaming, sino la <B>sintaxis declarativa</B>: expresar
                <I>qu‚</I> quieres (filtrar, proyectar, ordenar, limitar) sin escribir un bucle
                imperativo con variables temporales.
            </p>

            <Definition headingLevel="h4">
                <Fragment slot="title">Por qu‚ queremos una sintaxis declarativa</Fragment>
                <List>
                    <ListItem icon={icons.FileText}>
                        <B>Legibilidad:</B> el flujo se lee como una historia (fuente -> filtro ->
                        transformaci¢n -> orden -> l¡mite -> salida).
                    </ListItem>
                    <ListItem icon={icons.Pipe}>
                        <B>Composici¢n:</B> cambias una etapa sin reescribir todo el procedimiento.
                    </ListItem>
                    <ListItem icon={icons.Gear}>
                        <B>Optimizable:</B> filtrar temprano y cortar con <PowerShellInline
                            code="-First"
                        /> reduce trabajo (igual que un optimizador empuja <I>WHERE</I> hacia
                        abajo).
                    </ListItem>
                    <ListItem icon={icons.ListChecks}>
                        <B>Razonable y testeable:</B> cada etapa tiene contrato claro (entrada ->
                        salida), con menos estado mutable.
                    </ListItem>
                </List>
            </Definition>

            <Info headingLevel="h4">
                <span slot="title">El mismo contrato en PowerShell, Scala y SQL</span>
                <p class="mb-2">
                    Tres notaciones para el mismo objetivo: "dame los 10 correos £nicos de usuarios
                    activos".
                </p>

                <PowerShellBlock
                    code={`Import-Csv users.csv |
Where-Object { $_.active -eq 'true' } |
Select-Object -ExpandProperty email |
Sort-Object -Unique |
Select-Object -First 10`}
                >
                    <Fragment slot="title">Pipeline (PowerShell)</Fragment>
                </PowerShellBlock>

                <CodeBlock
                    lang="scala"
                    code={`users
  .filter(_.active)
  .map(_.email)
  .distinct
  .take(10)`}
                >
                    <Fragment slot="title">Method chaining (Scala)</Fragment>
                </CodeBlock>

                <CodeBlock
                    lang="sql" code={`SELECT DISTINCT email
FROM users
WHERE active = TRUE
LIMIT 10;`}
                >
                    <Fragment slot="title">Consulta declarativa (SQL)</Fragment>
                </CodeBlock>

                <Tip headingLevel="h4">
                    <span slot="title">Por qu‚ SQL es un gran espejo</span>
                    <p>
                        SQL funciona porque describe <I>qu‚</I> quieres y delega el <I>c¢mo</I> al
                        motor (planificador/optimizador). En pipelines buscamos el mismo beneficio:
                        un vocabulario de transformaciones para poder <B>reordenar</B>, <B>cortar
                            temprano</B>, <B>instrumentar</B> y <B>componer</B> sin ensuciar la
                        intenci¢n del flujo.
                    </p>
                </Tip>
            </Info>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-ejercicio">
        <Heading headingLevel="h2" Icon={icons.ListChecks}>
            Ejercicio corto
        </Heading>
        <Exercise>
            <span slot="title">Traducir cadenas declarativas a PowerShell</span>
            <Info>
                <span slot="title">Entrada</span>
                <List>
                    <ListItem icon={icons.Code}>
                        Un pequeño pipeline en Python (ver arriba) que <I>filtra</I>, <I
                        >proyecta</I>,
                        <I>deduplica</I> y <I>toma</I>.
                    </ListItem>
                    <ListItem icon={icons.Table}>
                        Una consulta SQL <I>SELECT DISTINCT ... WHERE ... LIMIT 10</I>.
                    </ListItem>
                </List>
            </Info>
            <Question>
                <List>
                    <ListItem icon={icons.Pipe}>
                        Escribe el pipeline equivalente en PowerShell usando <PowerShellInline
                            code="Where-Object"
                        />, <PowerShellInline code="Select-Object" />, <PowerShellInline
                            code="Sort-Object -Unique"
                        /> y <PowerShellInline code="Select-Object -First" />.
                    </ListItem>
                </List>
            </Question>
            <Solution>
                <PowerShellBlock
                    code={`Import-Csv users.csv |
Where-Object { $_.active -eq 'true' } |
Select-Object -ExpandProperty email |
Sort-Object -Unique |
Select-Object -First 10`}
                >
                    <Fragment slot="title">Solución esperada</Fragment>
                    <span slot="footer">
                        Composición declarativa: cada etapa transforma el flujo; se materializa al
                        final si es necesario.
                    </span>
                </PowerShellBlock>
            </Solution>
        </Exercise>
    </NotesSection>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            <P>
                El pipeline de PowerShell se entiende mejor como <B>sintaxis declarativa</B> cercana
                a FP, method chaining y SQL. Piensa en transformar flujos paso a paso, filtrando
                temprano y materializando al final.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <References>
        <Fragment slot="recommended">
            <WebPage
                title="Collection Pipeline"
                url="https://martinfowler.com/articles/collection-pipeline/"
                location="MartinFowler.com"
            >
                <Fragment slot="description">
                    Patrón para encadenar operaciones declarativas en colecciones
                    (filter/map/reduce), espejo útil del pipeline.
                </Fragment>
            </WebPage>
        </Fragment>
    </References>
</NotesLayout>
