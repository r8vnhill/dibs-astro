---
import * as icons from "~/assets/img/icons";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Important,
    Info,
} from "~/components/ui/callouts";
import { CodeBlock, PowerShellBlock, PowerShellInline, SqlInline } from "~/components/ui/code";
import { Mono } from "~/components/ui/font";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import { List, ListItem } from "~/components/ui/list";
import { ReferencesFromJsonLd } from "~/components/ui/references";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
import bibliographyRaw from "~/data/bibliography/software-libraries/scripting/pipelines.bibliography.jsonld?raw";

const bibliography = JSON.parse(bibliographyRaw);
---

<NotesLayout
    title="Pipelines I: PowerShell declarativo"
    description="Introducción al pipeline de PowerShell: cómo componer transformaciones declarativas sobre flujos de objetos (filtrar, proyectar, transformar, ordenar y exportar)."
    timeMultiplier={2}
>
    <Abstract>
        <P>
            En PowerShell, el <B>pipeline</B> es la forma de pensar los programas como flujos de
            datos.
        </P>
        <P>
            En esta lección aprenderás a componer pipelines <I>declarativos</I> que filtran,
            proyectan y transforman <B>objetos</B>, manteniéndolos en streaming desde la fuente
            hasta la salida.
        </P>
    </Abstract>

    <NotesSection id="h2-pipeline-intuition">
        <Heading headingLevel="h2" Icon={icons.ArrowsMerge}>
            Pensar en pasos: de colecciones al pipeline de PowerShell
        </Heading>

        <P>
            Antes de hablar del <B>pipeline</B>, partamos por una idea más simple: <B>procesar una
                colección paso a paso</B>.
        </P>

        <P>
            En muchos lenguajes, cuando trabajas con una colección de datos, aplicas una secuencia
            de operaciones: <I>filtrar</I>, <I>transformar</I>, <I>eliminar duplicados</I>,
            <I>limitar resultados</I>. Cada paso opera sobre el resultado del anterior.
        </P>

        <Definition>
            <Fragment slot="title">Transformaciones encadenadas</Fragment>
            <P>
                Una <B>transformación</B> recibe una colección de entrada y produce otra colección
                de salida. Al encadenarlas, describes <I>qué</I> quieres hacer con los datos, no
                <I>cómo</I> recorrerlos elemento por elemento.
            </P>
            <P>
                El foco está en el flujo de datos, no en el control del bucle.
            </P>
        </Definition>

        <Info>
            <span slot="title">El mismo problema, expresado como pasos</span>

            <CodeBlock
                lang="scala"
                code={`
                    users
                        .filter(_.active)
                        .map(_.email)
                        .distinct
                        .take(10)
                `}
            >
                <Fragment slot="title">Colecciones con operaciones encadenadas (Scala)</Fragment>
            </CodeBlock>

            <CodeBlock
                lang="python"
                code={`
                    list(
                        islice(
                            dict.fromkeys(
                                map(
                                    lambda u: u.email,
                                    filter(lambda u: u.active, users)
                                )
                            ),
                            10
                        )
                    )
                `}
            >
                <Fragment slot="title"
                >Colecciones con funciones de orden superior (Python)</Fragment>
            </CodeBlock>

            <CodeBlock
                lang="sql"
                code={`
                    SELECT DISTINCT email
                    FROM users
                    WHERE active = TRUE
                    LIMIT 10;
                `}
            >
                <Fragment slot="title">Consulta declarativa (SQL)</Fragment>
            </CodeBlock>
        </Info>

        <P>
            Algunos lenguajes hacen estas transformaciones más explícitas y legibles que otros, pero
            el modelo mental es el mismo.
        </P>

        <P>
            Aunque la sintaxis cambia, la <B>idea es siempre la misma</B>:
        </P>

        <List>
            <ListItem icon={icons.Funnel}>
                Quedarse solo con los elementos que cumplen una condición.
            </ListItem>
            <ListItem icon={icons.CursorText}>
                Extraer un dato relevante de cada elemento.
            </ListItem>
            <ListItem icon={icons.Copy}>
                Eliminar duplicados.
            </ListItem>
            <ListItem icon={icons.ArrowDown}>
                Limitar la cantidad de resultados.
            </ListItem>
        </List>

        <Important headingLevel="h3">
            <span slot="title">¿Dónde entra PowerShell?</span>

            <P>
                El <B>pipeline de PowerShell</B> expresa exactamente la misma idea, pero en lugar de
                encadenar métodos o funciones, <B>conecta comandos que procesan objetos</B>.
            </P>

            <P>
                Cada comando:
            </P>

            <List>
                <ListItem icon={icons.Cube}>
                    recibe <B>objetos</B> como entrada,
                </ListItem>
                <ListItem icon={icons.ArrowRight}>
                    procesa los objetos del pipeline,
                </ListItem>
                <ListItem icon={icons.ArrowElbowRight}>
                    y envía el resultado al siguiente comando.
                </ListItem>
            </List>

            <P>
                Esa conexión se escribe con el operador <PowerShellInline>|</PowerShellInline>, que
                puedes leer como <Enquote>pasa estos objetos a…</Enquote>.
            </P>
        </Important>

        <Info>
            <span slot="title">El mismo flujo expresado como pipeline</span>

            <PowerShellBlock
                code={`
                    Import-Csv users.csv |
                        Where-Object { $_.active -eq 'true' } |
                        Select-Object -ExpandProperty email |
                        Sort-Object -Unique |
                        Select-Object -First 10
                `}
            >
                <Fragment slot="title">Pipeline en PowerShell</Fragment>
            </PowerShellBlock>
            <P>
                Nota: <PowerShellInline>Import-Csv</PowerShellInline> produce propiedades como
                texto; el tipo exacto depende del origen de los datos.
            </P>
        </Info>

        <Explanation>
            <List>
                <ListItem icon={icons.Pipe}>
                    <B><PowerShellInline>|</PowerShellInline> conecta pasos:</B> no es “texto” — son
                    <B>objetos tipados</B> los que fluyen entre comandos.
                </ListItem>
                <ListItem icon={icons.Funnel}>
                    <B>Filtrar temprano:</B> igual que en SQL o FP, reduces trabajo en los pasos
                    siguientes.
                </ListItem>
                <ListItem icon={icons.Stack}>
                    <B>Procesamiento incremental:</B> PowerShell no necesita cargar todo en memoria
                    para empezar a trabajar.
                </ListItem>
                <ListItem icon={icons.FileText}>
                    <B>La salida final decide el formato:</B> solo al final decides si conviertes a
                    texto, archivo o reporte.
                </ListItem>
            </List>
        </Explanation>
    </NotesSection>

    <NotesSection id="h2-common-cmdlets">
        <Heading headingLevel="h2" Icon={icons.Toolbox}>
            Cmdlets comunes en el pipeline
        </Heading>

        <P>
            Una vez que entiendes el pipeline como una secuencia de transformaciones, el siguiente
            paso es conocer los <B>cmdlets más comunes</B> que aparecen en casi cualquier flujo de
            PowerShell.
        </P>

        <P>
            No se trata de memorizar comandos, sino de reconocer <B>roles</B>: filtrar, transformar,
            ordenar, limitar y proyectar datos.
        </P>

        <NotesSection id="h3-filtering">
            <Heading
                headingLevel="h3" Icon={icons.Funnel}
                slot="heading"
            >
                Filtrar objetos
            </Heading>

            <PowerShellBlock
                code={`
                    Get-Process | Where-Object { $_.CPU -gt 100 }
                `}
            >
                <span slot="title">Filtrar objetos</span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Database}>
                        <PowerShellInline>Get-Process</PowerShellInline> es un cmdlet de <B>origen
                            de datos</B>: consulta al sistema operativo y produce un flujo de <B
                        >objetos</B>, uno por cada proceso en ejecución.
                    </ListItem>

                    <ListItem icon={icons.Funnel}>
                        <PowerShellInline>Where-Object</PowerShellInline> recibe esos objetos uno a
                        uno desde el pipeline y evalúa una condición booleana para cada uno. Solo
                        los objetos que cumplen la condición continúan fluyendo.
                    </ListItem>

                    <ListItem icon={icons.Cube}>
                        Dentro del bloque <PowerShellInline code="{ ... }" />, la variable
                        automática <PowerShellInline>$_</PowerShellInline> representa <B>el objeto
                            actual del pipeline</B>. En este ejemplo, <PowerShellInline
                        >$_</PowerShellInline> es un objeto de tipo <PowerShellInline
                        >[System.Diagnostics.Process]</PowerShellInline>.
                    </ListItem>
                </List>

                <P>
                    Conceptualmente, este paso equivale a un <Mono>filter</Mono> en programación
                    funcional o a una cláusula <SqlInline>WHERE</SqlInline> en SQL: describe <I
                    >qué</I> procesos te interesan, no <I>cómo</I> recorrerlos.
                </P>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-projection">
            <Heading
                headingLevel="h3" Icon={icons.CursorText}
                slot="heading"
            >
                Proyectar y limitar
            </Heading>

            <PowerShellBlock
                code={`
                    Get-Service | Select-Object -Property Name, Status -First 10
                `}
            >
                <span slot="title">Proyectar y limitar objetos</span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Database}>
                        <PowerShellInline>Get-Service</PowerShellInline> es un cmdlet de <B>origen
                            de datos</B> que consulta al sistema operativo y produce un flujo de
                        objetos, uno por cada servicio registrado.
                    </ListItem>

                    <ListItem icon={icons.CursorText}>
                        <PowerShellInline>Select-Object</PowerShellInline> es el cmdlet principal
                        para <B>proyectar</B> datos en el pipeline: permite elegir qué propiedades
                        conservar y cómo se ve el objeto que continúa fluyendo.

                        <List>
                            <ListItem icon={icons.Tag}>
                                La opción <PowerShellInline code={`-Property Name, Status`} />
                                indica que solo nos interesan esas dos propiedades. El resultado no
                                es el mismo objeto original, sino un <B>nuevo objeto más simple</B>,
                                con únicamente esos campos.
                            </ListItem>

                            <ListItem icon={icons.ArrowDown}>
                                La opción <PowerShellInline>-First 10</PowerShellInline> limita el
                                número de objetos que continúan por el pipeline, deteniendo el flujo
                                una vez alcanzado ese límite. Esto es equivalente a un
                                <SqlInline>LIMIT</SqlInline> en SQL.
                            </ListItem>
                        </List>
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-transformation">
            <Heading
                headingLevel="h3" Icon={icons.MagicWand}
                slot="heading"
            >
                Transformar con ForEach-Object
            </Heading>

            <P>
                Hasta ahora vimos etapas que <B>filtran</B> y <B>proyectan</B>. El siguiente rol
                típico en un pipeline es <B>transformar</B>: tomar cada objeto y producir otro
                objeto (o efecto) a partir de él.
            </P>

            <PowerShellBlock
                code={`
                    Get-ChildItem -Path . -File -Filter *.mp4 |
                        ForEach-Object {
                            [PSCustomObject]@{
                                Name   = $_.Name
                                SizeKB = [math]::Round($_.Length / 1KB, 2)
                            }
                        } |
                        Sort-Object SizeKB -Descending |
                        Select-Object -First 10
                `}
            >
                <span slot="title">Transformar cada elemento del pipeline</span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.FolderOpen}>
                        <PowerShellInline>Get-ChildItem</PowerShellInline> produce un flujo de
                        objetos del sistema de archivos (por ejemplo, instancias como
                        <PowerShellInline>[FileInfo]</PowerShellInline>). Aquí limitamos a archivos
                        con <PowerShellInline>-File</PowerShellInline> y al patrón <PowerShellInline
                        >-Filter *.mp4</PowerShellInline>.
                    </ListItem>

                    <ListItem icon={icons.MagicWand}>
                        <PowerShellInline>ForEach-Object</PowerShellInline> aplica un bloque a cada
                        objeto del pipeline. Conceptualmente, es el equivalente a <Mono>map</Mono>
                        en FP: por cada entrada, produce una salida.
                    </ListItem>

                    <ListItem icon={icons.Cube}>
                        Dentro del bloque, <PowerShellInline>$_</PowerShellInline> vuelve a
                        representar el <B>objeto actual</B> (en este caso, un archivo). Usamos sus
                        propiedades <PowerShellInline>Name</PowerShellInline> y <PowerShellInline
                        >Length</PowerShellInline> para construir una vista más útil.
                    </ListItem>

                    <ListItem icon={icons.Tag}>
                        El bloque devuelve un <PowerShellInline>[PSCustomObject]</PowerShellInline>,
                        es decir, un objeto nuevo con propiedades explícitas. Esto mantiene el
                        pipeline <B>estructurado</B> y evita depender de parsear texto.
                    </ListItem>

                    <ListItem icon={icons.SortDescending}>
                        Después podemos seguir componiendo: ordenamos por <PowerShellInline
                        >SizeKB</PowerShellInline> y tomamos los 10 más grandes con
                        <PowerShellInline>-First</PowerShellInline>.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>
    </NotesSection>

    <Exercise headingLevel="h2">
        <Fragment slot="title">
            Transformar datos JSON con pipelines
        </Fragment>

        <Fragment slot="requirements">
            <P>
                Un uso común de PowerShell es el procesamiento y análisis de datos, sobre todo en
                etapas exploratorias. Para eso necesitas poder <B>leer</B> y <B>escribir</B> objetos
                (serialización) en formatos estándar como JSON, CSV o XML. PowerShell incluye
                cmdlets que serializan y deserializan datos y que se integran naturalmente con el
                pipeline.
            </P>

            <P>
                En este ejercicio practicarás un flujo típico:
                <Enquote>texto → objetos → transformaciones → texto</Enquote>. La regla es simple:
                trabaja con <B>objetos</B> hasta el último paso.
            </P>

            <P>
                Supón que tienes un archivo <Mono>users.json</Mono> con una lista de usuarios con
                esta estructura:
            </P>

            <CodeBlock
                lang="json"
                code={`
                [
                    { "name": "Isaac", "email": "isaac@example.com", "active": true },
                    { "name": "Miria", "email": "miria@example.com", "active": false }
                ]
            `}
            />

            <P>
                Tu tarea es:
            </P>

            <List>
                <ListItem icon={icons.Funnel}>
                    Filtrar solo los usuarios con <Mono>active</Mono> en <B>true</B>.
                </ListItem>
                <ListItem icon={icons.MagicWand}>
                    Transformar cada usuario a un objeto con solo <Mono>name</Mono> y <Mono
                    >email</Mono>, ambos en mayúsculas.
                </ListItem>
                <ListItem icon={icons.FloppyDisk}>
                    Guardar el resultado en un nuevo archivo <Mono>active-users.json</Mono>.
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="notes">
            <List>
                <ListItem icon={icons.Cube}>
                    <B><PowerShellInline>ConvertFrom-Json</PowerShellInline></B> toma texto JSON y
                    lo convierte en objetos de PowerShell con propiedades accesibles.
                </ListItem>
                <ListItem icon={icons.FileText}>
                    <B><PowerShellInline>ConvertTo-Json</PowerShellInline></B> serializa objetos de
                    PowerShell y produce texto JSON.
                </ListItem>
                <ListItem icon={icons.PencilSimpleLine}>
                    <B><PowerShellInline>Set-Content</PowerShellInline></B> escribe texto en un
                    archivo (creándolo o reemplazándolo).
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="use">
            <PowerShellBlock
                code={`
                    Get-Content 'users.json' |
                        ConvertFrom-Json |
                        ... | # Tu código aquí: filtra y transforma objetos
                        ConvertTo-Json |
                        Set-Content 'active-users.json'
                `}
            >
                <Fragment slot="title">Pipeline base</Fragment>
            </PowerShellBlock>
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    Get-Content 'users.json' |
                        ConvertFrom-Json |
                        Where-Object { $_.active -eq $true } |
                        ForEach-Object {
                            [PSCustomObject]@{
                                name  = $_.name.ToUpper()
                                email = $_.email.ToUpper()
                            }
                        } |
                        ConvertTo-Json |
                        Set-Content 'active-users.json'
                `}
            />

            <P>
                Este pipeline lee el archivo como texto, lo convierte a objetos, aplica filtrado y
                transformación, vuelve a serializar a JSON, y finalmente guarda el resultado. El
                trabajo principal ocurre sobre <B>objetos</B>, no sobre strings.
            </P>
        </Fragment>
    </Exercise>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            <P>
                El pipeline de PowerShell es más que un operador: es un <B>modelo de ejecución</B>
                orientado a objetos. Cada etapa recibe objetos con propiedades, produce objetos, y
                los entrega al siguiente cmdlet a medida que están disponibles.
            </P>

            <P>
                Pensar en <I>roles</I> (filtrar, proyectar, transformar, ordenar, limitar) te ayuda
                a diseñar pipelines claros, reutilizables y fáciles de leer. La regla práctica es
                simple: <B>trabaja con objetos hasta el último paso</B>.
            </P>
        </Fragment>

        <Fragment slot="key-points">
            <ListItem icon={icons.Cube}>
                El pipeline transporta <B>objetos tipados</B>, no texto.
            </ListItem>
            <ListItem icon={icons.Funnel}>
                Filtra temprano con <PowerShellInline>Where-Object</PowerShellInline> para reducir
                lo que fluye.
            </ListItem>
            <ListItem icon={icons.CursorText}>
                Proyecta lo necesario con <PowerShellInline>Select-Object</PowerShellInline> y
                limita con <PowerShellInline>-First</PowerShellInline> cuando puedas.
            </ListItem>
            <ListItem icon={icons.MagicWand}>
                Transforma con <PowerShellInline>ForEach-Object</PowerShellInline> (piensa en
                <Mono>map</Mono>): entrada → salida.
            </ListItem>
            <ListItem icon={icons.FileText}>
                Decide el formato <I>al final</I>: exporta/serializa solo en la última etapa.
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            <P>
                Lo declarativo no significa “hacer menos”, sino <B>decir mejor</B>: hacer explícita
                la intención del flujo y dejar que el recorrido sea un detalle de la herramienta.
            </P>

            <P>
                A medida que tus pipelines crecen, esta forma de pensar se vuelve una habilidad de
                diseño: separar <I>qué</I> quieres obtener de <I>cómo</I> lo recorres. El resultado
                suele ser más mantenible, más testeable y menos frágil que encadenar texto.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <ReferencesFromJsonLd
        source={bibliography}
        recommended={["pipeline-connecting-commands"]}
        additional={["collection-pipeline-fowler"]}
    >
        <Fragment slot="description-pipeline-connecting-commands">
            Capítulo introductorio sobre el pipeline de PowerShell: cómo encadenar cmdlets, por qué
            el flujo de objetos es distinto al de shells tradicionales, y cómo exportar resultados a
            CSV/JSON/XML. Incluye ejemplos prácticos con <PowerShellInline>Get-Process</PowerShellInline
            >, conceptos de conversión y exportación, y ejercicios guiados para afianzar el uso del
            pipeline.
        </Fragment>

        <Fragment slot="description-collection-pipeline-fowler">
            Artículo fundacional sobre el patrón Collection Pipeline: cómo encadenar operaciones
            declarativas (<Mono>map</Mono>, <Mono>filter</Mono>, <Mono>reduce</Mono>, <Mono
            >group-by</Mono>) para transformar colecciones. Compara sintaxis en múltiples lenguajes
            (Ruby, Clojure, Smalltalk), explora alternativas (loops, comprehensions), y discute
            temas avanzados como laziness, paralelismo e inmutabilidad. Incluye un catálogo
            detallado de operaciones comunes con ejemplos visuales.
        </Fragment>
    </ReferencesFromJsonLd>
</NotesLayout>
