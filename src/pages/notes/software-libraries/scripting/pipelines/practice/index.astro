---
import * as icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Exercise, Explanation, Hints, More, Solution, Tip, Warning } from "~/components/ui/callouts";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import { DibsSourceLink } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import ToDo from "~/components/utils/ToDo";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Pipelines III: Caso práctico y composición" description="Definir descripción"
    timeMultiplier={2}
>
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="...">
        <Heading
            headingLevel="h2" Icon={null}
            slot="heading"
        >
            ...
        </Heading>

        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "Definir id",
                    "Definir el título y su ícono",
                    "Plantear el problema que vamos a resolver, la idea es que separaremos una tarea en varios scripts que luego encadenaremos en un pipeline",
                ],
            }}
        />

        <NotesSection id="...">
            <Heading headingLevel="h3" Icon={null}
                slot="heading"
            >
                ...
            </Heading>
        
            <ToDo
                client:only="react"
                metadata={{
                    tasks: [
                        "Definir id",
                        "Definir el título y su ícono",
                        "Agregar texto 'al rededor' del código para contextualizar",
                        "Reemplazar placeholders como 'path/to/...' por valores reales",
                        `...`,
                    ],
                }}
            />
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-file-hash-streaming">
        <Heading
            headingLevel="h2" Icon={icons.Code}
            slot="heading"
        >
            Calcular hash de archivos en <I>streaming</I> con <PowerShellInline code="begin" />, <PowerShellInline
                code="process"
            /> y <PowerShellInline code="end" />
        </Heading>

        <p class="mb-2">
            Este ejemplo muestra un caso <I>pipeline-aware</I> realista (aunque algo simplificado para no abrumar):
            calcular el hash de archivos sin cargar todo en memoria. El objetivo es ilustrar la separación de
            responsabilidades entre los bloques <PowerShellInline code="begin" />, <PowerShellInline code="process" /> y
            <PowerShellInline code="end" />, más que profundizar en criptografía.
        </p>

        <NotesSection id="h3-hash-policy">
            <Heading headingLevel="h3" Icon={icons.Hash}>
                Política de algoritmos y flags de seguridad
            </Heading>

            <p class="mb-3">
                Antes de hacer <I>streaming</I> del archivo, conviene definir una <B>política de selección de
                    algoritmo</B>. El siguiente bloque no calcula el hash; <I>valida y describe</I> la elección del
                algoritmo según si es considerado inseguro (<code>MD5</code>, <code>SHA1</code>), si fue autorizado
                explícitamente con un flag y si entra en la categoría de “fuerte” (<code>SHA256</code>, <code
                >SHA384</code>, <code>SHA512</code>). Esto permite <I>fallar temprano</I>
                o registrar decisiones, y luego encadenar el cómputo real en otra función.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding()]
                    param(
                        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
                        [Alias('Name', 'HashAlgorithm')]
                        [ValidateSet('MD5', 'SHA1', 'SHA256', 'SHA384', 'SHA512')]
                        [string] $Algorithm = 'SHA256',

                        [switch] $AllowInsecure
                    )

                    process {
                        $isInsecure = $Algorithm -in @('MD5', 'SHA1')
                        $isSecure = !$isInsecure
                        $isAllowed = $isSecure -or $isInsecure -and $AllowInsecure

                        [PSCustomObject]@{
                            Algorithm  = $Algorithm
                            IsInsecure = $isInsecure
                            IsAllowed  = $isAllowed
                            IsSecure   = $isSecure
                        }
                    }
                `}
            >
                <Fragment slot="title">Comprobación de política de hash</Fragment>
                <span slot="footer">
                    Emite un objeto con campos <code>Algorithm</code>, <code>IsInsecure</code>, <code>IsAllowed</code>,
                    <code>IsSecure</code>, <code>IsStrongHash</code>. Útil para registrar/validar antes del cómputo en
                    <I>streaming</I>.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="pipeline/hash/Test-AlgorithmSecurity.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.Pipe}>
                        <B>Entrada por pipeline (combinada):</B> el parámetro <PowerShellInline code="$Algorithm" />
                        acepta entrada por <PowerShellInline code="ValueFromPipeline" /> y por <PowerShellInline
                            code="ValueFromPipelineByPropertyName"
                        /> simultáneamente. Con los <PowerShellInline code="[Alias('Name','HashAlgorithm')]" /> es común
                        que encaje con objetos previos (p. ej. salidas que traen un campo <code>Name</code> o <code
                        >HashAlgorithm</code>), sin tener que renombrar propiedades.
                    </ListItem>

                    <ListItem icon={icons.SlidersHorizontal}>
                        <B><PowerShellInline code="[ValidateSet(...)]" />:</B> restringe la entrada a una lista conocida
                        de algoritmos y habilita autocompletado, mensajes de error claros y documentación implícita.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <PowerShellBlock
            code={`
                #Requires -Version 7.0
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
                    [Alias('FullName', 'Path')]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Leaf })]
                    [string] $LiteralPath,

                    [ValidateSet('MD5', 'SHA1', 'SHA256')]
                    [string] $Algorithm = 'SHA256',

                    [switch] $IncludeLength
                )

                begin {
                    switch ($Algorithm) {
                        'SHA256' { $hasher = [System.Security.Cryptography.SHA256]::Create(); break }
                        'SHA1' { $hasher = [System.Security.Cryptography.SHA1]::Create(); break }
                        'MD5' { $hasher = [System.Security.Cryptography.MD5]::Create(); break }
                        default { throw "Unsupported algorithm: $Algorithm" }
                    }

                    Write-Verbose "Initialized $Algorithm hasher."
                }

                process {
                    try {
                        $resolved = (Resolve-Path -LiteralPath $LiteralPath -ErrorAction Stop).Path
                        $file = Get-Item -LiteralPath $resolved -ErrorAction Stop

                        $stream = [System.IO.File]::OpenRead($resolved)
                        try {
                            $hasher.Initialize() | Out-Null
                            $bytes = $hasher.ComputeHash($stream)
                            $hashString = [Convert]::ToHexString($bytes).ToLowerInvariant()

                            $result = @{
                                Path      = $file.FullName
                                Algorithm = $Algorithm
                                Hash      = $hashString
                            }
                            if ($IncludeLength) { $result.Length = $file.Length }

                            [pscustomobject]$result
                        }
                        finally {
                            $stream.Dispose()
                        }
                    }
                    catch {
                        Write-Warning ("Could not hash '{0}': {1}" -f $LiteralPath, $_.Exception.Message)
                    }
                }

                end {
                    if ($hasher) {
                        $hasher.Dispose()
                        Write-Verbose "Disposed $Algorithm hasher."
                    }
                }
            `}
        >
            <Fragment slot="title">Función <PowerShellInline code="Get-FileHashStream" /> (pipeline-aware)</Fragment>
            <Fragment slot="footer">
                Entrada por pipeline (acepta <code>FullName</code>/<code>Path</code> por alias) y salida de objetos:
                <code>Path, Algorithm, [Length], Hash</code>.
            </Fragment>
            <Fragment slot="source">scripts/pipeline/Get-FileHashStream.ps1</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.Pipe}>
                    <B>Entrada por pipeline combinada</B>: los atributos <PowerShellInline code="ValueFromPipeline" /> y
                    <PowerShellInline code="ValueFromPipelineByPropertyName" /> pueden usarse <I>juntos</I> en el mismo
                    parámetro. Esto permite que el script acepte tanto la entrada directa (el objeto completo que fluye
                    por el pipeline) como la asignación automática de una propiedad que coincida por nombre. Por
                    ejemplo, un parámetro con <PowerShellInline code="[Alias('FullName','Path')]" /> podrá recibir
                    objetos <PowerShellInline code="FileInfo" /> desde <PowerShellInline code="Get-ChildItem" />, ya sea
                    porque el objeto completo se inyecta o porque PowerShell detecta y usa su propiedad
                    <PowerShellInline code="FullName" />. Esta combinación maximiza la compatibilidad con distintos
                    productores y evita tener que usar <PowerShellInline code="ForEach-Object" /> o <PowerShellInline
                        code="Select-Object"
                    /> solo para adaptar nombres.
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    <B><PowerShellInline code="[ValidateSet(...)]" /></B>: restringe <PowerShellInline
                        code="$Algorithm"
                    /> a valores conocidos (<code>SHA256|SHA1|MD5</code>). Mejora mensajes de error y autocompletado.
                </ListItem>

                <ListItem icon={icons.ToggleLeft}>
                    <B><PowerShellInline code="switch (...) { ... }" /></B> es una estructura de control para comparar
                    un valor contra múltiples condiciones. Evalúa una expresión y ejecuta el bloque asociado a la
                    primera coincidencia (o a todas, si no se usa <PowerShellInline code="break" />).

                    <PowerShellBlock
                        code={`
                            switch ($value) {
                                'A' { 'Matched A'; break }
                                'B' { 'Matched B'; break }
                                default { 'No match' }
                            }
                        `}
                    >
                        <Fragment slot="title">
                            Sintaxis básica
                        </Fragment>

                        <ul class="list-disc ml-6 mt-2" slot="footer">
                            <li>
                                <PowerShellInline code="default" /> se ejecuta si ninguna condición coincide.
                            </li>
                            <li>
                                <PowerShellInline code="break" /> detiene la ejecución dentro del
                                <PowerShellInline code="switch" />, evitando que siga evaluando otros casos.
                            </li>
                        </ul>
                    </PowerShellBlock>

                    <Warning>
                        No debe confundirse con el tipo de parámetro <PowerShellInline code="[switch]" />, que
                        representa un <I>flag booleano</I> (p. ej., <PowerShellInline code="-Verbose" /> o
                        <PowerShellInline code="-Force" />) y no tiene relación con la estructura condicional
                        <PowerShellInline code="switch" />.
                    </Warning>
                </ListItem>

                <ListItem icon={icons.PlayCircle}>
                    <B><I>begin</I> = inicialización única</B>: se crea el <I>hasher</I> una sola vez y se reutiliza. Si
                    el algoritmo no es válido, se falla temprano.
                </ListItem>

                <ListItem icon={icons.Cpu}>
                    <B><I>process</I> = unidad de trabajo</B>: por cada archivo se resuelve la ruta, se abre un
                    <PowerShellInline code="FileStream" />, se inicializa el <I>hasher</I> y se calcula el hash. Se
                    emite un <PowerShellInline code="[pscustomobject]" /> por elemento, listo para componer.
                </ListItem>

                <ListItem icon={icons.FlagCheckered}>
                    <B><I>end</I> = limpieza</B>: se liberan recursos compartidos como el <I>hasher</I>. Los flujos
                    individuales se cierran en su propio <I>finally</I> para cada elemento.
                </ListItem>

                <ListItem icon={icons.Code}>
                    <B>Detalles clave</B>:

                    <List class="mt-2">
                        <ListItem icon={icons.FolderOpen}>
                            <PowerShellInline code="[System.IO.File]::OpenRead($resolved)" /> abre el archivo en modo
                            lectura.
                        </ListItem>

                        <ListItem icon={icons.ArrowClockwise}>
                            <PowerShellInline code="$hasher.Initialize()" /> reinicia el estado antes de cada elemento.
                        </ListItem>

                        <ListItem icon={icons.Hash}>
                            <PowerShellInline code="$hasher.ComputeHash($stream)" /> calcula el hash de forma eficiente.
                        </ListItem>
                        <ListItem icon={icons.TextT}>
                            <PowerShellInline code="[Convert]::ToHexString($bytes).ToLowerInvariant()" /> lo convierte a
                            hex.
                        </ListItem>
                        <ListItem icon={icons.Trash}>
                            <PowerShellInline code="$stream.Dispose()" /> en <I>finally</I> garantiza cierre del archivo
                            incluso con errores.
                        </ListItem>
                        <ListItem icon={icons.TrashSimple}>
                            <PowerShellInline code="$hasher.Dispose()" /> en <I>end</I> libera recursos al finalizar el
                            pipeline.
                        </ListItem>
                    </List>
                </ListItem>
            </List>
        </Explanation>

        <PowerShellBlock
            code={`
                # Archivos de la carpeta actual -> calcular hash SHA256 e incluir longitud
                Get-ChildItem -File |
                    .\\Get-FileHashStream.ps1 -Algorithm SHA256 -IncludeLength |
                    Sort-Object Length -Descending |
                    Select-Object -First 2 @{
                        Name='FileName'
                        Expression={ Split-Path $_.Path -Leaf }
                    }, Length, Hash |
                    Format-Table -AutoSize
            `}
        >
            <Fragment slot="title">
                Desde <code>scripts/pipeline</code>
            </Fragment>
            <span slot="footer">
                Lista los 2 archivos más grandes en la carpeta actual, mostrando su nombre, longitud y hash SHA256.
                <PowerShellInline code="Select-Object" /> usa una expresión para extraer solo el nombre del archivo
                (<PowerShellInline code="Split-Path $_.Path -Leaf" />).
            </span>
        </PowerShellBlock>
    </NotesSection>

    <Exercise>
        <p class="mt-6 mb-3">
            <B>Parte B.</B> Compón un pipeline que use: <PowerShellInline code="Get-ChildItem" /> → tu script de la
            Parte A → <PowerShellInline code=".\\Get-FileHashStream.ps1 -Algorithm SHA256" /> para calcular el hash de
            cada archivo → proyecta columnas y exporta a CSV. La idea es agregar la propiedad <code>Hash</code> sin
            romper el flujo.
        </p>

        <p>
            Para exportar a CSV, usa <PowerShellInline
                code={`| Export-Csv -LiteralPath "$Env:TMP\\file-inventory.csv"`}
            />, que crea un archivo temporal en la carpeta del usuario. Luego, abre ese archivo con
            <PowerShellInline code="code $Env:TMP\\file-inventory.csv" /> para ver el resultado.
        </p>

        <Hints>
            <List>
                <ListItem icon={icons.MagicWand}>
                    <B>Propiedades calculadas con <PowerShellInline code="Select-Object" /></B>: puedes crear columnas
                    derivadas en tiempo real usando la sintaxis: <PowerShellInline
                        code="@{ Name = 'NombreColumna'; Expression = { <bloque de código> } }"
                    />.
                </ListItem>

                <ListItem icon={icons.Code}>
                    <B>Desglose de la expresión</B>:
                    <ul class="list-disc ml-6 mt-2">
                        <li>
                            <PowerShellInline code="$_" /> representa el elemento actual del pipeline.
                        </li>
                        <li>
                            <PowerShellInline code="Get-FileHashStream.ps1 -Algorithm SHA256 -LiteralPath $_.Path" />
                            invoca el script sobre la ruta del archivo actual.
                        </li>
                        <li>
                            <PowerShellInline code="Select-Object -ExpandProperty Hash" /> extrae solo el valor del hash
                            (sin cabeceras ni estructura adicional).
                        </li>
                    </ul>
                </ListItem>

                <ListItem icon={icons.Hash}>
                    Una vez que tengas el resultado de <PowerShellInline code="Get-FileHashStream.ps1" />, usa
                    <PowerShellInline code="| Select-Object -ExpandProperty Hash" /> para proyectar solo el valor del
                    hash (en lugar de <PowerShellInline code="@{Hash = xx}" />).
                </ListItem>
            </List>
        </Hints>

        <Solution>
            <PowerShellBlock
                code={`
                    # Archivos de la carpeta actual -> resumen + SHA256 -> CSV
                    Get-ChildItem -File |
                        .\\Get-FileInfoSummary.ps1 |
                        Select-Object Name, Path, Length, LastWriteTime, @{
                            Name       = 'Hash'
                            Expression = {
                                # Invoca el hasher por elemento y extrae solo el valor del hash
                                (.\\Get-FileHashStream.ps1 -Algorithm SHA256 -LiteralPath $_.Path |
                                    Select-Object -ExpandProperty Hash)
                            }
                        } |
                        Export-Csv "$Env:TMP\\file-inventory.csv"
                `}
            >
                <span slot="title">Solución Parte B — composición de pipeline</span>
                <span slot="footer">
                    El <PowerShellInline code="Select-Object" /> usa una propiedad calculada para anexar
                    <PowerShellInline code="Hash" /> por elemento.
                </span>
            </PowerShellBlock>
        </Solution>
    </Exercise>
</NotesLayout>
