---
import * as icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Important,
    More,
    Note,
    Solution,
    Tip,
    Warning,
} from "~/components/ui/callouts";
import { OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import Cons from "~/components/ui/procons/Cons.astro";
import ProCons from "~/components/ui/procons/ProCons.astro";
import Pros from "~/components/ui/procons/Pros.astro";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Laboratorio 1: Submódulos en Git" description="...">
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-intro">
        <Heading
            headingLevel="h2" Icon={icons.GitlabLogo}
            slot="heading"
        >
            Por qué GitLab y qué aprenderemos
        </Heading>

        <p class="mb-2">
            <B href="https://gitlab.com">GitLab</B> es una plataforma similar a GitHub, pero con mayor enfoque en
            integración continua (CI/CD), control interno de dependencias, y publicación de paquetes. Es ampliamente
            usada en entornos profesionales, especialmente donde las empresas mantienen su propia infraestructura de
            repositorios.
        </p>

        <p class="mb-2">
            En este curso utilizaremos GitLab para practicar el flujo completo de trabajo:
            <B>crear, clonar, organizar, versionar y publicar</B> bibliotecas de software. Más adelante aprovecharemos
            su <I>Package Registry</I> para distribuir nuestras bibliotecas.
        </p>

        <ProCons>
            <Pros title="Ventajas">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>Integración continua (CI/CD) integrada</B>: GitLab incluye un sistema de pipelines nativo (<I
                        >GitLab CI</I>) sin necesidad de servicios externos. Es ideal para automatizar pruebas,
                        compilaciones y despliegues directamente desde el repositorio.
                        <I>GitHub ofrece una funcionalidad similar a través de GitHub Actions</I>, aunque requiere
                        definir flujos en YAML por separado y algunos límites difieren.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Registro de paquetes unificado</B>: permite publicar y consumir bibliotecas o imágenes de
                        contenedores desde el mismo entorno, facilitando el flujo <I>build → test → publish</I> del
                        curso.
                        <I>GitHub cuenta con GitHub Packages</I>, pero en GitLab este registro está integrado de forma
                        más directa con la interfaz del proyecto y sus pipelines.
                    </ListItem>

                    <ListItem icon={icons.Lock}>
                        <B>Instalación autogestionada</B>: muchas organizaciones lo utilizan en servidores propios, lo
                        que facilita cumplir requisitos de seguridad y confidencialidad.
                        <I>GitHub Enterprise Server</I> ofrece una alternativa equivalente, aunque requiere
                        licenciamiento específico.
                    </ListItem>

                    <ListItem icon={icons.Users}>
                        <B>Gestión avanzada de roles y grupos</B>: ofrece más niveles de permisos y jerarquías de
                        proyectos que GitHub, útil cuando se trabaja en equipos grandes.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Automatización por línea de comandos</B> con <PowerShellInline code="glab" />: una
                        herramienta oficial que facilita tareas repetitivas —como crear o clonar repositorios— sin
                        depender de la interfaz web.
                        <I>GitHub dispone de su propia CLI (<PowerShellInline code="gh" />)</I>, que cumple un propósito
                        similar y también es útil para flujos automatizados.
                    </ListItem>
                </List>
            </Pros>

            <Cons>
                <List>
                    <ListItem icon={icons.CloudSlash}>
                        <B>Menor comunidad pública</B>: GitHub sigue siendo el principal espacio de colaboración
                        abierta, por lo que las herramientas o bibliotecas publicadas en GitLab pueden alcanzar a menos
                        personas al inicio. Este factor es importante al diseñar proyectos <I>open-source</I>, ya que
                        impacta la visibilidad y la cantidad de contribuciones potenciales.<FootnoteRef index={1} />
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <B>Curva de aprendizaje</B>: su interfaz y flujos de CI/CD tienen más opciones y
                        configuraciones, lo que puede ser abrumador al inicio.
                    </ListItem>

                    <ListItem icon={icons.Database}>
                        <B>Uso de almacenamiento y límites</B>: en la versión gratuita de GitLab Cloud, los límites de
                        espacio y minutos de CI son más estrictos que en GitHub.
                    </ListItem>

                    <ListItem icon={icons.Student}>
                        <B>Falta de un equivalente directo a GitHub Classroom</B>: GitLab no ofrece una herramienta
                        integrada para gestionar tareas o repositorios de estudiantes de forma automática. Si bien se
                        pueden implementar soluciones alternativas con scripts o grupos preconfigurados,
                        <I>GitHub Classroom</I> sigue siendo una ventaja significativa en contextos educativos por su
                        facilidad de uso y su integración con repositorios individuales.
                    </ListItem>
                </List>
            </Cons>
        </ProCons>

        <p>
            Hoy aprenderemos a:

            <List>
                <ListItem icon={icons.FolderPlus}>
                    Crear repositorios remotos automáticamente.
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    Inicializar proyectos locales y enlazarlos con su remoto.
                </ListItem>

                <ListItem icon={icons.Play}>
                    Automatizar ambos pasos en un solo script.
                </ListItem>
            </List>
        </p>
    </NotesSection>

    <NotesSection id="scripts">
        <Heading
            headingLevel="h2" Icon={icons.Terminal}
            slot="heading"
        >
            Scripts del laboratorio
        </Heading>

        <Important>
            <span slot="title">Requisitos previos</span>

            <p>
                Antes de comenzar, asegúrate de haber iniciado sesión en GitLab desde la línea de comandos con:
            </p>
            
            <PowerShellBlock code={`glab auth login`}>
                <span slot="title">Desde la terminal</span>
                <span slot="footer">Iniciar sesión en GitLab CLI</span>
            </PowerShellBlock>
        </Important>

        <p class="mb-3">
            Todos los scripts son idempotentes: puedes ejecutarlos varias veces sin generar duplicados ni
            inconsistencias.
        </p>

        <NotesSection id="h3-new-gitlab-repo">
            <Heading
                headingLevel="h3" Icon={icons.GitBranch}
                slot="heading"
            >
                Crear repo remoto en GitLab
            </Heading>

            <p class="mb-3">
                Este script crea un repositorio remoto en GitLab usando <PowerShellInline code="glab" />, de forma
                idempotente: primero verifica su existencia y, si ya existe, devuelve un resultado estable sin fallar.
                Además, respeta <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" /> gracias a <I
                >SupportsShouldProcess</I>, y normaliza el nombre para cumplir con las restricciones del hosting.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrEmpty()]
                        [string] $Name,

                        [switch] $Public
                    )

                    $normalized = $Name.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', ''
                    if ([string]::IsNullOrWhiteSpace($normalized)) {
                        throw [System.ArgumentException]::new(
                            "Name '$Name' is not valid after normalizing to '$normalized' (only [a-z0-9-])."
                        )
                    }

                    $visibility = if ($Public) { 'public' } else { 'private' }

                    # Invocador utilitario para ejecutar binarios externos y capturar ExitCode/Output.
                    $invoker = Join-Path $PSScriptRoot '..' 'core' 'Invoke-Tool.ps1' -Resolve

                    try {
                        # Idempotencia: salir en éxito si ya existe.
                        & $invoker glab repo view $normalized | Out-Null
                        Write-Verbose "Repository '$normalized' already exists. Not creating it again."
                        return [pscustomobject]@{
                            Name       = $normalized
                            Visibility = $visibility
                            Created    = $false
                            Output     = @()
                            Message    = 'Repository already exists'
                        }
                    }
                    catch {
                        Write-Verbose "Repo '$normalized' not found. Will attempt to create it."
                    }

                    if ($PSCmdlet.ShouldProcess($normalized, "Create GitLab repository ($visibility)")) {
                        try {
                            $args = @('repo', 'create', $normalized, '--defaultBranch', 'main')
                            if ($Public) { $args += '--public' } else { $args += '--private' }

                            $result = & $invoker glab $args
                            $out = $result.Output

                            Write-Verbose ("Created '{0}' as {1}.{2}{3}" -f $normalized, $visibility, 
                                [Environment]::NewLine, ($out -join [Environment]::NewLine))

                            [pscustomobject]@{
                                Name       = $normalized
                                Visibility = $visibility
                                Created    = $true
                                Output     = $out
                                Message    = 'Repository created'
                            }
                        }
                        catch {
                            throw [System.AggregateException]::new(
                                "Failed to create repository '$Name' ('$normalized').", $_.Exception)
                        }
                    }
                `}
            >
                <Fragment slot="title">
                    Creación idempotente de repositorios en GitLab
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitLabRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.TextT}>
                        <PowerShellInline code=".ToLowerInvariant()" /> evita efectos de cultura (e.g. “I/İ” en turco) y
                        las expresiones regulares sustituyen espacios por guiones y filtran a
                        <Mono>[a-z0-9-]</Mono>.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <PowerShellInline code="& $invoker glab repo view $normalized" /> consulta el repo; si devuelve
                        <Mono>ExitCode = 0</Mono> asumimos que existe y devolvemos un objeto con <PowerShellInline
                            code="Created = $false"
                        />.
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <PowerShellInline code="& $invoker glab $args" /> ejecuta <PowerShellInline
                            code="glab repo create"
                        /> con
                        <PowerShellInline code="--defaultBranch main" /> y visibilidad según <PowerShellInline
                            code="-Public"
                        />. El bloque está protegido con <PowerShellInline code="try" />/<PowerShellInline
                            code="catch"
                        /> y arroja un <I>AggregateException</I> con contexto si falla.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-set-git-remote">
            <Heading
                headingLevel="h3" Icon={icons.Link}
                slot="heading"
            >
                Asignar remoto en Git
            </Heading>

            <p class="mb-3">
                Este script configura un remoto de Git de forma <B>idempotente</B>: si el remoto ya existe con la misma
                URL, no hace nada; si existe con otra URL, la actualiza; si no existe, lo crea. Usamos <PowerShellInline
                    code="git -C"
                />
                para operar en la carpeta del repo sin cambiar el directorio actual, y <I>SupportsShouldProcess</I> para
                habilitar
                <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" />.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidatePattern('^(https://|git@|ssh://)')]
                        [string] $RemoteUrl,

                        [Parameter()]
                        [ValidateNotNullOrEmpty()]
                        [string] $Path = '.',

                        [ValidatePattern('^[\\w.-]+$')]
                        [string] $RemoteName = 'origin'
                    )

                    $invoker = Join-Path $PSScriptRoot '..' 'core' 'Invoke-Tool.ps1' -Resolve
                    $repoPath = (Resolve-Path -LiteralPath $Path).Path

                    try {
                        & $invoker git -C $repoPath rev-parse --is-inside-work-tree | Out-Null
                    }
                    catch {
                        throw [System.AggregateException]::new(
                            "The path '$repoPath' is not a Git repository (or does not exist).",
                            $_.Exception
                        )
                    }

                    $currentUrl = try {
                        $res = & $invoker git -C $repoPath remote get-url $RemoteName
                        ($res.Output | Out-String).Trim()
                    }
                    catch {
                        $null
                    }

                    if ($null -ne $currentUrl) {
                        if ([string]::Equals($currentUrl, $RemoteUrl, 'OrdinalIgnoreCase')) {
                            [pscustomobject]@{
                                RepoPath = $repoPath
                                Remote   = $RemoteName
                                Url      = $RemoteUrl
                                Existed  = $true
                                Changed  = $false
                                Action   = 'none'
                                Output   = @()
                                Message  = 'Remote already configured'
                            }
                        }
                        elseif ($PSCmdlet.ShouldProcess("$RemoteName → $RemoteUrl", 'git remote set-url')) {
                            $set = & $invoker git -C $repoPath remote set-url $RemoteName $RemoteUrl
                            [pscustomobject]@{
                                RepoPath = $repoPath
                                Remote   = $RemoteName
                                Url      = $RemoteUrl
                                Existed  = $true
                                Changed  = $true
                                Action   = 'set-url'
                                Output   = $set.Output
                                Message  = "Remote URL updated (was: $currentUrl)"
                            }
                        }
                    }
                    elseif ($PSCmdlet.ShouldProcess("$RemoteName → $RemoteUrl", 'git remote add')) {
                        $add = & $invoker git -C $repoPath remote add $RemoteName $RemoteUrl
                        return [pscustomobject]@{
                            RepoPath = $repoPath
                            Remote   = $RemoteName
                            Url      = $RemoteUrl
                            Existed  = $false
                            Changed  = $true
                            Action   = 'add'
                            Output   = $add.Output
                            Message  = 'Remote added'
                        }
                    }
                    else {
                        [pscustomobject]@{
                            RepoPath = $repoPath
                            Remote   = $RemoteName
                            Url      = $RemoteUrl
                            Existed  = [bool]$currentUrl
                            Changed  = $false
                            Action   = 'skipped'
                            Output   = @()
                            Message  = 'Operation skipped'
                        }
                    }
                `}
            >
                <Fragment slot="title">
                    Set-GitRemote.ps1
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Set-GitRemote.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.CheckCircle}>
                        <B>Validación de URL</B>: <PowerShellInline
                            code="[ValidatePattern('^(https://|git@|ssh://)')]"
                        /> asegura que apuntemos a un remoto válido (HTTPS o SSH) antes de ejecutar Git.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Verificar repo</B>: <PowerShellInline
                            code="& $invoker git -C $repoPath rev-parse --is-inside-work-tree"
                        /> confirma que la ruta es un repositorio Git; si falla, se lanza una excepción con contexto.
                    </ListItem>

                    <ListItem icon={icons.Eye}>
                        <B>Leer remoto actual</B>: el bloque <PowerShellInline code="try" />/<PowerShellInline
                            code="catch"
                        /> asigna <PowerShellInline code="$null" /> si el remoto no existe con <PowerShellInline
                            code="$currentUrl = try { ... } catch { $null }"
                        />.
                    </ListItem>

                    <ListItem icon={icons.Equals}>
                        <B>Comparación</B>: <PowerShellInline code="[string]::Equals(..., 'OrdinalIgnoreCase')" /> evita
                        cambios innecesarios por diferencias de mayúsculas/minúsculas en la URL.
                    </ListItem>

                    <ListItem icon={icons.MagicWand}>
                        <B>Acciones</B>: si no hay cambios → <I>none</I>; si difiere → <I>set-url</I>; si no existe → <I
                        >add</I>. Gracias a <I>ShouldProcess</I>, puedes simular con <Mono>-WhatIf</Mono>.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-new-git-project">
            <Heading
                headingLevel="h3" Icon={icons.Play}
                slot="heading"
            >
                Crear proyecto completo (remoto + local + remoto origin)
            </Heading>

            <p class="mb-3">
                Este script combina los pasos anteriores: crea el repositorio remoto, inicializa el repositorio local
                (usando el script de la lección anterior) y asigna el remoto <Mono>origin</Mono>. Es idempotente de
                extremo a extremo.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidatePattern('^[a-zA-Z0-9._-]+$')]
                        [string] $Username,

                        [Parameter(Mandatory)]
                        [ValidatePattern('^[a-zA-Z0-9._-]+$')]
                        [string] $RepositoryName,

                        [ValidatePattern('^[a-zA-Z0-9._-]*$')]
                        [string] $Prefix = '',

                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $LiteralPath = '.',

                        [switch] $Public
                    )

                    $result = @{
                        NewRepository        = $null
                        InitializeRepository = $null
                        SetRemote            = $null
                    }

                    $newRepository = Join-Path $PSScriptRoot 'New-GitLabRepository.ps1' -Resolve
                    $initializeRepository = Join-Path $PSScriptRoot 'Initialize-Repository.ps1' -Resolve
                    $setRemote = Join-Path $PSScriptRoot 'Add-Remote.ps1' -Resolve

                    $forward = @{}
                    foreach ($k in 'WhatIf', 'Confirm') {
                        if ($PSBoundParameters.ContainsKey($k)) { $forward[$k] = $PSBoundParameters[$k] }
                    }

                    $normalized = (
                        $RepositoryName.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', '')

                    $repoSlug = if ([string]::IsNullOrEmpty($Prefix)) {
                        $normalized
                    }
                    else {
                        ($Prefix.Trim('-') + '-' + $normalized.Trim('-')).Trim('-')
                    }

                    $result.NewRepository = & $newRepository @forward -Name $LiteralPath -Public:$Public
                    $remoteUrl = "git@gitlab.com:$Username/$repoSlug.git"
                    $result.InitializeRepository = (
                        & $initializeRepository @forward -Name $normalized -RemoteUrl $remoteUrl)
                    $result.SetRemote = (
                        & $setRemote @forward -Path $normalized -RemoteName 'origin' -RemoteUrl $remoteUrl)

                    [pscustomobject]$result
                `}
            >
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitProject.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <ToDo
                  client:only="react"
                  metadata={{
                    tasks: [
                      `Explicar:
                      - `,
                    ],
                  }}
                />
            </Explanation>

            <PowerShellBlock code={`
                
            `}>
                <Fragment slot="title">...</Fragment>
                <Fragment slot="footer">...</Fragment>
                <Fragment slot="source">path/to/script.ps1</Fragment>
            </PowerShellBlock>
        </NotesSection>
    </NotesSection>

    <Footnotes>
        <Footnote index={1}>
            Una estrategia común para mitigar este problema es mantener un <B>mirror</B> del repositorio en GitHub (Git
            permite definir varios remotos). Sin embargo, esto puede complicar la gestión de <I>issues</I> o solicitudes
            de cambio (<I>merge requests</I> en GitLab, equivalentes a <I>pull requests</I> en GitHub), ya que habría
            que coordinar dos fuentes distintas de colaboración.
        </Footnote>
    </Footnotes>
</NotesLayout>

<NotesLayout
    title="Laboratorio 1: GitLab — crear repos y remotos"
    description="Crea un repositorio en GitLab, inicializa el repo local y configura el remoto de forma idempotente."
>
</NotesLayout>
