---
import * as icons from "~/assets/img/icons";
import { Enquote, Heading, P } from "~/components/semantics";
import { Exercise, Explanation, Important, Question, Tip } from "~/components/ui/callouts";
import { OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { NotesSection } from "~/layouts";
import NotesLayout from "~/layouts/NotesLayout.astro";
---

<NotesLayout
    title="Ensayo seguro (-WhatIf / -Confirm)"
    description="Si estás leyendo esto es porque se me olvidó agregar la descripción. Se agradece si me lo recuerdas."
    git={{ user: "r8vnhill", repo: "dibs-scripts" }}
>
    <NotesSection id="h2-dry-run-pattern">
        <Heading headingLevel="h2" Icon={icons.ShieldCheck}>
            Patrón de ensayo seguro (dry run)
        </Heading>

        <P>
            Antes de crear carpetas o archivos, conviene ensayar el cambio: ver <B>qué</B> se haría sin ejecutar nada.
            En PowerShell esto se habilita con el atributo <PowerShellInline code="SupportsShouldProcess" />, que agrega
            los <B>parámetros automáticos</B> <PowerShellInline code="-WhatIf" /> y <PowerShellInline
                code="-Confirm"
            />. Con ellos, el script puede <B>simular</B> o <B>solicitar confirmación</B> de acciones potencialmente
            destructivas, reduciendo riesgos y aumentando la confianza en su comportamiento.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                # [!code focus:2]
                [CmdletBinding(SupportsShouldProcess,
                    ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    # [!code focus:2]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Name,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                    [string] $Path
                )

                Set-StrictMode -Version 3.0

                # [!code focus:1]
                $base = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)
                $target = Join-Path $base $Name
                $readmePath = Join-Path $target 'README.md'
                # [!code focus:1]
                $helperPath = Join-Path $PSScriptRoot 'New-Readme.ps1' -Resolve

                $existsBefore = Test-Path -LiteralPath $readmePath -PathType Leaf
                $created = $false
                $skipped = $false

                if (!(Test-Path -LiteralPath $target -PathType Container)) {
                    New-Item -Path $target -ItemType Directory -Force | Out-Null
                }

                if (!$existsBefore) {
                    # [!code focus:5]
                    if ($PSCmdlet.ShouldProcess($readmePath, 'Create README.md')) {
                        $content = & $helperPath -Name $Name -Verbose:$PSBoundParameters['Verbose']
                        Set-Content -Path $readmePath -Encoding UTF8 -Value $content
                        $created = $true
                    }
                }
                else {
                    $skipped = $true
                }

                [PSCustomObject]@{
                    BasePath     = $base
                    TargetPath   = $target
                    ReadmePath   = $readmePath
                    HelperPath   = $helperPath
                    ExistsBefore = $existsBefore
                    Created      = $created
                    Skipped      = $skipped
                }
            `}
        >
            <Fragment slot="title">
                Initialize-Project (con <code>-WhatIf</code>)
            </Fragment>
            <DibsSourceLink
                repo="scripts" file="scaffolding/Initialize-Project.ps1"
                slot="source" ref="ae2ea81f7c7a376d2c05763dbba045e8644c0fca"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.Shield}>
                    <B><PowerShellInline code="SupportsShouldProcess" /></B> indica que el comando admite los parámetros
                    automáticos <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" />. PowerShell
                    los agrega y gestiona por ti: <PowerShellInline code="-WhatIf" />
                    <B>nunca ejecuta</B> la acción, sólo la describe; <PowerShellInline code="-Confirm" />
                    <B>solicita confirmación</B> antes de proceder (según reglas de impacto y preferencia del usuario).
                    <FootnoteRef index={1} />
                </ListItem>

                <ListItem icon={icons.CellSignalHigh}>
                    <B><PowerShellInline code="ConfirmImpact" /></B> declara el impacto de las operaciones del comando
                    (<Mono>Low</Mono>, <Mono>Medium</Mono>, <Mono>High</Mono>). PowerShell lo compara con
                    <B><PowerShellInline code="$ConfirmPreference" /></B> del usuario (por defecto, <Mono>High</Mono>):

                    <List>
                        <ListItem icon={icons.Scales}>
                            Si <B><Mono>ConfirmImpact >= $ConfirmPreference</Mono></B>, se pedirá confirmación
                            automáticamente.
                        </ListItem>

                        <ListItem icon={icons.HandPalm}>
                            Si no, <B>igual puedes forzarla</B> con <PowerShellInline code="-Confirm" />.
                        </ListItem>
                    </List>

                    En este ejemplo <Mono>Medium</Mono> describe creación/modificación de archivos (relevante pero no
                    destructiva).
                </ListItem>

                <ListItem icon={icons.CurrencyDollar}>
                    <B><PowerShellInline code="$PSCmdlet.ShouldProcess([string] target, [string] action)" /></B> es el
                    <B>punto de decisión</B>: aquí se evalúa si una operación debe simularse o ejecutarse. Coloca cada
                    operación con efectos dentro de este <B>if</B>. Con <PowerShellInline code="-WhatIf" /> se simula y
                    con <PowerShellInline code="-Confirm" /> se solicita permiso —como se explicó arriba—.
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    <B><PowerShellInline code="-Switch:$variable" /></B> pasa un switch sólo si la variable booleana es
                    <PowerShellInline code="$true" />. Para <I>propagar</I> switches comunes a helpers, usa
                    <PowerShellInline code="$PSBoundParameters" />: por ejemplo
                    <PowerShellInline code="-Verbose:$PSBoundParameters['Verbose']" />. Si quieres propagar
                    <PowerShellInline code="-WhatIf" /> / <PowerShellInline code="-Confirm" /> el helper <B>también debe
                        declarar</B> <PowerShellInline code="SupportsShouldProcess" /> para que PowerShell gestione su
                    simulación/confirmación correctamente.
                </ListItem>
            </List>

            <Tip headingLevel="h4">
                <span slot="title">Regla mental</span>

                Declara <PowerShellInline code="SupportsShouldProcess" />, marca el impacto con <PowerShellInline
                    code="ConfirmImpact"
                />, y <B>envuelve efectos</B> en <PowerShellInline code="ShouldProcess(target, action)" />. Con eso,
                <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" /> <Enquote>simplemente
                    funcionan</Enquote>.
            </Tip>
        </Explanation>

        <Important headingLevel="h3">
            <Fragment slot="title">Confirmación y simulación</Fragment>

            <P>
                Como se indicó arriba, <PowerShellInline code="SupportsShouldProcess" /> habilita <Mono>-WhatIf</Mono>
                y <Mono>-Confirm</Mono>, y el punto de decisión es
                <PowerShellInline code="$PSCmdlet.ShouldProcess(target, action)" />. En la práctica: <Mono
                >-WhatIf</Mono>
                simula sin aplicar cambios y <Mono>-Confirm</Mono> pide autorización previa.
            </P>

            <List>
                <ListItem icon={icons.CheckCircle}>
                    <PowerShellInline code="Low" /> → operaciones triviales (por ejemplo, lectura o inspección de
                    datos).
                </ListItem>
                <ListItem icon={icons.FolderPlus}>
                    <PowerShellInline code="Medium" /> → operaciones que crean o modifican recursos.
                </ListItem>
                <ListItem icon={icons.WarningCircle}>
                    <PowerShellInline code="High" /> → operaciones críticas o destructivas (por ejemplo, eliminación de
                    archivos o estructuras completas).
                </ListItem>
            </List>
        </Important>

        <NotesSection id="h3-safe-run-example">
            <Heading headingLevel="h3" Icon={icons.TerminalWindow}>
                Ensayo seguro con <Mono>-WhatIf</Mono> y confirmación
            </Heading>

            <P>
                Antes de crear carpetas o archivos, ejecuta el comando con <PowerShellInline code="-WhatIf" /> para
                comprobar <I>qué</I> haría el script sin realizar cambios reales. Si además deseas que el script <B>pida
                    confirmación antes de ejecutar</B> cada acción, cambia <PowerShellInline code={`-WhatIf`} />
                <PowerShellInline code="-Confirm" />.
            </P>

            <PowerShellBlock
                code={`
                    ./scaffolding/Initialize-Project.ps1 -Name "Test" -Path "." -Verbose -WhatIf
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/scripts</Mono></Fragment>
            </PowerShellBlock>

            <OutputBlock
                code={`
                    What if: Performing the operation "Create Directory" on target "Destination: /path/to/dibs/scripts/Test".
                    What if: Performing the operation "Create README.md" on target "/path/to/dibs/scripts/Test/README.md".

                    BasePath     : /path/to/dibs/scripts
                    TargetPath   : /path/to/dibs/scripts/Test
                    ReadmePath   : /path/to/dibs/scripts/Test/README.md
                    HelperPath   : /path/to/dibs/scripts/scaffolding/New-Readme.ps1
                    ExistsBefore : False
                    Created      : False
                    Skipped      : False
                `}
            >
                <span slot="title">Salida con <PowerShellInline code="-WhatIf" /></span>
            </OutputBlock>

            <Question headingLevel="h4">
                Prueba distintos valores de <PowerShellInline code="-Name" /> y
                <PowerShellInline code="-Path" /> junto con
                <PowerShellInline code="-WhatIf" />. ¿Qué ocurre si el proyecto ya existe? ¿Y si la ruta no es válida?
            </Question>

            <Question headingLevel="h4">
                Ejecuta el script con <PowerShellInline code="-Confirm" /> para observar cómo solicita autorización
                antes de crear cada archivo.
            </Question>
        </NotesSection>
    </NotesSection>

    <Exercise headingLevel="h2">
        <Fragment slot="title">
            Limpieza segura con <Mono>ConfirmImpact = 'High'</Mono>
        </Fragment>

        <Fragment slot="requirements">
            Implementa un script <Mono>Remove-WorkFolder.ps1</Mono> que elimine UNA carpeta de trabajo específica de
            forma <B>segura</B>, aplicando el patrón de ensayo/confirmación:

            <List>
                <ListItem icon={icons.Shield}>
                    Declara <PowerShellInline code="[CmdletBinding(SupportsShouldProcess, ConfirmImpact='High')]" />.
                </ListItem>
                <ListItem icon={icons.Folder}>
                    Parámetro obligatorio <Mono>$Path</Mono>, válido y de tipo <I>carpeta existente</I>.
                </ListItem>
                <ListItem icon={icons.CursorClick}>
                    Usa <PowerShellInline code="$PSCmdlet.ShouldProcess(target, action)" /> para proteger la llamada a
                    <PowerShellInline code="Remove-Item -Recurse -Force" />.
                </ListItem>
                <ListItem icon={icons.SlidersHorizontal}>
                    Propaga verbosidad y switches comunes con
                    <PowerShellInline code="-Verbose:$PSBoundParameters['Verbose']" /> y, opcionalmente,
                    <PowerShellInline code="-WhatIf:$PSBoundParameters['WhatIf']" /> /
                    <PowerShellInline code="-Confirm:$PSBoundParameters['Confirm']" />.
                </ListItem>
                <ListItem icon={icons.ListChecks}>
                    Devuelve un <Mono>PSCustomObject</Mono> con <Mono>TargetPath</Mono>, <Mono>ExistsBefore</Mono> y
                    <Mono>Deleted</Mono>.
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="use">
            <PowerShellBlock
                code={`
                    ./Remove-WorkFolder.ps1 -Path './Test' -Verbose -WhatIf

                    # Luego, con confirmación interactiva
                    ./Remove-WorkFolder.ps1 -Path './Test' -Verbose -Confirm
                `}
            >
                <span slot="title">Prueba el flujo seguro</span>
            </PowerShellBlock>
        </Fragment>

        <Fragment slot="hints">
            Recuerda resolver rutas con <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)" />
            y usar <PowerShellInline code="-LiteralPath" /> en las operaciones de archivo para evitar problemas con
            caracteres especiales.
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact='High')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                        [string] $Path
                    )

                    $target = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)
                    $existsBefore = Test-Path -LiteralPath $target -PathType Container
                    $deleted = $false

                    if ($existsBefore) {
                        if ($PSCmdlet.ShouldProcess($target, 'Remove work folder recursively')) {
                            Remove-Item -LiteralPath $target -Recurse -Force \
                                -Verbose:$PSBoundParameters['Verbose'] \
                                -WhatIf:$PSBoundParameters['WhatIf'] \
                                -Confirm:$PSBoundParameters['Confirm']
                            $deleted = $true
                        }
                    }

                    [PSCustomObject]@{
                        TargetPath   = $target
                        ExistsBefore = $existsBefore
                        Deleted      = $deleted
                    }
                `}
            >
                <span slot="title">Solución de referencia</span>
            </PowerShellBlock>
        </Fragment>
    </Exercise>

    <Footnotes>
        <Footnote index={1}>
            Nota que <PowerShellInline code={`-Confirm`} /> hace que el script <B>solicite confirmación</B> antes de
            ejecutar una acción; <B>no significa que tú ya la estés confirmando.</B>
        </Footnote>
    </Footnotes>
</NotesLayout>
