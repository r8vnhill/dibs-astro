---
import * as icons from "~/assets/img/icons";
import comoImg from "~/assets/img/why/como.webp";
import { Enquote, Heading, P } from "~/components/semantics";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Hints,
    Important,
    Info,
    More,
    Note,
    Question,
    Solution,
    Tip,
    Warning,
} from "~/components/ui/callouts";
import { MarkdownInline, OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import ToDo from "~/components/utils/ToDo";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Patrones básicos de scripting"
    description="Si estás leyendo esto es porque se me olvidó agregar la descripción."
    git={{ user: "r8vnhill", repo: "dibs-scripts" }}
>
    <Abstract>
        ...
    </Abstract>

    <NotesSection id="h2-should-process">
        <Heading
            headingLevel="h2" Icon={icons.ShieldCheck}
            slot="heading"
        >
            Patrón de ensayo seguro (simular antes de ejecutar)
        </Heading>

        <P>
            Antes de modificar archivos o crear estructuras, es buena práctica hacer un “ensayo” que muestre <I>qué</I>
            se haría sin hacerlo realmente. En PowerShell esto se logra con <PowerShellInline code="-WhatIf" /> (vía
            <PowerShellInline code="SupportsShouldProcess" />). Así evitamos efectos no deseados y ganamos confianza en
            el script.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.4
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrEmpty()]
                    [string] $Name,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                    [string] $Path
                )

                $base = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)
                $target = Join-Path $base $Name
                $readmePath = Join-Path $target 'README.md'
                $helperPath = Join-Path $PSScriptRoot 'New-Readme.ps1' -Resolve

                Write-Verbose (@'
                Base path: {0}
                Project destination: {1}
                Helper: {2}
                '@ -f $base, $target, $helperPath)

                if (!(Test-Path -Path $readmePath -PathType Leaf)) {
                    if ($PSCmdlet.ShouldProcess($readmePath, 'Create README.md')) {
                        $content = & $helperPath -Name $Name -Verbose:$VerbosePreference
                        Set-Content -Path $readmePath -Encoding UTF8 -Value $content

                        Write-Information ('README.md created successfully at {0}' -f $readmePath)
                    }
                }
                else {
                    Write-Warning ('README.md already exists at {0}; creation skipped.' -f $readmePath)
                }
            `}
        >
            <Fragment slot="title">
                Initialize-Project (con <code>-WhatIf</code>)
            </Fragment>
            <DibsSourceLink
                repo="scripts" file="Initialize-Project.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.Shield}>
                    <PowerShellInline code="SupportsShouldProcess" /> permite simular o confirmar acciones con
                    <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" />. Esto hace que los
                    scripts sean más seguros al modificar el sistema, sobre todo con <PowerShellInline
                        code="ConfirmImpact = 'Medium'"
                    />.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <PowerShellInline code="[ValidateNotNullOrWhiteSpace()]" /> (desde PowerShell&nbsp;7.4) evita que el
                    valor sea
                    <PowerShellInline code="$null" />, vacío o solo espacios.
                </ListItem>

                <ListItem icon={icons.CurrencyDollar}>
                    <PowerShellInline code="$PSCmdlet" /> expone información y utilidades del “cmdlet actual”, como
                    <PowerShellInline code="ShouldProcess()" /> para integrar <PowerShellInline code="-WhatIf" /> y
                    <PowerShellInline code="-Confirm" />.
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    <PowerShellInline code="Path" /> puede incluir el proveedor (por ejemplo,
                    <Mono>Microsoft.PowerShell.Core\FileSystem::C:\Users</Mono>), mientras que
                    <PowerShellInline code="ProviderPath" /> muestra solo la ruta del sistema (por ejemplo, <Mono
                    >C:\Users</Mono>).
                    <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath(...)" /> es una forma segura y
                    portable de obtener el <I>provider path</I> real dentro de un script. Como ya validamos que la ruta
                    existe con
                    <PowerShellInline code="[ValidateScript(...)]" />, usar <Mono>Unresolved</Mono> es suficiente y
                    confiable.

                    <More headingLevel="h5">
                        <span slot="title">¿Y si necesito usar <Mono>Resolved</Mono>?</span>

                        <P>
                            <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath(...)" /> no requiere
                            que la ruta exista, por lo que es más flexible. En cambio,
                            <PowerShellInline code="$PSCmdlet.GetResolvedProviderPathFromPSPath(...)" /> solo funciona
                            con rutas reales existentes y necesita un parámetro adicional que representa el proveedor
                            (por ejemplo, el file system). Este enfoque es menos común y se usa principalmente en
                            escenarios más avanzados.
                        </P>

                        <P>Ejemplo de uso con la variante <Mono>Resolved</Mono>:</P>

                        <PowerShellBlock
                            code={`
                                $base = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path,
                                    [ref](Get-PSProvider FileSystem))
                            `}
                        >
                            <Fragment slot="title">Conversión a ruta resuelta</Fragment>
                            <Fragment slot="footer">Devuelve la ruta real solo si existe.</Fragment>
                        </PowerShellBlock>
                    </More>
                </ListItem>

                <ListItem icon={icons.Info}>
                    <PowerShellInline code="Write-Information" /> y <PowerShellInline code="Write-Warning" /> muestran
                    mensajes sin detener la ejecución. Se usan junto a <PowerShellInline code="Write-Verbose" /> para
                    diferenciar propósitos.
                </ListItem>

                <ListItem icon={icons.Link}>
                    <B><PowerShellInline code="$PSScriptRoot" /></B> devuelve la ruta donde está el script actual. Útil
                    para cargar helpers locales sin depender del directorio de ejecución.
                </ListItem>

                <ListItem icon={icons.MapPin}>
                    <B><PowerShellInline code="-Resolve" /></B> en <PowerShellInline code="Join-Path" /> verifica que la
                    ruta exista y devuelve su forma absoluta; falla si el archivo no existe.
                </ListItem>

                <ListItem icon={icons.PlayCircle}>
                    <B><PowerShellInline code="&" /></B> ejecuta comandos o scripts almacenados en variables, como
                    <PowerShellInline code="& $helperPath -Name $Name" />.
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    <B><PowerShellInline code="-Switch:$variable" /></B> permite pasar un switch solo si la variable
                    booleana es
                    <PowerShellInline code="$true" />, como <PowerShellInline code="-Verbose:$VerbosePreference" />.
                </ListItem>
            </List>
        </Explanation>

        <Important headingLevel="h3">
            <Fragment slot="title">Confirmación y simulación</Fragment>
            <P>
                <PowerShellInline code="SupportsShouldProcess" /> habilita las banderas <PowerShellInline
                    code="-WhatIf"
                /> y <PowerShellInline code="-Confirm" />. <PowerShellInline code={`-WhatIf`} /> muestra lo que el
                script haría sin ejecutar acciones, mientras que <PowerShellInline code={`-Confirm`} /> pide
                confirmación antes de continuar.
            </P>
            <List>
                <ListItem icon={icons.CheckCircle}>
                    <PowerShellInline code="Low" /> → operaciones triviales.
                </ListItem>
                <ListItem icon={icons.FolderPlus}>
                    <PowerShellInline code="Medium" /> → crean o modifican archivos (como en este ejemplo).
                </ListItem>
                <ListItem icon={icons.Trash}>
                    <PowerShellInline code="High" /> → operaciones destructivas o críticas.
                </ListItem>
            </List>
        </Important>

        <NotesSection id="h3-safe-dry-run">
            <Heading
                headingLevel="h3" Icon={icons.TerminalWindow}
                slot="heading"
            >
                Ensayo seguro con <Mono>-WhatIf</Mono> y confirmación
            </Heading>

            <P>
                Antes de crear carpetas o archivos, ensaya el cambio con <PowerShellInline code="-WhatIf" />. Así
                verificas <I>qué</I> haría el script sin modificar nada. Si además quieres pedir confirmación
                interactiva, usa <PowerShellInline code="-Confirm" />.
            </P>

            <PowerShellBlock
                code={`
                    ./scripts/Initialize-Project.ps1 -Name "Test" -Path "." -Verbose -WhatIf
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/</Mono></Fragment>
            </PowerShellBlock>

            <OutputBlock
                code={`
                    What if: Performing the operation "Initialize project and create README.md" on target "/path/to/dibs/Test".
                `}
            >
                <span slot="title">Salida con <PowerShellInline code="-WhatIf" /></span>
            </OutputBlock>

            <Question headingLevel="h4">
                Prueba distintos valores de <PowerShellInline code="-Name" /> y <PowerShellInline code="-Path" /> con
                <PowerShellInline code="-WhatIf" />. ¿Qué sucede si el proyecto ya existe? ¿Y si la ruta no existe?
            </Question>

            <Question headingLevel="h4">
                Ejecuta el script con <PowerShellInline code="-Confirm" /> para observar el flujo de confirmaciones.
            </Question>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-iteration">
        <Heading headingLevel="h2" Icon={icons.ArrowsClockwise}>
            Recorrer y transformar archivos
        </Heading>

        <P>
            Un caso típico en bibliotecas de software es estandarizar metadatos: por ejemplo, asegurarte de que cada
            proyecto tenga archivo <Mono>LICENSE</Mono> y que su <Mono>README.md</Mono> incluya una sección de licencia.
            A continuación iteramos por todos los <Mono>README.md</Mono> del árbol, creamos <Mono
            >LICENSE</Mono><FootnoteRef index={1} />&nbsp;si falta y añadimos (o evitamos duplicar) la sección
            <MarkdownInline code="## License" />.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.4
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                    [string] $Root,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Owner,
                    
                    [ValidateRange(1900, 3000)]
                    [int] $Year = (Get-Date).Year
                )

                $rootPath = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Root)
                $bsd2Url = 'https://raw.githubusercontent.com/spdx/license-list-data/master/text/BSD-2-Clause.txt'
                $section = @'
                ## License

                This project is licensed under the **BSD 2-Clause** license.  
                See the [LICENSE](./LICENSE) file for details.
                '@

                $licenseText = (Invoke-RestMethod -Uri $bsd2Url) -replace '<year>', $Year -replace (
                    '<owner>', $Owner)

                $foundReadmes = Get-ChildItem -Path $rootPath -Recurse -File -Filter README.md

                foreach ($readme in $foundReadmes) {
                    $dir = $readme.DirectoryName
                    $licensePath = Join-Path $dir 'LICENSE'

                    if (!(Test-Path -LiteralPath $licensePath)) {
                        if ($PSCmdlet.ShouldProcess($licensePath, 'Create LICENSE (BSD-2)')) {
                            Set-Content -LiteralPath $licensePath -Encoding utf8 -Value $licenseText
                            Write-Information ('LICENSE created -> {0}' -f $licensePath)
                        }
                    }
                    else {
                        Write-Warning ('LICENSE already present -> {0}' -f $licensePath)
                    }

                    $readmeText = Get-Content -LiteralPath $readme.FullName -Raw
                    if ($readmeText -notmatch '(?im)^##\\s*License\\b') {
                        if ($PSCmdlet.ShouldProcess($readme.FullName, 'Append License section')) {
                            Add-Content -LiteralPath $readme.FullName -Encoding utf8 -Value (
                                '{0}{0}{1}' -f [Environment]::NewLine, $section)
                            Write-Information ('License section appended -> {0}' -f $readme.FullName)
                        }
                    }
                    else {
                        Write-Warning ('README already has a License section -> {0}' -f $readme.FullName)
                    }
                }
            `}
        >
            <span slot="title">Estandarizar LICENSE y sección en README.md</span>
            <DibsSourceLink
                slot="source" repo="scripts"
                file="core/Add-License.ps1"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.NumberCircleOne}>
                    <PowerShellInline code="[ValidateRange(1900, 3000)]" /> valida en tiempo de <em>binding</em> que
                    <PowerShellInline code="-Year" /> esté dentro del rango permitido. Si no, PowerShell detiene el
                    script antes de ejecutar la lógica.

                    <More headingLevel="h5">
                        <span slot="title">¿Y si estoy programando después del año 3000?</span>

                        <img
                            src={comoImg.src} alt="¿Qué?"
                            class="mx-auto my-4 w-64 rounded-xl shadow-md transition-transform duration-300 hover:scale-105"
                        />
                    </More>
                </ListItem>

                <ListItem icon={icons.CloudArrowDown}>
                    <PowerShellInline code="Invoke-RestMethod" /> descarga el contenido y te entrega directamente el <I
                    >cuerpo</I> (string u objeto si es JSON/XML). Es ideal cuando quieres el payload sin metadatos. En
                    cambio, <PowerShellInline code="Invoke-WebRequest" /> retorna un objeto más “pesado” con
                    encabezados, estado, etc., y el texto viene en <Mono>.Content</Mono>.
                    <br />
                    Como la licencia de SPDX es texto plano y solo nos interesa el contenido, <PowerShellInline
                        code="Invoke-RestMethod"
                    /> es la opción más simple.
                </ListItem>

                <ListItem icon={icons.PencilSimpleLine}>
                    <B>Reemplazos con</B> <PowerShellInline code="-replace" />: es un operador de <I>expresiones
                        regulares</I> que recibe <Mono>patrón</Mono> y <Mono>reemplazo</Mono>. En el script encadenamos
                    dos reemplazos: primero <PowerShellInline code={`'<year>'`} /> por <PowerShellInline
                        code="$Year"
                    />, y luego <PowerShellInline code={`'<owner>'`} /> por <PowerShellInline
                        code="$Owner"
                    />.<FootnoteRef index={2} />
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    <B>Enumerar archivos</B> con <PowerShellInline code="Get-ChildItem -Recurse -File -Filter" />:
                    <List>
                        <ListItem icon={icons.ArrowBendDoubleUpRight}>
                            <PowerShellInline code="-Recurse" /> recorre subcarpetas.
                        </ListItem>
                        <ListItem icon={icons.File}>
                            <PowerShellInline code="-File" /> limita a archivos.
                        </ListItem>
                        <ListItem icon={icons.FileMd}>
                            <PowerShellInline code="-Filter README.md" /> conserva sólo archivos <Mono>README.md</Mono>;
                            usar <PowerShellInline code={`Where-Object`} /> es una alternativa, pero usualmente es menos
                            eficiente porque filtra <B>después</B> de obtener todos los archivos.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.ArrowsClockwise}>
                    <PowerShellInline code="foreach ($readme in $foundReadmes) { ... }" />: bucle nativo (no de
                    pipeline) que itera colecciones en memoria. Es rápido y legible para transformaciones por archivo.
                </ListItem>

                <ListItem icon={icons.Funnel}>
                    <PowerShellInline code="$readmeText -notmatch '(?im)^##\\s*License\\b'" /> usa el operador de
                    comparación con expresiones regulares <PowerShellInline code="-match" /> / <PowerShellInline
                        code="-notmatch"
                    />. Este devuelve un valor booleano según si la cadena cumple (o no cumple) con el patrón dado. En
                    este caso:
                    <List>
                        <ListItem icon={icons.TextT}>
                            La expresión regular <Mono>(?im)^##\s*License\b</Mono>
                            busca un encabezado <MarkdownInline code="## License" /> al inicio de una línea.
                        </ListItem>

                        <ListItem icon={icons.TextAa}>
                            La bandera <Mono>i</Mono> ignora mayúsculas/minúsculas; <Mono>m</Mono> permite que <Mono
                            >^</Mono> coincida con el inicio de cada línea (no solo del texto completo).
                        </ListItem>

                        <ListItem icon={icons.ShieldCheck}>
                            Con <PowerShellInline code="-notmatch" /> verificamos que no exista aún esa sección,
                            evitando duplicar la licencia en el README.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.TextIndent}>
                    <PowerShellInline code="[Environment]::NewLine" /> devuelve el separador de línea apropiado para el
                    sistema operativo (por ejemplo, <Mono>\r\n</Mono> en Windows, <Mono>\n</Mono> en Unix).
                </ListItem>

                <ListItem icon={icons.PlusCircle}>
                    <PowerShellInline code="Add-Content" /> agrega texto al final de un archivo existente, mientras que
                    <PowerShellInline code="Set-Content" /> sobrescribe el contenido. Aquí usamos <PowerShellInline
                        code="Add-Content -Encoding utf8"
                    /> para anexar la sección de licencia al README preservando codificación UTF-8 y sin borrar lo
                    anterior.
                </ListItem>
            </List>
        </Explanation>

        <More headingLevel="h3">
            <span slot="title"><PowerShellInline code="ForEach-Object" /></span>

            <P>
                PowerShell ofrece dos formas de iterar colecciones: la palabra clave
                <PowerShellInline code="foreach" /> y el cmdlet <PowerShellInline code="ForEach-Object" />. Aunque se
                parecen, tienen diferencias importantes:
            </P>

            <List>
                <ListItem icon={icons.Rocket}>
                    <B><PowerShellInline code="foreach" /></B> (palabra clave): recorre una colección ya materializada
                    en memoria (por ejemplo, una variable como <PowerShellInline code="$foundReadmes" />). Suele ser más
                    rápido y permite usar <PowerShellInline code={`break`} />/<PowerShellInline code={`continue`} /> de
                    forma clara. Es ideal cuando ya tienes los datos y quieres un bucle “procedimental”.
                </ListItem>

                <ListItem icon={icons.Pipe}>
                    <B><PowerShellInline code="... | ForEach-Object { ... }" /></B> (cmdlet): procesa elementos <I>en
                        streaming</I> conforme llegan por el pipeline (esto se entenderá mejor cuando lleguemos al tema
                    de pipelines), con menor consumo de memoria y mejor composición con otros cmdlets (<PowerShellInline
                        code="Get-ChildItem ... | Where-Object ... | ForEach-Object { ... }"
                    />). Útil para árboles grandes de archivos o secuencias largas.
                </ListItem>
            </List>

            <Tip headingLevel="h4">
                Prefiere <PowerShellInline code="foreach" /> cuando: ya tienes los datos en una variable, buscas
                velocidad/claridad y vas a ejecutar varias acciones por elemento. Usa <PowerShellInline
                    code="ForEach-Object"
                /> cuando: estés componiendo pipelines, quieras <I>streaming</I> para ahorrar memoria o necesites
                <PowerShellInline code="-Parallel" /> (esto último escapa del alcance del curso).
            </Tip>

            <Note headingLevel="h4">
                La abreviatura <PowerShellInline code="| % { ... }" /> es equivalente a un <PowerShellInline
                    code="ForEach-Object"
                />, pero en scripts se recomienda usar <PowerShellInline code="ForEach-Object" /> por legibilidad..
            </Note>
        </More>

        <More>
            <span slot="title">¿Y <PowerShellInline code={`for`} />?</span>

            <P>
                Además de <PowerShellInline code="foreach" /> y <PowerShellInline code="ForEach-Object" />, PowerShell
                también incluye la estructura clásica <PowerShellInline code="for" />, similar a la de lenguajes como C,
                Java o JavaScript. Es menos común en scripts de PowerShell, pero útil cuando necesitas control manual
                sobre un contador o índices.
            </P>

            <List>
                <ListItem icon={icons.ArrowsClockwise}>
                    <B><PowerShellInline code="for" /></B> permite definir tres expresiones: inicialización, condición y
                    actualización. Por ejemplo:
                    <PowerShellBlock code={`for ($i = 0; $i -lt 5; $i++) { "Iteración $i" }`} />
                    Aquí <PowerShellInline code="$i = 0" /> inicializa el contador,
                    <PowerShellInline code="$i -lt 5" /> controla la condición de salida, y <PowerShellInline
                        code="$i++"
                    /> incrementa el valor en cada iteración.
                </ListItem>

                <ListItem icon={icons.Rocket}>
                    Es más adecuado cuando:
                    <List>
                        <ListItem icon={icons.NumberCircleOne}>
                            Necesitas iterar un número específico de veces.
                        </ListItem>

                        <ListItem icon={icons.NumberCircleTwo}>
                            Requieres acceder al índice actual.
                        </ListItem>

                        <ListItem icon={icons.NumberCircleThree}>
                            Vas a modificar valores dentro de un arreglo o lista usando índices.
                        </ListItem>
                    </List>
                </ListItem>
            </List>

            <Tip headingLevel="h4">
                Usa <PowerShellInline code="for" /> sólo cuando necesites un contador explícito o debas manipular
                índices. Si solo necesitas recorrer colecciones, <PowerShellInline code="foreach" /> es más idiomático y
                expresivo. En la práctica, <PowerShellInline code="for" /> se usa con poca frecuencia en scripts de
                PowerShell.
            </Tip>
        </More>

        <P class="mt-4">Ahora puedes ejecutar el script desde la terminal:</P>

        <PowerShellBlock
            code={`
                ./scripts/core/Add-License.ps1 -Root . -Owner "Tu Nombre" -WhatIf
            `}
        >
            <span slot="title">Desde la terminal de PowerShell</span>
        </PowerShellBlock>

        <P>
            Si todo se ve bien, vuelve a ejecutar sin <PowerShellInline code="-WhatIf" /> para aplicar los cambios de
            verdad.
        </P>

        <Question headingLevel="h3">
            ¿Qué sucede si ejecutas el script dos veces seguidas? ¿Y si cambias el valor de <PowerShellInline
                code="-Owner"
            />?
        </Question>
    </NotesSection>

    <Exercise>
        <span slot="title">Normalizar archivos Markdown</span>

        <Fragment slot="requirements">
            Escribe un script que <B>normalice archivos Markdown</B> en un árbol de proyectos (por ejemplo, todos los
            <Mono>README.md</Mono>):

            <List class="mt-2">
                <ListItem icon={icons.Eraser}>
                    Quita espacios en blanco al final de cada línea.
                </ListItem>

                <ListItem icon={icons.ArrowsLeftRight}>
                    Asegura que el archivo termine con un salto de línea.
                </ListItem>

                <ListItem icon={icons.Calendar}>
                    Agrega o actualiza una línea <MarkdownInline code="Last updated: YYYY-MM-DD" /> al final con
                    <PowerShellInline code="-UpdateStamp" />.
                </ListItem>

                <ListItem icon={icons.ShieldCheck}>
                    Debe soportar <MarkdownInline code="-WhatIf" /> y <MarkdownInline code="-Confirm" /> (patrón de <I
                    >ensayo seguro</I>).
                </ListItem>
            </List>
        </Fragment>

        <Definition headingLevel="h3">
            <span slot="title">
                <PowerShellInline code="[switch]" />: <Enquote>booleano</Enquote> por presencia
            </span>

            <P>
                Declarar un parámetro como <PowerShellInline code="[switch] $UpdateStamp" /> es similar a un booleano
                que representa la presencia o ausencia del switch en la línea de comandos. Si se incluye
                <PowerShellInline code="-UpdateStamp" />, el valor de <PowerShellInline code="$UpdateStamp.IsPresent" />
                es
                <PowerShellInline code="$true" />; si no, es <PowerShellInline code="$false" />.
            </P>
        </Definition>

        <PowerShellBlock
            code={`
                $a -eq $b        # Igualdad
                $a -ne $b        # Desigualdad
                $a -lt $b        # Menor que
                $a -le $b        # Menor o igual que
                $a -gt $b        # Mayor que
                $a -ge $b        # Mayor o igual que
                $a -and $b       # Y lógico
                $a -or $b        # O lógico
            `}
        ><span slot="title">Operadores útiles</span></PowerShellBlock>

        <Fragment slot="hints">
            <List>
                <ListItem icon={icons.TextT}>
                    Para limpiar espacios al final de línea, utiliza <PowerShellInline code="-replace" /> con el patrón
                    <PowerShellInline code={`'[ \\t]+(?=\\r?\\n)'`} /> (espacios o tabs antes de salto de línea).
                </ListItem>

                <ListItem icon={icons.ArrowsLeftRight}>
                    Puedes verificar que un string termine con salto de línea usando 
                    <MarkdownInline code="$_.EndsWith([Environment]::NewLine)" /> ()
                </ListItem>

                <ListItem icon={icons.Calendar}
                >Para buscar y reemplazar el sello de fecha, usa el patrón <PowerShellInline
                        code={`'(?im)^\\s*Last updated: .*$'`}
                    /> con <MarkdownInline code="[regex]::Replace(...)" />.</ListItem></List></Fragment>

        <Solution><PowerShellBlock
                code={`
          #Requires -Version 7.0
          [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
          param(
              [Parameter(Mandatory)]
              [ValidateNotNullOrEmpty()]
              [string] $Root,

              [switch] $UpdateStamp
          )

          $rootPath = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Root)
          $files = Get-ChildItem -Path $rootPath -Recurse -File -Filter README.md

          foreach ($file in $files) {
              $original = Get-Content -LiteralPath $file.FullName -Raw

              # 1) Quitar espacios en blanco al final de cada línea
              $clean = [regex]::Replace($original, '[ \\t]+(?=\\r?\\n)', '')

              # 2) Asegurar salto de línea final
              if (-not $clean.EndsWith([Environment]::NewLine)) {
                  $clean += [Environment]::NewLine
              }

              # 3) Agregar/actualizar sello de fecha si se pidió -UpdateStamp
              if ($UpdateStamp) {
                  $stamp = "Last updated: $(Get-Date)"
                  if ($clean -match '(?im)^\\s*Last updated: .*$') {
                      $clean = [regex]::Replace($clean, '(?im)^\\s*Last updated: .*$', $stamp, 1)
                  }
                  else {
                      $clean = $clean + $stamp + [Environment]::NewLine
                  }
              }

              # Aplicar cambios solo si hubo modificaciones, respetando -WhatIf
              if (($clean -ne $original) -and (
                      $PSCmdlet.ShouldProcess(
                          $file.FullName, 'Normalize Markdown whitespace and stamp'))) {
                  Set-Content -LiteralPath $file.FullName -Encoding utf8 -NoNewline:$false -Value $clean
                  Write-Output "Fixed -> $($file.FullName)"
              }
              else {
                  Write-Verbose "No changes -> $($file.FullName)"
              }
          }
      `}
            ><slot slot="title" />
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="Cleanup-Readmes.ps1"
                /></PowerShellBlock></Solution></Exercise>

    <Footnotes>
        <Footnote index={1}>
            Usaremos la licencia BSD-2 como ejemplo por ser simple y permisiva, pero puedes usar la que prefieras (MIT,
            Apache-2.0, GPL, etc.). Revisa la <Link href="https://spdx.org/licenses/">lista de licencias SPDX</Link>
            para más opciones.
        </Footnote>

        <Footnote index={2}>
            Como es <I>regex</I>, si el texto de reemplazo puede contener metacaracteres (por ejemplo barras
            invertidas), puedes proteger el patrón con <PowerShellInline code="[regex]::Escape(...)" /> o usar el
            operador <PowerShellInline code="-creplace" /> si necesitas coincidencia <I>case-sensitive</I>.
        </Footnote>
    </Footnotes>
</NotesLayout>

<!--
    <ConclusionsLayout
          ><Fragment slot="conclusions">
            En esta lección exploramos dos patrones fundamentales para escribir
            scripts más seguros y útiles en PowerShell. Primero, el <strong
              >ensayo seguro</strong
            > con
            <PowerShellInline code="-WhatIf" /> y <PowerShellInline
              code="-Confirm"
            />, que permite simular o confirmar operaciones antes de aplicarlas.
            Luego, el recorrido y transformación de archivos, aplicando validaciones y
            operaciones típicas sobre proyectos (por ejemplo, crear <code
              >LICENSE</code
            > y asegurar secciones en
            <code>README.md</code>). Ambos enfoques muestran cómo usar la
            <strong>pipeline de objetos</strong>, las validaciones de parámetros y las
            capacidades de <PowerShellInline code="[CmdletBinding()]" /> para hacer scripts
            más expresivos, confiables y mantenibles.</Fragment
          >

          <Fragment slot="key-points"
            ><ListItem icon={icons.ShieldCheck}
              >El patrón de <strong>ensayo seguro</strong> evita efectos no deseados y
              aumenta la confianza en el script.</ListItem
            >

            <ListItem icon={icons.FolderOpen}
              >Recorrer y transformar archivos es un caso común al estandarizar
              proyectos y metadatos.</ListItem
            >

            <ListItem icon={icons.SlidersHorizontal}
              >Validaciones de parámetros y atributos como <PowerShellInline
                code="[ValidateRange]"
              /> o
              <PowerShellInline code="[switch]" /> hacen los scripts más robustos.</ListItem
            >

            <ListItem icon={icons.Terminal}
              >La combinación de <PowerShellInline code="[CmdletBinding()]" /> y cmdlets
              como
              <PowerShellInline code="Write-Verbose" /> aporta control y claridad al ejecutar.</ListItem
            ></Fragment
          >

          <Fragment slot="takeaways"
            >El scripting en PowerShell no se limita a resolver tareas inmediatas: se
            trata de desarrollar <em>hábitos de diseño</em> que hagan que tus herramientas
            sean confiables, predecibles y fáciles de mantener. Incorporar confirmaciones,
            validaciones y diagnósticos transforma simples scripts en piezas reutilizables
            y seguras, que pueden crecer junto con tus proyectos y bibliotecas de software.</Fragment
          ></ConclusionsLayout
        >

        <References
          ><Fragment slot="recommended"
            ><WebPage
              title="Everything you wanted to know about ShouldProcess"
              url="https://learn.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess"
              location="Microsoft Learn"
              ><Fragment slot="description"
                >Guía práctica y profunda sobre cómo agregar soporte a <PowerShellInline
                  code=`-WhatIf`
                /> y
                <PowerShellInline code=`-Confirm` /> en funciones PowerShell con <PowerShellInline
                  code=`SupportsShouldProcess`
                />. Explica el uso correcto de <PowerShellInline
                  code=`$PSCmdlet.ShouldProcess()`
                /> (y sus
                <em>overloads</em>), dónde colocarlo en el flujo (especialmente en
                bucles), y cómo se relaciona con variables de preferencia como
                <PowerShellInline code=`$WhatIfPreference` />, <PowerShellInline
                  code=`$ConfirmPreference`
                /> y <PowerShellInline code=`ConfirmImpact` />. Distingue
                <PowerShellInline code=`ShouldProcess` /> de <PowerShellInline
                  code=`ShouldContinue`
                /> (cuándo usar cada uno) e incluye patrones para implementar <PowerShellInline
                  code=`-Force`
                /> sin romper confirmaciones ni simulaciones. Cubre matices de propagación
                entre módulos de script, localización de los prompts y formas de pasar
                <em>switches</em> (<PowerShellInline code=`-WhatIf:$true` />, <em
                  >splatting</em
                >). Ideal para quienes diseñan funciones seguras y reproducibles, y
                quieren entender los bordes reales de
                <PowerShellInline code=`-WhatIf` />/<PowerShellInline
                  code=`-Confirm`
                /> más allá de lo básico.
              </Fragment></WebPage
            ></Fragment
          >

          <!-- <Fragment slot="additional">...</Fragment>
    </References >

    <Footnotes><Footnote index={1}><PowerShellInline code="&" /> ejecuta un script en un nuevo contexto, sin compartir
            variables locales. En cambio, <PowerShellInline code="." /> (dot-sourcing) carga el script en el contexto
            actual, permitiendo que sus funciones y variables permanezcan disponibles después de la ejecución.</Footnote>

        <Footnote index={3}
        >En scripts, <PowerShellInline code="Write-Output" /> es preferible a
            <PowerShellInline code="Write-Host" /> porque escribe en el pipeline, permitiendo redirección, filtrado y
            pruebas automatizadas.
            <PowerShellInline code="Write-Host" /> solo imprime en pantalla y rompe esa flexibilidad, por lo que se
            recomienda usarlo únicamente para mostrar mensajes interactivos al usuario.</Footnote></Footnotes>*/ }
-->
