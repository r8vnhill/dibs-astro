---
import * as icons from "~/assets/img/icons";
import comoImg from "~/assets/img/why/como.webp";
import { Enquote, Heading, P } from "~/components/semantics";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Important,
    More,
    Note,
    Question,
    Tip,
} from "~/components/ui/callouts";
import { MarkdownInline, OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link, PythonLink } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, Book, References, WebPage } from "~/components/ui/references";
import ToDo from "~/components/utils/ToDo";
import { LinksLayout } from "~/layouts";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Patrones básicos de scripting"
    description="Patrones básicos de scripting en PowerShell: -WhatIf/-Confirm, foreach vs ForEach-Object, regex y rutas portables. Diseña scripts seguros y mantenibles."
    git={{ user: "r8vnhill", repo: "dibs-scripts" }}
>
    <Abstract>
        <P>
            Esta lección eleva tus scripts de <Enquote>funcionan en mi máquina</Enquote> a herramientas seguras y
            mantenibles. Practicarás el <B>ensayo seguro</B> con <PowerShellInline code="-WhatIf" /> y
            <PowerShellInline code="-Confirm" /> mediante <PowerShellInline code="SupportsShouldProcess" />, y
            recorrerás árboles de archivos con <PowerShellInline code="foreach" /> para aplicar transformaciones
            idempotentes. También aprenderás a usar expresiones regulares, tipos de versión y resolución de rutas para
            mantener consistencia y portabilidad en tus scripts.
        </P>

        <P>
            Como cierre, implementarás <PowerShellInline code={`Update-ScriptRequiresVersion.ps1`} />, un script que
            ajusta la directiva de versión <PowerShellInline code={`#Requires -Version`} /> de forma automática, segura
            y predecible. El objetivo es que tus herramientas no solo funcionen, sino que lo hagan de manera confiable
            cuando crece el proyecto o las ejecuta otra persona.
        </P>
    </Abstract>

    <NotesSection id="h2-should-process">
        <Heading
            headingLevel="h2" Icon={icons.ShieldCheck}
            slot="heading"
        >
            Patrón de ensayo seguro (simular antes de ejecutar)
        </Heading>

        <P>
            Antes de modificar archivos o crear estructuras, es buena práctica hacer un “ensayo” que muestre <I>qué</I>
            se haría sin hacerlo realmente. En PowerShell esto se logra con <PowerShellInline code="-WhatIf" /> (vía
            <PowerShellInline code="SupportsShouldProcess" />). Así evitamos efectos no deseados y ganamos confianza en
            el script.
        </P>

        <ToDo
          client:only="react"
          metadata={{
            tasks: [
              "Usar objeto de dominio en lugar de string",
            ],
          }}
        />

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrEmpty()]
                    [string] $Name,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                    [string] $Path
                )

                $base = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)
                $target = Join-Path $base $Name
                $readmePath = Join-Path $target 'README.md'
                $helperPath = Join-Path $PSScriptRoot 'New-Readme.ps1' -Resolve

                Write-Verbose (@'
                Base path: {0}
                Project destination: {1}
                Helper: {2}
                '@ -f $base, $target, $helperPath)

                if (!(Test-Path -Path $readmePath -PathType Leaf)) {
                    if ($PSCmdlet.ShouldProcess($readmePath, 'Create README.md')) {
                        $content = & $helperPath -Name $Name -Verbose:$VerbosePreference
                        Set-Content -Path $readmePath -Encoding UTF8 -Value $content

                        Write-Information ('README.md created successfully at {0}' -f $readmePath)
                    }
                }
                else {
                    Write-Warning ('README.md already exists at {0}; creation skipped.' -f $readmePath)
                }
            `}
        >
            <Fragment slot="title">
                Initialize-Project (con <code>-WhatIf</code>)
            </Fragment>
            <DibsSourceLink
                repo="scripts" file="core/Initialize-Project.ps1"
                slot="source" ref="433e47c4c33d32ebc072e9eb8b31f6cc8200584d"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.Shield}>
                    <PowerShellInline code="SupportsShouldProcess" /> permite simular o confirmar acciones con
                    <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" />. Esto hace que los
                    scripts sean más seguros al modificar el sistema, sobre todo con <PowerShellInline
                        code="ConfirmImpact = 'Medium'"
                    />.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <PowerShellInline code="[ValidateNotNullOrWhiteSpace()]" /> (desde PowerShell&nbsp;7.4) evita que el
                    valor sea <PowerShellInline code="$null" />, vacío o solo espacios.
                </ListItem>

                <ListItem icon={icons.CurrencyDollar}>
                    <PowerShellInline code="$PSCmdlet" /> expone información y utilidades del “cmdlet actual”, como
                    <PowerShellInline code="ShouldProcess()" /> para integrar <PowerShellInline code="-WhatIf" /> y
                    <PowerShellInline code="-Confirm" />.
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    <PowerShellInline code="Path" /> puede incluir el proveedor (por ejemplo,
                    <Mono>Microsoft.PowerShell.Core\FileSystem::C:\Users</Mono>), mientras que
                    <PowerShellInline code="ProviderPath" /> muestra solo la ruta del sistema (por ejemplo, <Mono
                    >C:\Users</Mono>).
                    <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath(...)" /> es una forma segura y
                    portable de obtener el <I>provider path</I> real dentro de un script. Como ya validamos que la ruta
                    existe con
                    <PowerShellInline code="[ValidateScript(...)]" />, usar <Mono>Unresolved</Mono> es suficiente y
                    confiable.

                    <More headingLevel="h5">
                        <span slot="title">¿Y si necesito usar <Mono>Resolved</Mono>?</span>

                        <P>
                            <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath(...)" /> no requiere
                            que la ruta exista, por lo que es más flexible. En cambio,
                            <PowerShellInline code="$PSCmdlet.GetResolvedProviderPathFromPSPath(...)" /> solo funciona
                            con rutas reales existentes y necesita un parámetro adicional que representa el proveedor
                            (por ejemplo, el file system). Este enfoque es menos común y se usa principalmente en
                            escenarios más avanzados.
                        </P>

                        <P>Ejemplo de uso con la variante <Mono>Resolved</Mono>:</P>

                        <PowerShellBlock
                            code={`
                                $base = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path,
                                    [ref](Get-PSProvider FileSystem))
                            `}
                        >
                            <Fragment slot="title">Conversión a ruta resuelta</Fragment>
                            <Fragment slot="footer">Devuelve la ruta real solo si existe.</Fragment>
                        </PowerShellBlock>
                    </More>
                </ListItem>

                <ListItem icon={icons.Info}>
                    <PowerShellInline code="Write-Information" /> y <PowerShellInline code="Write-Warning" /> muestran
                    mensajes sin detener la ejecución. Se usan junto a <PowerShellInline code="Write-Verbose" /> para
                    diferenciar propósitos.
                </ListItem>

                <ListItem icon={icons.Link}>
                    <B><PowerShellInline code="$PSScriptRoot" /></B> devuelve la ruta donde está el script actual. Útil
                    para cargar helpers locales sin depender del directorio de ejecución.
                </ListItem>

                <ListItem icon={icons.MapPin}>
                    <B><PowerShellInline code="-Resolve" /></B> en <PowerShellInline code="Join-Path" /> verifica que la
                    ruta exista y devuelve su forma absoluta; falla si el archivo no existe.
                </ListItem>

                <ListItem icon={icons.PlayCircle}>
                    <B><PowerShellInline code="&" /></B> ejecuta comandos o scripts almacenados en variables, como
                    <PowerShellInline code="& $helperPath -Name $Name" />.
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    <B><PowerShellInline code="-Switch:$variable" /></B> permite pasar un switch solo si la variable
                    booleana es
                    <PowerShellInline code="$true" />, como <PowerShellInline code="-Verbose:$VerbosePreference" />.
                </ListItem>
            </List>
        </Explanation>

        <Important headingLevel="h3">
            <Fragment slot="title">Confirmación y simulación</Fragment>
            <P>
                <PowerShellInline code="SupportsShouldProcess" /> habilita las banderas <PowerShellInline
                    code="-WhatIf"
                /> y <PowerShellInline code="-Confirm" />. <PowerShellInline code={`-WhatIf`} /> muestra lo que el
                script haría sin ejecutar acciones, mientras que <PowerShellInline code={`-Confirm`} /> pide
                confirmación antes de continuar.
            </P>
            <List>
                <ListItem icon={icons.CheckCircle}>
                    <PowerShellInline code="Low" /> → operaciones triviales.
                </ListItem>
                <ListItem icon={icons.FolderPlus}>
                    <PowerShellInline code="Medium" /> → crean o modifican archivos (como en este ejemplo).
                </ListItem>
                <ListItem icon={icons.Trash}>
                    <PowerShellInline code="High" /> → operaciones destructivas o críticas.
                </ListItem>
            </List>
        </Important>

        <NotesSection id="h3-safe-dry-run">
            <Heading
                headingLevel="h3" Icon={icons.TerminalWindow}
                slot="heading"
            >
                Ensayo seguro con <Mono>-WhatIf</Mono> y confirmación
            </Heading>

            <P>
                Antes de crear carpetas o archivos, ensaya el cambio con <PowerShellInline code="-WhatIf" />. Así
                verificas <I>qué</I> haría el script sin modificar nada. Si además quieres pedir confirmación
                interactiva, usa <PowerShellInline code="-Confirm" />.
            </P>

            <PowerShellBlock
                code={`
                    ./scripts/Initialize-Project.ps1 -Name "Test" -Path "." -Verbose -WhatIf
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/</Mono></Fragment>
            </PowerShellBlock>

            <OutputBlock
                code={`
                    What if: Performing the operation "Initialize project and create README.md" on target "/path/to/dibs/Test".
                `}
            >
                <span slot="title">Salida con <PowerShellInline code="-WhatIf" /></span>
            </OutputBlock>

            <Question headingLevel="h4">
                Prueba distintos valores de <PowerShellInline code="-Name" /> y <PowerShellInline code="-Path" /> con
                <PowerShellInline code="-WhatIf" />. ¿Qué sucede si el proyecto ya existe? ¿Y si la ruta no existe?
            </Question>

            <Question headingLevel="h4">
                Ejecuta el script con <PowerShellInline code="-Confirm" /> para observar el flujo de confirmaciones.
            </Question>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-iteration">
        <Heading headingLevel="h2" Icon={icons.ArrowsClockwise}>
            Recorrer y transformar archivos
        </Heading>

        <P>
            Un caso típico en bibliotecas de software es estandarizar metadatos: por ejemplo, asegurarte de que cada
            proyecto tenga archivo <Mono>LICENSE</Mono> y que su <Mono>README.md</Mono> incluya una sección de licencia.
            A continuación iteramos por todos los <Mono>README.md</Mono> del árbol, creamos <Mono
            >LICENSE</Mono><FootnoteRef index={1} />&nbsp;si falta y añadimos (o evitamos duplicar) la sección
            <MarkdownInline code="## License" />.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -Path $_ -PathType Container })]
                    [string] $Root,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Owner,
                    
                    [ValidateRange(1900, 3000)]
                    [int] $Year = (Get-Date).Year
                )

                $rootPath = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Root)
                $bsd2Url = 'https://raw.githubusercontent.com/spdx/license-list-data/master/text/BSD-2-Clause.txt'
                $section = @'
                ## License

                This project is licensed under the **BSD 2-Clause** license.  
                See the [LICENSE](./LICENSE) file for details.
                '@

                $licenseText = (Invoke-RestMethod -Uri $bsd2Url) -replace '<year>', $Year -replace (
                    '<owner>', $Owner)

                $foundReadmes = Get-ChildItem -Path $rootPath -Recurse -File -Filter README.md

                foreach ($readme in $foundReadmes) {
                    $dir = $readme.DirectoryName
                    $licensePath = Join-Path $dir 'LICENSE'

                    if (!(Test-Path -LiteralPath $licensePath)) {
                        if ($PSCmdlet.ShouldProcess($licensePath, 'Create LICENSE (BSD-2)')) {
                            Set-Content -LiteralPath $licensePath -Encoding utf8 -Value $licenseText
                            Write-Information ('LICENSE created -> {0}' -f $licensePath)
                        }
                    }
                    else {
                        Write-Warning ('LICENSE already present -> {0}' -f $licensePath)
                    }

                    $readmeText = Get-Content -LiteralPath $readme.FullName -Raw
                    if ($readmeText -notmatch '(?im)^##\\s*License\\b') {
                        if ($PSCmdlet.ShouldProcess($readme.FullName, 'Append License section')) {
                            Add-Content -LiteralPath $readme.FullName -Encoding utf8 -Value (
                                '{0}{0}{1}' -f [Environment]::NewLine, $section)
                            Write-Information ('License section appended -> {0}' -f $readme.FullName)
                        }
                    }
                    else {
                        Write-Warning ('README already has a License section -> {0}' -f $readme.FullName)
                    }
                }
            `}
        >
            <span slot="title">Estandarizar LICENSE y sección en README.md</span>
            <DibsSourceLink
                slot="source" repo="scripts"
                file="core/Add-License.ps1"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.NumberCircleOne}>
                    <PowerShellInline code="[ValidateRange(1900, 3000)]" /> valida en tiempo de <I>binding</I> que
                    <PowerShellInline code="-Year" /> esté dentro del rango permitido. Si no, PowerShell detiene el
                    script antes de ejecutar la lógica.

                    <More headingLevel="h5">
                        <span slot="title">¿Y si estoy programando después del año 3000?</span>

                        <img
                            src={comoImg.src} alt="¿Qué?"
                            class="mx-auto my-4 w-64 rounded-xl shadow-md transition-transform duration-300 hover:scale-105"
                        />
                    </More>
                </ListItem>

                <ListItem icon={icons.CloudArrowDown}>
                    <PowerShellInline code="Invoke-RestMethod" /> descarga el contenido y te entrega directamente el <I
                    >cuerpo</I> (string u objeto si es JSON/XML). Es ideal cuando quieres el payload sin metadatos. En
                    cambio, <PowerShellInline code="Invoke-WebRequest" /> retorna un objeto más “pesado” con
                    encabezados, estado, etc., y el texto viene en <Mono>.Content</Mono>.
                    <br />
                    Como la licencia de SPDX es texto plano y solo nos interesa el contenido, <PowerShellInline
                        code="Invoke-RestMethod"
                    /> es la opción más simple.
                </ListItem>

                <ListItem icon={icons.PencilSimpleLine}>
                    <B>Reemplazos con</B> <PowerShellInline code="-replace" />: es un operador de <I>expresiones
                        regulares</I> que recibe <Mono>patrón</Mono> y <Mono>reemplazo</Mono>. En el script encadenamos
                    dos reemplazos: primero <PowerShellInline code={`'<year>'`} /> por <PowerShellInline
                        code="$Year"
                    />, y luego <PowerShellInline code={`'<owner>'`} /> por <PowerShellInline
                        code="$Owner"
                    />.<FootnoteRef index={2} />
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    <B>Enumerar archivos</B> con <PowerShellInline code="Get-ChildItem -Recurse -File -Filter" />:
                    <List>
                        <ListItem icon={icons.ArrowBendDoubleUpRight}>
                            <PowerShellInline code="-Recurse" /> recorre subcarpetas.
                        </ListItem>
                        <ListItem icon={icons.File}>
                            <PowerShellInline code="-File" /> limita a archivos.
                        </ListItem>
                        <ListItem icon={icons.FileMd}>
                            <PowerShellInline code="-Filter README.md" /> conserva sólo archivos <Mono>README.md</Mono>;
                            usar <PowerShellInline code={`Where-Object`} /> es una alternativa, pero usualmente es menos
                            eficiente porque filtra <B>después</B> de obtener todos los archivos.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.ArrowsClockwise}>
                    <PowerShellInline code="foreach ($readme in $foundReadmes) { ... }" />: bucle nativo (no de
                    pipeline) que itera colecciones en memoria. Es rápido y legible para transformaciones por archivo.
                </ListItem>

                <ListItem icon={icons.Funnel}>
                    <PowerShellInline code="$readmeText -notmatch '(?im)^##\\s*License\\b'" /> usa el operador de
                    comparación con expresiones regulares <PowerShellInline code="-match" /> / <PowerShellInline
                        code="-notmatch"
                    />. Este devuelve un valor booleano según si la cadena cumple (o no cumple) con el patrón dado. En
                    este caso:
                    <List>
                        <ListItem icon={icons.TextT}>
                            La expresión regular <Mono>(?im)^##\s*License\b</Mono>
                            busca un encabezado <MarkdownInline code="## License" /> al inicio de una línea.
                        </ListItem>

                        <ListItem icon={icons.TextAa}>
                            La bandera <Mono>i</Mono> ignora mayúsculas/minúsculas; <Mono>m</Mono> permite que <Mono
                            >^</Mono> coincida con el inicio de cada línea (no solo del texto completo).
                        </ListItem>

                        <ListItem icon={icons.ShieldCheck}>
                            Con <PowerShellInline code="-notmatch" /> verificamos que no exista aún esa sección,
                            evitando duplicar la licencia en el README.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.TextIndent}>
                    <PowerShellInline code="[Environment]::NewLine" /> devuelve el separador de línea apropiado para el
                    sistema operativo (por ejemplo, <Mono>\r\n</Mono> en Windows, <Mono>\n</Mono> en Unix).
                </ListItem>

                <ListItem icon={icons.PlusCircle}>
                    <PowerShellInline code="Add-Content" /> agrega texto al final de un archivo existente, mientras que
                    <PowerShellInline code="Set-Content" /> sobrescribe el contenido. Aquí usamos <PowerShellInline
                        code="Add-Content -Encoding utf8"
                    /> para anexar la sección de licencia al README preservando codificación UTF-8 y sin borrar lo
                    anterior.
                </ListItem>
            </List>
        </Explanation>

        <More headingLevel="h3">
            <span slot="title"><PowerShellInline code="ForEach-Object" /></span>

            <P>
                PowerShell ofrece dos formas de iterar colecciones: la palabra clave
                <PowerShellInline code="foreach" /> y el cmdlet <PowerShellInline code="ForEach-Object" />. Aunque se
                parecen, tienen diferencias importantes:
            </P>

            <List>
                <ListItem icon={icons.Rocket}>
                    <B><PowerShellInline code="foreach" /></B> (palabra clave): recorre una colección ya materializada
                    en memoria (por ejemplo, una variable como <PowerShellInline code="$foundReadmes" />). Suele ser más
                    rápido y permite usar <PowerShellInline code={`break`} />/<PowerShellInline code={`continue`} /> de
                    forma clara. Es ideal cuando ya tienes los datos y quieres un bucle “procedimental”.
                </ListItem>

                <ListItem icon={icons.Pipe}>
                    <B><PowerShellInline code="... | ForEach-Object { ... }" /></B> (cmdlet): procesa elementos <I>en
                        streaming</I> conforme llegan por el pipeline (esto se entenderá mejor cuando lleguemos al tema
                    de pipelines), con menor consumo de memoria y mejor composición con otros cmdlets (<PowerShellInline
                        code="Get-ChildItem ... | Where-Object ... | ForEach-Object { ... }"
                    />). Útil para árboles grandes de archivos o secuencias largas.
                </ListItem>
            </List>

            <Tip headingLevel="h4">
                Prefiere <PowerShellInline code="foreach" /> cuando: ya tienes los datos en una variable, buscas
                velocidad/claridad y vas a ejecutar varias acciones por elemento. Usa <PowerShellInline
                    code="ForEach-Object"
                /> cuando: estés componiendo pipelines, quieras <I>streaming</I> para ahorrar memoria o necesites
                <PowerShellInline code="-Parallel" /> (esto último escapa del alcance del curso).
            </Tip>

            <Note headingLevel="h4">
                La abreviatura <PowerShellInline code="| % { ... }" /> es equivalente a un <PowerShellInline
                    code="ForEach-Object"
                />, pero en scripts se recomienda usar <PowerShellInline code="ForEach-Object" /> por legibilidad..
            </Note>
        </More>

        <More>
            <span slot="title">¿Y <PowerShellInline code={`for`} />?</span>

            <P>
                Además de <PowerShellInline code="foreach" /> y <PowerShellInline code="ForEach-Object" />, PowerShell
                también incluye la estructura clásica <PowerShellInline code="for" />, similar a la de lenguajes como C,
                Java o JavaScript. Es menos común en scripts de PowerShell, pero útil cuando necesitas control manual
                sobre un contador o índices.
            </P>

            <List>
                <ListItem icon={icons.ArrowsClockwise}>
                    <B><PowerShellInline code="for" /></B> permite definir tres expresiones: inicialización, condición y
                    actualización. Por ejemplo:
                    <PowerShellBlock code={`for ($i = 0; $i -lt 5; $i++) { "Iteración $i" }`} />
                    Aquí <PowerShellInline code="$i = 0" /> inicializa el contador,
                    <PowerShellInline code="$i -lt 5" /> controla la condición de salida, y <PowerShellInline
                        code="$i++"
                    /> incrementa el valor en cada iteración.
                </ListItem>

                <ListItem icon={icons.Rocket}>
                    Es más adecuado cuando:
                    <List>
                        <ListItem icon={icons.NumberCircleOne}>
                            Necesitas iterar un número específico de veces.
                        </ListItem>

                        <ListItem icon={icons.NumberCircleTwo}>
                            Requieres acceder al índice actual.
                        </ListItem>

                        <ListItem icon={icons.NumberCircleThree}>
                            Vas a modificar valores dentro de un arreglo o lista usando índices.
                        </ListItem>
                    </List>
                </ListItem>
            </List>

            <Tip headingLevel="h4">
                Usa <PowerShellInline code="for" /> sólo cuando necesites un contador explícito o debas manipular
                índices. Si solo necesitas recorrer colecciones, <PowerShellInline code="foreach" /> es más idiomático y
                expresivo. En la práctica, <PowerShellInline code="for" /> se usa con poca frecuencia en scripts de
                PowerShell.
            </Tip>
        </More>

        <P class="mt-4">Ahora puedes ejecutar el script desde la terminal:</P>

        <PowerShellBlock
            code={`
                ./scripts/core/Add-License.ps1 -Root . -Owner "Tu Nombre" -WhatIf
            `}
        >
            <span slot="title">Desde <PowerShellInline code={`dibs/`} /></span>
        </PowerShellBlock>

        <P>
            Si todo se ve bien, vuelve a ejecutar sin <PowerShellInline code="-WhatIf" /> para aplicar los cambios de
            verdad.
        </P>

        <Question headingLevel="h3">
            ¿Qué sucede si ejecutas el script dos veces seguidas? ¿Y si cambias el valor de <PowerShellInline
                code="-Owner"
            />?
        </Question>
    </NotesSection>

    <Exercise headingLevel="h2">
        <Fragment slot="title">
            <Mono>Update-ScriptRequiresVersion</Mono>
        </Fragment>

        <Fragment slot="requirements">
            <List>
                <ListItem icon={icons.ShieldCheck}>
                    Crea <Mono>Update-ScriptRequiresVersion.ps1</Mono> con <PowerShellInline
                        code="SupportsShouldProcess"
                    />.
                </ListItem>

                <ListItem icon={icons.FolderOpen}>
                    Debe recorrer recursivamente una carpeta raíz y procesar todos los <Mono>.ps1</Mono> usando
                    <PowerShellInline code={`foreach`} />.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    Verifica en cada archivo cuántas veces aparece <PowerShellInline code={`#Requires -Version M.m`} />
                    (regex).
                    <br />
                    Regla:

                    <List>
                        <ListItem icon={icons.NumberCircleOne}>
                            <B>Si existe exactamente 1</B>: reemplaza su versión por la proporcionada (si no se
                            proporciona, usa la versión actual de PowerShell).
                        </ListItem>
                        <ListItem icon={icons.NumberCircleTwo}>
                            <B>Si no existe</B>: inserta <PowerShellInline code={`#Requires -Version M.m`} /> como <I
                            >primera línea</I> del script.
                        </ListItem>
                        <ListItem icon={icons.Warning}>
                            <B>Si existe más de una</B>: imprime <PowerShellInline code={`Write-Warning`} /> y no
                            modifica el archivo.
                        </ListItem>
                    </List>
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="notes">
            <Definition headingLevel="h4">
                <span slot="title"><PowerShellInline code={`[Version]`} /></span>

                <B><PowerShellInline code="[Version]" /></B> es el tipo .NET para representar versiones.

                <List>
                    <ListItem icon={icons.TerminalWindow}>
                        <B><PowerShellInline code="$PSVersionTable" /></B> es un <PowerShellInline
                            code={`[hashtable]`}
                        />
                        con datos de la sesión actual (por ejemplo, <PowerShellInline code={`.PSVersion`} />,
                        <PowerShellInline code={`.PSEdition`} />, <PowerShellInline code={`.Platform`} />, etc.).
                    </ListItem>

                    <ListItem icon={icons.Tag}>
                        <B><PowerShellInline code="$PSVersionTable.PSVersion" /></B> es un <PowerShellInline
                            code={`[Version]`}
                        /> que representa la versión del motor de PowerShell en ejecución (p. ej., <Mono>7.4.2</Mono>).
                    </ListItem>

                    <ListItem icon={icons.NumberCircleOne}>
                        <B><PowerShellInline code=".Major" /> / <PowerShellInline code=".Minor" /></B> son enteros de la
                        versión. Para normalizar a <Mono>Mayor.Menor</Mono> (recomendado en <Mono>#Requires
                            -Version</Mono>), compón la cadena así:
                        <PowerShellBlock
                            code={`
                                $v = $PSVersionTable.PSVersion
                                $target = '{0}.{1}' -f $v.Major, $v.Minor  # ej. "7.5"
                            `}
                        />
                    </ListItem>

                    <ListItem icon={icons.Lightbulb}>
                        Al declarar un parámetro <PowerShellInline code="[Version] $Version" />, puedes pasar
                        <PowerShellInline code={`'7.5'`} /> o <PowerShellInline code={`7.5`} />; PowerShell lo convierte
                        automáticamente a <PowerShellInline code={`[Version]`} />. Si no lo pasas, usar
                        <PowerShellInline code="$PSVersionTable.PSVersion" /> te da un valor consistente y tipado.
                    </ListItem>
                </List>
            </Definition>

            <Definition headingLevel="h4">
                <PowerShellInline code={`[regex]::Matches([string] $Input, [string] $Pattern)`} slot="title" />

                <List>
                    <ListItem icon={icons.MagnifyingGlass}>
                        <B><PowerShellInline code="[regex]::Matches($text, $rxRequires)" />:</B> Ejecuta el patrón sobre
                        <PowerShellInline code={`$text`} /> y devuelve un <PowerShellInline
                            code={`[MatchCollection]`}
                        /> (todas las coincidencias). Útil cuando quieres contar o recorrer múltiples matches.
                    </ListItem>

                    <ListItem icon={icons.NumberCircleOne}>
                        <B><PowerShellInline code="[MatchCollection].Count" />:</B> Cantidad de coincidencias
                        encontradas.
                    </ListItem>

                    <ListItem icon={icons.BracketsCurly}>
                        <B><PowerShellInline code="[MatchCollection][0].Groups[1].Value" />:</B> Del primer match
                        (<PowerShellInline code={`[0]`} />), toma el <I>primer</I> grupo de captura explícito
                        (<PowerShellInline code={`.Groups[1]`} />) y su texto (<PowerShellInline code={`.Value`} />).
                        <PowerShellInline code={`.Groups[0]`} /> es la coincidencia completa; los grupos capturados
                        empiezan en <PowerShellInline code={`1`} />.
                    </ListItem>
                </List>

                <PowerShellBlock
                    code={`
                        $rxRequires = '(?im)^\\s*#\\s*Requires\\s+-Version\\s+([0-9]+(?:\\.[0-9]+)?)\\s*$'

                        $matches = [regex]::Matches($text, $rxRequires)

                        $matches.Count              # -> 1
                        $matches[0].Value           # -> "#Requires -Version 7.5"
                        $matches[0].Groups[1].Value # -> "7.5"   (el grupo capturado de la versión)
                    `}
                >
                    <span slot="title">Ejemplo rápido</span>
                </PowerShellBlock>
            </Definition>
        </Fragment>

        <Fragment slot="use">
            <PowerShellBlock code={`./maintenance/Update-ScriptRequiresVersion.ps1 -Root . -WhatIf -Verbose`}>
                <span slot="footer">Ensayo — sin aplicar cambios</span>
                <Fragment slot="title">Desde <Mono>dibs/scripts/</Mono></Fragment>
            </PowerShellBlock>

            <PowerShellBlock code={`./maintenance/Update-ScriptRequiresVersion.ps1 -Root . -Version 7.5 -Confirm`}>
                <span slot="footer">Aplicación con confirmación</span>
                <Fragment slot="title">Desde <Mono>dibs/scripts/</Mono></Fragment>
            </PowerShellBlock>
        </Fragment>

        <Fragment slot="hints">
            <List>
                <ListItem icon={icons.TextT}>
                    Un patrón simple para la línea (modo multilinea/ignore case): <Mono
                    >(?im)^\s*#\s*Requires\s+-Version\s+([0-9]+(?:\.[0-9]+)?)\s*$</Mono>
                </ListItem>

                <ListItem icon={icons.ArrowsClockwise}>
                    Estructura típica: lee <Mono>-Raw</Mono>, calcula <Mono>$newText</Mono>, si cambia y <Mono
                    >ShouldProcess</Mono> → <Mono>Set-Content</Mono>.
                </ListItem>

                <ListItem icon={icons.Funnel}>
                    Puedes usar <PowerShellInline code={`Get-ChildItem ... -Filter *.ps1`} /> para limitar a archivos
                    <Mono>.ps1</Mono>.
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $Root,

                        [Version] $Version = $PSVersionTable.PSVersion
                    )

                    $rootPath = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Root)
                    $targetVersion = '{0}.{1}' -f $Version.Major, $Version.Minor
                    $requiresLine = '#Requires -Version {0}' -f $targetVersion
                    $rxRequires = '(?im)^\\s*#\\s*Requires\\s+-Version\\s+([0-9]+(?:\\.[0-9]+)?)\\s*$'

                    $foundScripts = Get-ChildItem -LiteralPath $rootPath -Recurse -File -Filter *.ps1
                    foreach ($script in $foundScripts) {
                        $text = Get-Content -LiteralPath $script.FullName -Raw
                        $matches = [regex]::Matches($text, $rxRequires)
                        $count = $matches.Count

                        if ($count -eq 0) {
                            $newText = '{0}{1}{2}' -f $requiresLine, [Environment]::NewLine, $text
                            if ($newText -ne $text) {
                                Write-Information (
                                    '[{0}] Insert #Requires -> {1}' -f $script.Name, $requiresLine)
                                if ($PSCmdlet.ShouldProcess($script.FullName, 'Insert #Requires -Version')) {
                                    Set-Content -LiteralPath $script.FullName -Encoding utf8 -Value $newText
                                }
                            }
                        }
                        elseif ($count -eq 1) {
                            $current = $matches[0].Groups[1].Value
                            if ($current -ne $targetVersion) {
                                $newText = $text -replace $rxRequires, $requiresLine
                                Write-Information ('[{0}] Update #Requires {1} -> {2}' -f $script.Name,
                                    $current, $targetVersion)
                                if ($PSCmdlet.ShouldProcess($script.FullName, 'Update #Requires -Version')) {
                                    Set-Content -LiteralPath $script.FullName -Encoding utf8 -Value $newText
                                }
                            }
                            else {
                                Write-Verbose ('[{0}] OK (version {1})' -f $script.Name, $current)
                            }
                        }
                        else {
                            Write-Warning ('[{0}] Multiple #Requires -Version lines found ({1}); skipping.' -f 
                                $script.Name, $count)
                        }
                    }
                `}
            >
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="maintenance/Update-ScriptRequiresVersion.ps1"
                />
            </PowerShellBlock>
        </Fragment>
    </Exercise>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            Esta lección nos llevó de <Enquote>escribir scripts que hacen cosas</Enquote> a <Enquote>diseñar
                herramientas seguras y mantenibles</Enquote>. Practicaste el <B>ensayo seguro</B> con <PowerShellInline
                code="-WhatIf"
            /> / <PowerShellInline code="-Confirm" />, recorriste árboles con <PowerShellInline code="foreach" /> y
            aplicaste transformaciones idempotentes. También normalizaste metadatos con expresiones regulares y
            aprendiste a encapsular decisiones peligrosas tras
            <PowerShellInline code="$PSCmdlet.ShouldProcess()" />. El resultado: scripts predecibles, auditables y
            fáciles de evolucionar.
        </Fragment>

        <Fragment slot="key-points">
            <List>
                <ListItem icon={icons.ShieldCheck}>
                    <PowerShellInline code="SupportsShouldProcess" /> + <PowerShellInline code="-WhatIf" /> /
                    <PowerShellInline code="-Confirm" /> ⇒ cambios controlados y reversibles.
                </ListItem>
                <ListItem icon={icons.ArrowsClockwise}>
                    <PowerShellInline code="foreach" /> para colecciones materializadas; <PowerShellInline
                        code="ForEach-Object"
                    /> para <I>streaming</I> en pipelines.
                </ListItem>
                <ListItem icon={icons.TextT}>
                    Regex bien acotadas permiten <I>detectar</I>, <I>contar</I> y <I>reemplazar</I> sin ambigüedades
                    (<PowerShellInline code="[regex]::Matches" /> / <PowerShellInline code="-replace" />).
                </ListItem>
                <ListItem icon={icons.MapPin}>
                    Resuelve rutas con <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath(...)" />
                    para portabilidad.
                </ListItem>
                <ListItem icon={icons.CheckCircle}>
                    Idempotencia: volver a ejecutar no debe romper ni duplicar; debe dejar el estado consistente.
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="takeaways">
            <P>
                El valor de un script no está solo en <Enquote>que funcione</Enquote>, sino en <I>cómo</I> se comporta
                cuando algo sale mal, cuando lo ejecuta otra persona o cuando el proyecto crece. Diseña con seguridad
                (ensayo, confirmación), claridad (mensajes, validaciones) y propósito (regex acotadas, versiones
                normalizadas). Si repites estos hábitos —simular, verificar, aplicar— convertirás tareas frágiles en <B
                >flujos confiables</B> que tu equipo puede reutilizar sin miedo.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <LinksLayout>
        <PythonLink />
    </LinksLayout>

    <References>
        <Fragment slot="recommended">
            <WebPage
                title="Everything you wanted to know about ShouldProcess"
                url="https://learn.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess"
                location="Microsoft Learn"
            >
                <Fragment slot="description">
                    Guía práctica y profunda sobre cómo agregar soporte a <PowerShellInline code={`-WhatIf`} /> y
                    <PowerShellInline code={`-Confirm`} /> en funciones PowerShell con <PowerShellInline
                        code={`SupportsShouldProcess`}
                    />. Explica el uso correcto de <PowerShellInline code={`$PSCmdlet.ShouldProcess()`} /> (y sus
                    <I>overloads</I>), dónde colocarlo en el flujo (especialmente en bucles), y cómo se relaciona con
                    variables de preferencia como <PowerShellInline code={`$WhatIfPreference`} />, <PowerShellInline
                        code={`$ConfirmPreference`}
                    /> y <PowerShellInline code={`ConfirmImpact`} />. Distingue <PowerShellInline
                        code={`ShouldProcess`}
                    /> de <PowerShellInline code={`ShouldContinue`} /> (cuándo usar cada uno) e incluye patrones para
                    implementar <PowerShellInline code={`-Force`} /> sin romper confirmaciones ni simulaciones. Cubre
                    matices de propagación entre módulos de script, localización de los prompts y formas de pasar
                    <I>switches</I> (<PowerShellInline code={`-WhatIf:$true`} />, <I>splatting</I>). Ideal para quienes
                    quieren entender los bordes reales de <PowerShellInline code={`-WhatIf`} />/<PowerShellInline
                        code={`-Confirm`}
                    /> más allá de lo básico.
                </Fragment>
            </WebPage>
        </Fragment>

        <Fragment slot="additional">
            <Book
                chapter="Adding logic and loops"
                bookTitle="Learn PowerShell in a month of lunches, fourth edition: Covers Windows, Linux, and MacOS"
                pages={[273, 278]}
            >
                <AuthorList slot="authors" authors={[{ firstName: "Travis", lastName: "Plunk" }]} />

                <Fragment slot="description">
                    Este capítulo explica los distintos tipos de bucles en PowerShell —<PowerShellInline
                        code={`foreach`}
                    />, <PowerShellInline code={`ForEach-Object`} /> y <PowerShellInline code={`while`} />—, mostrando
                    cuándo conviene usar cada uno y cómo difieren en comportamiento. Presenta ejemplos prácticos de
                    iteración sobre colecciones, procesamiento en <I>pipeline</I>, y ejecución en paralelo con
                    <PowerShellInline code={`ForEach-Object -Parallel`} />. También introduce los bucles
                    <PowerShellInline code={`while`} /> y <PowerShellInline code={`do while`} />, ilustrando cómo
                    controlar condiciones y tiempos de ejecución, y cómo aplicar operadores lógicos para construir
                    iteraciones más complejas.
                </Fragment>
            </Book>
        </Fragment>
    </References>

    <Footnotes>
        <Footnote index={1}>
            Usaremos la licencia BSD-2 como ejemplo por ser simple y permisiva, pero puedes usar la que prefieras (MIT,
            Apache-2.0, GPL, etc.). Revisa la <Link href="https://spdx.org/licenses/">lista de licencias SPDX</Link>
            para más opciones.
        </Footnote>

        <Footnote index={2}>
            Como es <I>regex</I>, si el texto de reemplazo puede contener metacaracteres (por ejemplo barras
            invertidas), puedes proteger el patrón con <PowerShellInline code="[regex]::Escape(...)" /> o usar el
            operador <PowerShellInline code="-creplace" /> si necesitas coincidencia <I>case-sensitive</I>.
        </Footnote>
    </Footnotes>
</NotesLayout>
