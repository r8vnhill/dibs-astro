---
import * as icons from "~/assets/img/icons";
import { P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Explanation, Important, Note } from "~/components/ui/callouts";
import Question from "~/components/ui/callouts/Question.astro";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import Cons from "~/components/ui/procons/Cons.astro";
import ProCons from "~/components/ui/procons/ProCons.astro";
import Pros from "~/components/ui/procons/Pros.astro";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Laboratorio 1: GitLab — crear repos y remotos" description="...">
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-intro">
        <Heading
            headingLevel="h2" Icon={icons.GitlabLogo}
            slot="heading"
        >
            Por qué GitLab y qué aprenderemos
        </Heading>

        <P>
            En este curso utilizaremos <B href="https://gitlab.com">GitLab</B>, una plataforma similar a GitHub pero con
            un enfoque más completo en integración continua (CI/CD), gestión de dependencias y publicación de paquetes.
            Es ampliamente usada en entornos profesionales, especialmente cuando las organizaciones mantienen su propia
            infraestructura de repositorios.
        </P>

        <P>
            Con GitLab practicaremos el flujo completo de trabajo:
            <B>crear, clonar, organizar, versionar y publicar</B> bibliotecas de software. Más adelante, usaremos su
            <I>Package Registry</I> para distribuir nuestras bibliotecas dentro de pipelines automatizados.
        </P>

        <ProCons>
            <Pros title="Ventajas">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>CI/CD integrado</B>: GitLab incluye un sistema de pipelines nativo (<I>GitLab CI</I>) sin
                        depender de servicios externos, ideal para automatizar pruebas, compilaciones y despliegues.
                        GitHub ofrece una solución similar con <I>GitHub Actions</I>, pero con una configuración
                        separada en YAML y límites distintos.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Registro de paquetes unificado</B>: permite publicar y consumir bibliotecas o imágenes de
                        contenedores en el mismo entorno, simplificando el flujo <I>build → test → publish</I>. En
                        GitHub, esta función está separada en <I>GitHub Packages</I>.
                    </ListItem>

                    <ListItem icon={icons.Lock}>
                        <B>Instalación autogestionada</B>: muchas organizaciones lo implementan en servidores propios,
                        facilitando el cumplimiento de políticas de seguridad y confidencialidad. GitHub ofrece una
                        alternativa con
                        <I>Enterprise Server</I>, pero bajo licenciamiento específico.
                    </ListItem>

                    <ListItem icon={icons.Users}>
                        <B>Gestión avanzada de roles y grupos</B>: ofrece jerarquías y permisos más detallados,
                        especialmente útiles en equipos grandes o con múltiples proyectos relacionados.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Automatización por línea de comandos</B> mediante <PowerShellInline code="glab" />: la CLI
                        oficial de GitLab permite crear, clonar o administrar repositorios sin usar la interfaz web.
                        GitHub cuenta con su propia CLI (<PowerShellInline code="gh" />) con fines similares.
                    </ListItem>
                </List>
            </Pros>

            <Cons>
                <List>
                    <ListItem icon={icons.CloudSlash}>
                        <B>Menor comunidad pública</B>: GitHub sigue siendo el principal espacio de colaboración
                        abierta, por lo que los proyectos en GitLab pueden tener menor visibilidad y participación al
                        inicio.<FootnoteRef index={1} />
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <B>Curva de aprendizaje más alta</B>: la interfaz y las opciones de CI/CD ofrecen mayor control,
                        pero también más complejidad para quienes comienzan.
                    </ListItem>

                    <ListItem icon={icons.Database}>
                        <B>Límites más estrictos en la nube</B>: la versión gratuita de GitLab Cloud tiene menor espacio
                        de almacenamiento y minutos de CI que GitHub.
                    </ListItem>

                    <ListItem icon={icons.Student}>
                        <B>Sin equivalente directo a GitHub Classroom</B>: GitLab no incluye una herramienta integrada
                        para gestionar tareas o repositorios de estudiantes. Aunque pueden configurarse soluciones
                        alternativas con grupos y scripts, <I>GitHub Classroom</I> sigue siendo más conveniente en
                        contextos educativos.
                    </ListItem>
                </List>
            </Cons>
        </ProCons>

        <P>
            Hoy aprenderemos a:
            <List>
                <ListItem icon={icons.FolderPlus}>Crear repositorios remotos automáticamente.</ListItem>
                <ListItem icon={icons.FolderOpen}>Inicializar proyectos locales y enlazarlos con su remoto.</ListItem>
                <ListItem icon={icons.Play}>Automatizar ambos pasos en un solo script.</ListItem>
            </List>
        </P>
    </NotesSection>

    <NotesSection id="scripts">
        <Heading
            headingLevel="h2" Icon={icons.Terminal}
            slot="heading"
        >
            Scripts del laboratorio
        </Heading>

        <Important>
            <span slot="title">Requisitos previos</span>

            <P>
                Antes de comenzar, asegúrate de haber iniciado sesión en GitLab desde la línea de comandos con:
            </P>

            <PowerShellBlock code={`glab auth login`}>
                <span slot="title">Desde la terminal</span>
                <span slot="footer">Iniciar sesión en GitLab CLI</span>
            </PowerShellBlock>
        </Important>

        <P>
            Todos los scripts son idempotentes: puedes ejecutarlos varias veces sin generar duplicados ni
            inconsistencias.
        </P>

        <NotesSection id="...">
            <Heading headingLevel="h3" Icon={null}
                slot="heading"
            >
                ...
            </Heading>
        
            <ToDo
                client:only="react"
                metadata={{
                    tasks: [
                        "Definir id",
                        "Definir el título y su ícono",
                        "Agregar texto 'al rededor' del código para contextualizar",
                        "Reemplazar placeholders como 'path/to/...' por valores reales",
                        `...`,
                    ],
                }}
            />

            <PowerShellBlock code={`
                #Requires -Version 7.5
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                    [string] $Path
                )

                $invoker = Join-Path $PSScriptRoot '..' 'core' 'Invoke-Tool.ps1' -Resolve

                $repoPath = $PSCmdlet.GetResolvedProviderPathFromPSPath($Path)

                try {
                    Write-Verbose "Checking if '$repoPath' is inside a Git work tree"
                    & $invoker git -C $repoPath rev-parse --is-inside-work-tree | Out-Null
                    $true
                }
                catch {
                    Write-Verbose "'$repoPath' is not inside a Git work tree"
                    $false
                }
            `}>
                <Fragment slot="title">...</Fragment>
                <Fragment slot="footer">...</Fragment>
                <Fragment slot="source">path/to/script.ps1</Fragment>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-new-gitlab-repo">
            <Heading
                headingLevel="h3" Icon={icons.GitBranch}
                slot="heading"
            >
                Crear repo remoto en GitLab
            </Heading>

            <p class="mb-3">
                Este script crea un repositorio remoto en GitLab usando <PowerShellInline code="glab" />, de forma
                idempotente: primero verifica su existencia y, si ya existe, devuelve un resultado estable sin fallar.
                Además, respeta <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" /> gracias a <I
                >SupportsShouldProcess</I>, y normaliza el nombre para cumplir con las restricciones del hosting.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrEmpty()]
                        [string] $Name,

                        [switch] $Public
                    )

                    $normalized = $Name.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', ''
                    if ([string]::IsNullOrWhiteSpace($normalized)) {
                        throw [System.ArgumentException]::new(
                            "Name '$Name' is not valid after normalizing to '$normalized' (only [a-z0-9-])."
                        )
                    }

                    $visibility = if ($Public) { 'public' } else { 'private' }

                    # Invocador utilitario para ejecutar binarios externos y capturar ExitCode/Output.
                    $invoker = Join-Path $PSScriptRoot '..' 'core' 'Invoke-Tool.ps1' -Resolve

                    try {
                        # Idempotencia: salir en éxito si ya existe.
                        & $invoker glab repo view $normalized | Out-Null
                        Write-Verbose "Repository '$normalized' already exists. Not creating it again."
                        return [pscustomobject]@{
                            Name       = $normalized
                            Visibility = $visibility
                            Created    = $false
                            Output     = @()
                            Message    = 'Repository already exists'
                        }
                    }
                    catch {
                        Write-Verbose "Repo '$normalized' not found. Will attempt to create it."
                    }

                    if ($PSCmdlet.ShouldProcess($normalized, "Create GitLab repository ($visibility)")) {
                        try {
                            $args = @('repo', 'create', $normalized, '--defaultBranch', 'main')
                            if ($Public) { $args += '--public' } else { $args += '--private' }

                            $result = & $invoker glab $args
                            $out = $result.Output

                            Write-Verbose ("Created '{0}' as {1}.{2}{3}" -f $normalized, $visibility, 
                                [Environment]::NewLine, ($out -join [Environment]::NewLine))

                            [pscustomobject]@{
                                Name       = $normalized
                                Visibility = $visibility
                                Created    = $true
                                Output     = $out
                                Message    = 'Repository created'
                            }
                        }
                        catch {
                            throw [System.AggregateException]::new(
                                "Failed to create repository '$Name' ('$normalized').", $_.Exception)
                        }
                    }
                `}
            >
                <Fragment slot="title">
                    Creación idempotente de repositorios en GitLab
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitLabRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.TextT}>
                        <PowerShellInline code=".ToLowerInvariant()" /> evita efectos de cultura (e.g. “I/İ” en turco) y
                        las expresiones regulares sustituyen espacios por guiones y filtran a
                        <Mono>[a-z0-9-]</Mono>.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <PowerShellInline code="& $invoker glab repo view $normalized" /> consulta el repo; si devuelve
                        <Mono>ExitCode = 0</Mono> asumimos que existe y devolvemos un objeto con <PowerShellInline
                            code="Created = $false"
                        />.
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <PowerShellInline code="& $invoker glab $args" /> ejecuta <PowerShellInline
                            code="glab repo create"
                        /> con
                        <PowerShellInline code="--defaultBranch main" /> y visibilidad según <PowerShellInline
                            code="-Public"
                        />. El bloque está protegido con <PowerShellInline code="try" />/<PowerShellInline
                            code="catch"
                        /> y arroja un <I>AggregateException</I> con contexto si falla.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-set-git-remote">
            <Heading
                headingLevel="h3" Icon={icons.Link}
                slot="heading"
            >
                Asignar remoto en Git
            </Heading>

            <p class="mb-3">
                Este script configura un remoto de Git de forma <B>idempotente</B>: si el remoto ya existe con la misma
                URL, no hace nada; si existe con otra URL, la actualiza; si no existe, lo crea. Usamos <PowerShellInline
                    code="git -C"
                />
                para operar en la carpeta del repo sin cambiar el directorio actual, y <I>SupportsShouldProcess</I> para
                habilitar
                <PowerShellInline code="-WhatIf" /> y <PowerShellInline code="-Confirm" />.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidatePattern('^(https://|git@|ssh://)')]
                        [string] $RemoteUrl,

                        [Parameter()]
                        [ValidateNotNullOrEmpty()]
                        [string] $Path = '.',

                        [ValidatePattern('^[\\w.-]+$')]
                        [string] $RemoteName = 'origin'
                    )

                    $invoker = Join-Path $PSScriptRoot '..' 'core' 'Invoke-Tool.ps1' -Resolve

                    $repoPath = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path)

                    $result = @{
                        RepoPath = $repoPath
                        Remote   = $RemoteName
                        Url      = $RemoteUrl
                        Existed  = $false
                        Changed  = $false
                        Action   = 'none'
                        Output   = @()
                        Message  = ''
                    }

                    $inside = $false
                    try {
                        & $invoker git -C $repoPath rev-parse --is-inside-work-tree | Out-Null
                        $inside = $true
                    }
                    catch { $inside = $false }

                    if (!$inside -and $WhatIfPreference) {
                        $result.Action = 'skipped'
                        $result.Message = 'WhatIf: would set remote after repository initialization'
                    }
                    elseif (!$inside) {
                        throw [System.AggregateException]::new(
                            "The path '$repoPath' is not a Git repository (or does not exist).",
                            $_.Exception
                        )
                    }
                    else {
                        $currentUrl = try {
                            $res = & $invoker git -C $repoPath remote get-url $RemoteName
                            $res.Output.Trim()
                        }
                        catch { $null }

                        $result.Existed = [bool]$currentUrl

                        if ($null -ne $currentUrl) {
                            if ([string]::Equals($currentUrl, $RemoteUrl, 'OrdinalIgnoreCase')) {
                                $result.Action = 'none'
                                $result.Message = 'Remote already configured'
                            }
                            elseif ($PSCmdlet.ShouldProcess("$RemoteName → $RemoteUrl", 'git remote set-url')) {
                                $set = & $invoker git -C $repoPath remote set-url $RemoteName $RemoteUrl
                                $result.Changed = $true
                                $result.Action = 'set-url'
                                $result.Output = $set.Output
                                $result.Message = "Remote URL updated (was: $currentUrl)"
                            }
                            else {
                                $result.Action = 'skipped'
                                $result.Message = 'Operation skipped'
                            }
                        }
                        elseif ($PSCmdlet.ShouldProcess("$RemoteName → $RemoteUrl", 'git remote add')) {
                            $add = & $invoker git -C $repoPath remote add $RemoteName $RemoteUrl
                            $result.Changed = $true
                            $result.Action = 'add'
                            $result.Output = $add.Output
                            $result.Message = 'Remote added'
                        }
                        else {
                            $result.Action = 'skipped'
                            $result.Message = 'Operation skipped'
                        }
                    }

                    [pscustomobject]$result
                `}
            >
                <Fragment slot="title">
                    Set-GitRemote.ps1
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Set-GitRemote.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.CheckCircle}>
                        <B>Validación de URL</B>: <PowerShellInline
                            code="[ValidatePattern('^(https://|git@|ssh://)')]"
                        /> asegura que apuntemos a un remoto válido (HTTPS o SSH) antes de ejecutar Git.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Verificar repo</B>: <PowerShellInline
                            code="& $invoker git -C $repoPath rev-parse --is-inside-work-tree"
                        /> confirma que la ruta es un repositorio Git; si falla, se lanza una excepción con contexto.
                    </ListItem>

                    <ListItem icon={icons.Eye}>
                        <B>Leer remoto actual</B>: el bloque <PowerShellInline code="try" />/<PowerShellInline
                            code="catch"
                        /> asigna <PowerShellInline code="$null" /> si el remoto no existe con <PowerShellInline
                            code="$currentUrl = try { ... } catch { $null }"
                        />.
                    </ListItem>

                    <ListItem icon={icons.Equals}>
                        <B>Comparación</B>: <PowerShellInline code="[string]::Equals(..., 'OrdinalIgnoreCase')" /> evita
                        cambios innecesarios por diferencias de mayúsculas/minúsculas en la URL.
                    </ListItem>

                    <ListItem icon={icons.MagicWand}>
                        <B>Acciones</B>: si no hay cambios → <I>none</I>; si difiere → <I>set-url</I>; si no existe → <I
                        >add</I>. Gracias a <I>ShouldProcess</I>, puedes simular con <Mono>-WhatIf</Mono>.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-new-git-project">
            <Heading
                headingLevel="h3" Icon={icons.Play}
                slot="heading"
            >
                Crear proyecto completo (remoto + local + remoto origin)
            </Heading>

            <p class="mb-3">
                Este script combina los pasos anteriores: crea el repositorio remoto, inicializa el repositorio local y
                asigna el remoto <Mono>origin</Mono>. Es idempotente de extremo a extremo y respeta <PowerShellInline
                    code="-WhatIf"
                />/<PowerShellInline code="-Confirm" />.
            </p>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.0
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidatePattern('^[a-zA-Z0-9._-]+$')]
                        [string] $Username,

                        [Parameter(Mandatory)]
                        [ValidatePattern('^[a-zA-Z0-9._-]+$')]
                        [string] $RepositoryName,

                        [ValidatePattern('^[a-zA-Z0-9._-]*$')]
                        [string] $Prefix = '',

                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $LiteralPath = '.',

                        [switch] $Public
                    )

                    $result = @{
                        NewRepository        = $null
                        InitializeRepository = $null
                        SetRemote            = $null
                    }

                    $newRepository = Join-Path $PSScriptRoot 'New-GitLabRepository.ps1' -Resolve
                    $initializeRepository = Join-Path $PSScriptRoot 'Initialize-Repository.ps1' -Resolve
                    $setRemote = Join-Path $PSScriptRoot 'Add-Remote.ps1' -Resolve

                    $forward = @{}
                    foreach ($k in 'WhatIf', 'Confirm') {
                        if ($PSBoundParameters.ContainsKey($k)) { $forward[$k] = $PSBoundParameters[$k] }
                    }

                    $normalized = (
                        $RepositoryName.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', '')

                    $repoSlug = if ([string]::IsNullOrEmpty($Prefix)) {
                        $normalized
                    }
                    else {
                        ($Prefix.Trim('-') + '-' + $normalized.Trim('-')).Trim('-')
                    }

                    $result.NewRepository = & $newRepository @forward -Name $repoSlug -Public:$Public
                    $remoteUrl = "git@gitlab.com:$Username/$repoSlug.git"
                    $result.InitializeRepository = & $initializeRepository @forward -LiteralPath $LiteralPath
                    $result.SetRemote = (
                        & $setRemote @forward -Path $LiteralPath -RemoteName 'origin' -RemoteUrl $remoteUrl)

                    [pscustomobject]$result
                `}
            >
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitProject.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.Share}>
                        <B>Propagación de <Mono>WhatIf</Mono>/<Mono>Confirm</Mono></B>: <PowerShellInline
                            code="$forward"
                        /> recoge las banderas <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" />
                        y las reenvía a los scripts internos con <PowerShellInline code="@forward" />, manteniendo la
                        simulación/confirmación en toda la orquestación.
                    </ListItem>

                    <ListItem icon={icons.Hash}>
                        <Mono>repoSlug</Mono>: a partir de <PowerShellInline code="$RepositoryName" /> se genera un <I
                        >slug</I> seguro para el remoto: minúsculas, espacios a guiones y filtrado a <Mono
                        >[a-z0-9-]</Mono>. Si hay <PowerShellInline code="$Prefix" />, se antepone (por ejemplo: <Mono
                        >dibs-scripts</Mono>).
                    </ListItem>

                    <ListItem icon={icons.GitlabLogo}>
                        <B>Remoto + local + origin</B>: el script primero asegura el remoto en GitLab, luego inicializa
                        el repositorio local (si hace falta), y finalmente establece <Mono>origin</Mono> a la URL SSH
                        <Mono>git@gitlab.com:&lt;user&gt;/&lt;slug&gt;.git</Mono>.
                    </ListItem>

                    <ListItem icon={icons.Eye}>
                        <B>Salida agregada</B>: se retorna un objeto con tres propiedades (<Mono>NewRepository</Mono>,
                        <Mono>InitializeRepository</Mono>, <Mono>SetRemote</Mono>) para inspeccionar el resultado de
                        cada paso por separado.
                    </ListItem>
                </List>
            </Explanation>

            <PowerShellBlock
                code={`
                    $params = @{
                        Username       = 'tu-usuario'   # <- reemplaza con tu usuario real de GitLab
                        RepositoryName = 'scripts'
                        Prefix         = 'dibs'
                        LiteralPath    = '.'            # carpeta actual como repo local
                        Public         = $true
                        Verbose        = $true
                        Confirm        = $true
                    }

                    $result = .\\git\\New-GitProject.ps1 @params

                    # Ver resultados individuales:
                    $result.NewRepository        | Format-List
                    $result.InitializeRepository | Format-List
                    $result.SetRemote            | Format-List
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/scripts</Mono></Fragment>
                <Fragment slot="footer">
                    Con <Mono>-WhatIf</Mono> el script describe lo que haría sin efectuar cambios; con <Mono
                    >-Confirm</Mono>
                    solicita confirmación paso a paso.
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitProject.ps1"
                />
            </PowerShellBlock>
        </NotesSection>

        <Question>
            <span slot="title">Ejercicio propuesto</span>

            <p>
                Modifica el script <Mono>Initialize-Project.ps1</Mono> para que llame a <Mono>New-GitProject.ps1</Mono>
                y cree el repositorio remoto en GitLab, inicialice el repo local (si procede) y configure el remoto
                <Mono>origin</Mono>. Mantén el comportamiento idempotente y respeta <Mono>-WhatIf</Mono>/<Mono
                >-Confirm</Mono>.
            </p>
        </Question>
    </NotesSection>

    <NotesSection id="h2-next-steps">
        <Heading
            headingLevel="h2" Icon={icons.Rocket}
            slot="heading"
        >
            Siguientes pasos
        </Heading>

        <p class="mb-3">
            Los scripts <B>no hacen commit ni push</B> para evitar cambios accidentales. La idea es que revises el
            estado del repo y confirmes conscientemente qué subirás. Además, conviene agregar un <Mono>.gitignore</Mono>
            antes de tu primer commit.
        </p>

        <PowerShellBlock
            code={`
                # 1) Revisa el estado y los archivos creados
                git status

                # 2) Crea un .gitignore recomendado para tu stack
                # Visita: https://www.toptal.com/developers/gitignore/
                # Copia el contenido y guárdalo como .gitignore en la raíz del proyecto

                # 3) Haz tu primer commit (cuando estés conforme)
                git add .
                git commit -m "init: estructura y configuración inicial"

                # 4) Publica en el remoto (rama main)
                git push origin main
            `}
        >
            <Fragment slot="title">Desde <Mono>dibs/scripts</Mono></Fragment>
            <span slot="footer">Publicar cambios manualmente</span>
        </PowerShellBlock>

        <Note>
            Si tu proyecto genera artefactos (por ejemplo, <Mono>bin/</Mono>, <Mono>obj/</Mono>, <Mono>dist/</Mono>,
            <Mono>node_modules/</Mono>, <Mono>*.env</Mono>), asegúrate de ignorarlos en <Mono>.gitignore</Mono> para
            evitar subir archivos innecesarios o sensibles.
        </Note>
    </NotesSection>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            En este laboratorio establecimos una base sólida para trabajar con GitLab desde la línea de comandos:
            normalizamos nombres de repos, creamos el remoto de forma idempotente con <B>glab</B>, inicializamos el
            repositorio local con rama <Mono>main</Mono> y configuramos <Mono>origin</Mono> sin duplicar estado.
            Orquestamos todo con un solo script que respeta <Mono>-WhatIf</Mono>/<Mono>-Confirm</Mono>, y cuidamos la
            compatibilidad de rutas usando
            <Mono>ProviderPath</Mono> cuando interactuamos con herramientas externas. El resultado es un flujo
            repetible, seguro y fácil de compartir con el equipo.
        </Fragment>

        <Fragment slot="key-points">
            <List>
                <ListItem icon={icons.Check}>
                    <B>Idempotencia</B>: los comandos pueden ejecutarse varias veces sin efectos secundarios (crear/no
                    crear, agregar/actualizar).
                </ListItem>
                <ListItem icon={icons.Check}>
                    <B>Determinismo y compatibilidad</B>: preferimos <Mono>ProviderPath</Mono> al invocar binarios
                    externos, y usamos <Mono>git -C</Mono> para no depender del directorio actual.
                </ListItem>
                <ListItem icon={icons.Check}>
                    <B>Control seguro</B>: <Mono>-WhatIf</Mono>/<Mono>-Confirm</Mono> permiten ensayar y confirmar
                    cambios; los scripts devuelven objetos para inspeccionar resultados.
                </ListItem>
                <ListItem icon={icons.Check}>
                    <B>Composición</B>: piezas pequeñas (crear remoto, inicializar, asignar <Mono>origin</Mono>) que se
                    combinan en un comando único.
                </ListItem>
                <ListItem icon={icons.Check}>
                    <B>Próximos pasos</B>: añadir <Mono>.gitignore</Mono>, primer <Mono>commit</Mono>/<Mono>push</Mono>
                    y preparar la base para CI/CD.
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="takeaways">
            Automatizar no es solo ahorrar tiempo: es diseñar <I>confianza operacional</I>. Al convertir acciones
            frágiles en comandos idempotentes —probables con <Mono>-WhatIf</Mono> y confirmables paso a paso— ganamos
            reproducibilidad y tranquilidad para iterar. Empieza por lo esencial, compón tareas pequeñas y prioriza
            claridad sobre “magia”. Este hábito se vuelve ventaja compuesta: menos sorpresas, más foco en el diseño de
            la biblioteca y un equipo que comparte el mismo lenguaje de trabajo.
        </Fragment>
    </ConclusionsLayout>

    <Footnotes>
        <Footnote index={1}>
            Una estrategia común para mitigar este problema es mantener un <B>mirror</B> del repositorio en GitHub (Git
            permite definir varios remotos). Sin embargo, esto puede complicar la gestión de <I>issues</I> o solicitudes
            de cambio (<I>merge requests</I> en GitLab, equivalentes a <I>pull requests</I> en GitHub), ya que habría
            que coordinar dos fuentes distintas de colaboración.
        </Footnote>
    </Footnotes>
</NotesLayout>
