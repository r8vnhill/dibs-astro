---
import * as icons from "~/assets/img/icons";
import { P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Explanation, Important, Info } from "~/components/ui/callouts";
import Question from "~/components/ui/callouts/Question.astro";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import Cons from "~/components/ui/procons/Cons.astro";
import ProCons from "~/components/ui/procons/ProCons.astro";
import Pros from "~/components/ui/procons/Pros.astro";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Laboratorio 1: GitLab — crear repos y remotos" description="...">
    <Abstract>
        <P>
            Este laboratorio es más largo y denso que los anteriores porque <B>condensa varias
                lecciones</B>: retomamos validaciones, salida tipada y herramientas de línea de
            comandos para aplicarlas en un flujo real de GitLab. La idea es practicar cómo se usan
            estos patrones juntos, no solo de forma aislada.
        </P>
        <P>
            Automatizaremos la creación de proyectos con la CLI <PowerShellInline code="glab" />,
            normalizaremos nombres válidos para GitLab, verificaremos repos locales y configuraremos
            remotos de manera idempotente. Cerraremos con un script orquestador que une todo el
            pipeline y te deja el repo listo para hacer commit y push manualmente, con soporte de
            <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" /> para ensayar
            sin riesgos.
        </P>
    </Abstract>

    <NotesSection id="h2-intro">
        <Heading
            headingLevel="h2" Icon={icons.GitlabLogo}
            slot="heading"
        >
            Por qué GitLab y qué aprenderemos
        </Heading>

        <P>
            En este curso trabajaremos con <B href="https://gitlab.com">GitLab</B>. Es probable que
            ya tengas familiaridad con GitHub, pero GitLab presenta un modelo distinto: integra
            repositorios, CI/CD y registro de paquetes en un mismo espacio. Esta integración es útil
            para practicar el flujo completo de creación y publicación de bibliotecas de software
            sin depender de múltiples servicios.
        </P>

        <P>
            Durante las unidades veremos cómo usar GitLab para <B>crear, versionar y publicar</B>
            bibliotecas. Más adelante aprovecharemos su <I>Package Registry</I> para distribuir
            nuestras bibliotecas, aunque en este curso nos concentraremos en la <B>orquestación
                local</B> (scripts, Gradle) y no llegaremos a implementar integración continua en
            GitLab.
        </P>

        <ProCons>
            <Pros title="Qué ganamos">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>CI/CD integrado</B>: GitLab incorpora su sistema de integración continua
                        (<I>GitLab CI/CD</I>) dentro del propio repositorio. El modelo es similar a
                        <I>GitHub Actions</I>, pero en GitLab forma parte nativa del proyecto y
                        suele requerir menos servicios externos. En este curso no trabajaremos con
                        GitLab CI/CD, pero el modelo es útil para contexto futuro.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Registro de paquetes en el mismo entorno</B>: permite publicar y consumir
                        artefactos (bibliotecas, contenedores, etc.) sin salir de la plataforma. En
                        GitHub esto existe como <I>GitHub Packages</I>, aunque opera como un
                        servicio separado.
                    </ListItem>

                    <ListItem icon={icons.Lock}>
                        <B>Opciones autogestionadas</B>: muchas organizaciones utilizan GitLab en
                        servidores propios, lo que facilita cumplir requisitos internos de
                        seguridad. GitHub también ofrece una variante empresarial (pagada), pero con
                        un modelo diferente de distribución.
                    </ListItem>

                    <ListItem icon={icons.Users}>
                        <B>Modelo de grupos y permisos detallado</B>: GitLab organiza repositorios
                        en grupos y subgrupos, lo que facilita estructurar proyectos relacionados.
                        GitHub ofrece organizaciones, pero con un modelo distinto de jerarquía.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>CLI oficial</B> mediante <PowerShellInline code="glab" />: permite crear
                        y gestionar proyectos desde la terminal. GitHub cuenta con <PowerShellInline
                            code="gh"
                        />, con un alcance comparable.
                    </ListItem>
                </List>
            </Pros>

            <Cons title="En qué topamos...">
                <List>
                    <ListItem icon={icons.CloudSlash}>
                        <B>Menor visibilidad pública</B>: GitHub sigue siendo el espacio
                        predominante para proyectos abiertos, por lo que los repositorios alojados
                        en GitLab suelen tener menos exposición inicial.
                        <FootnoteRef index={1} />
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <B>Flujos de CI/CD más detallados</B>: la configuración de integración
                        continua ofrece bastante control, pero esto también implica una mayor
                        cantidad de opciones al comienzo si vienes desde GitHub. Aunque no veremos
                        GitLab CI/CD en este curso, es útil tenerlo presente para proyectos futuros.
                    </ListItem>

                    <ListItem icon={icons.Database}>
                        <B>Restricciones en la nube gratuita</B>: GitLab Cloud incluye límites de
                        almacenamiento y de minutos de CI que pueden sentirse más estrictos que los
                        de GitHub en su capa gratuita.
                    </ListItem>

                    <ListItem icon={icons.Student}>
                        <B>Sin equivalente directo a GitHub Classroom</B>: GitLab no incluye un
                        sistema integrado para gestionar entregas de estudiantes. Se pueden
                        construir alternativas, pero requieren más trabajo manual.
                    </ListItem>
                </List>
            </Cons>
        </ProCons>

        <P>
            En esta primera parte aprenderemos a:
            <List>
                <ListItem icon={icons.FolderPlus}>
                    Crear repositorios remotos automáticamente.
                </ListItem>
                <ListItem icon={icons.FolderOpen}>
                    Inicializar proyectos locales y enlazarlos con su remoto.
                </ListItem>
                <ListItem icon={icons.Play}>
                    Automatizar ambos pasos con un script para agilizar el flujo.
                </ListItem>
            </List>
        </P>
    </NotesSection>

    <NotesSection id="scripts">
        <Heading
            headingLevel="h2" Icon={icons.Terminal}
            slot="heading"
        >
            Scripts del laboratorio
        </Heading>

        <Important>
            <span slot="title">Requisitos previos</span>

            <P>
                Antes de comenzar, asegúrate de haber iniciado sesión en GitLab desde la línea de
                comandos con:
            </P>

            <PowerShellBlock code={`glab auth login`}>
                <span slot="title">Desde la terminal</span>
                <span slot="footer">Iniciar sesión en GitLab CLI</span>
            </PowerShellBlock>
        </Important>

        <P>
            Todos los scripts son idempotentes: puedes ejecutarlos varias veces sin generar
            duplicados ni inconsistencias.
        </P>

        <NotesSection id="h3-test-git-repository">
            <Heading
                headingLevel="h3" Icon={icons.MagnifyingGlass}
                slot="heading"
            >
                Probar si una carpeta es un repositorio Git
            </Heading>

            <P>
                Antes de crear un remoto o asignar <Mono>origin</Mono>, conviene verificar si la
                carpeta indicada <I>ya es</I> un repositorio Git. Este script actúa como <B
                >comprobación preliminar idempotente</B>: nunca modifica la carpeta; únicamente
                inspecciona su estado usando Git de forma segura. Así evitamos intentar leer o
                configurar remotos donde todavía no existe <Mono>.git/</Mono>, y podemos decidir
                condicionalmente qué otros scripts ejecutar.
            </P>

            <P>
                La lógica retorna un objeto con <Mono>Status</Mono> (<Mono>IsRepository</Mono> o
                <Mono>NotRepository</Mono>) y posible <Mono>Error</Mono>. Usa <PowerShellInline
                    code="git -C <ruta> rev-parse --is-inside-work-tree"
                />
                para comprobar sin cambiar el directorio actual y captura excepciones, devolviendo
                un resultado estable sin romper la orquestación de scripts mayores.
            </P>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding()]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $Path
                    )

                    Set-StrictMode -Version 3.0

                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    $result = [PSCustomObject]@{
                        Status = 'Pending'
                        Error  = $null
                    }

                    try {
                        $repoPath = (Resolve-Path -LiteralPath $Path -ErrorAction Stop).ProviderPath
                        & $invoker git -C $repoPath rev-parse --is-inside-work-tree | Out-Null
                        $result.Status = 'IsRepository'
                    }
                    catch {
                        $result.Status = 'NotRepository'
                        $result.Error = $_
                    }

                    $result
                `}
            >
                <Fragment slot="title">Test-GitRepository.ps1</Fragment>
                <span slot="footer">
                    Devuelve objeto con <Mono>Status</Mono>: <Mono>IsRepository</Mono> o <Mono
                    >NotRepository</Mono>.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Test-GitRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Terminal}>
                        <B>Chequeo nativo</B>: <PowerShellInline
                            code="git -C <ruta> rev-parse --is-inside-work-tree"
                        /> verifica el estado sin cambiar el directorio actual. Desglose del
                        comando:
                        <List>
                            <ListItem icon={icons.TextT}>
                                <PowerShellInline code={`git`} />: el ejecutable de Git que invoca
                                los subcomandos.
                            </ListItem>

                            <ListItem icon={icons.Path}>
                                <PowerShellInline code={`-C <ruta>`} />: indica a Git que ejecute el
                                subcomando desde la carpeta especificada sin cambiar el directorio
                                del proceso actual.
                            </ListItem>

                            <ListItem icon={icons.Terminal}>
                                <PowerShellInline code={`rev-parse`} />: subcomando de Git usado
                                para obtener/parsear información interna y valores de configuración.
                            </ListItem>

                            <ListItem icon={icons.Check}>
                                <PowerShellInline code={`--is-inside-work-tree`} />: opción que hace
                                que <PowerShellInline code={`rev-parse`} /> devuelva "true" (por
                                stdout) y <I>ExitCode</I> 0 cuando la ruta está dentro de un work
                                tree; si no, el <I>ExitCode</I> será distinto de 0.
                            </ListItem>
                        </List>
                    </ListItem>
                    <ListItem icon={icons.Eye}>
                        <B>Resolución física</B>: <PowerShellInline
                            code="Resolve-Path -LiteralPath"
                        /> obtiene <Mono>ProviderPath</Mono> para evitar ambigüedades y fallar
                        temprano si la ruta es inválida.
                    </ListItem>

                    <ListItem icon={icons.MagicWand}>
                        <B>Manejo de errores</B>: cualquier excepción asigna <Mono>Status =
                            'NotRepository'</Mono> y preserva el detalle en <Mono>Error</Mono> para
                        inspección posterior sin detener otros scripts.
                    </ListItem>

                    <ListItem icon={icons.Info}>
                        <B>Salida estructurada</B>: retornar un objeto facilita componer condiciones
                        (<PowerShellInline code="if ($result.Status -eq 'IsRepository')" />) y
                        serializar resultados.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-convert-to-valid-gitlab-name">
            <Heading
                headingLevel="h3" Icon={icons.Hash}
                slot="heading"
            >
                Normalizar nombres para GitLab
            </Heading>

            <P>
                GitLab exige nombres de repositorio en minúsculas, sin espacios ni caracteres
                especiales (solo <Mono>[a-z0-9-]</Mono>). Este pequeño filtro convierte cualquier
                entrada —por ejemplo, <Mono>"R.E.M."</Mono>— en un <I>slug</I> válido como <Mono
                >"rem"</Mono>, y fallando en strings que no pueda convertir como <Mono
                >"菊池ひみこ"</Mono>. Lo usamos antes de crear el remoto para evitar errores de
                sintaxis y mantener nombres legibles y predecibles.
            </P>

            <PowerShellBlock
                code={`
                #Requires -Version 7.5
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Name
                )

                Set-StrictMode -Version 3.0

                $normalized = $Name.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', ''
                if ([string]::IsNullOrWhiteSpace($normalized)) {
                    throw [System.ArgumentException]::new(
                        "Name '$Name' is not valid after normalizing to '$normalized' (only [a-z0-9-])."
                    )
                }

                $normalized
            `}
            >
                <Fragment slot="title">ConvertTo-ValidGitLabName.ps1</Fragment>
                <Fragment slot="footer">
                    Retorna el nombre normalizado o lanza excepción si el resultado está vacío.
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/ConvertTo-ValidGitLabName.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.TextT}>
                        <B>Minúsculas invariantes</B>: <PowerShellInline
                            code=".ToLowerInvariant()"
                        /> convierte sin depender de la cultura local (evita casos como "I/İ" en
                        turco).
                    </ListItem>

                    <ListItem icon={icons.Eraser}>
                        <B>Limpieza de caracteres</B>: <PowerShellInline
                            code="-replace '\\s+', '-'"
                        /> cambia espacios por guiones; <PowerShellInline
                            code="-replace '[^a-z0-9-]', ''"
                        /> elimina todo lo que no sea alfanumérico o guion.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-new-gitlab-repo-status">
            <Heading
                headingLevel="h3" Icon={icons.GitBranch}
                slot="heading"
            >
                Crear repo remoto en GitLab
            </Heading>

            <P>
                Este script crea un repositorio remoto de forma <B>idempotente</B>: primero consulta
                si existe y, solo si no existe, intenta crearlo. Devuelve un objeto con
                <PowerShellInline code={`Name`} />, <PowerShellInline code={`Visibility`} /> y
                <PowerShellInline code={`Status { Created; Reason }`} />. Aquí <PowerShellInline
                    code={`Reason`}
                /> aprovecha la naturaleza dinámica de PowerShell: puede ser un texto, el resultado
                devuelto por <PowerShellInline code={`glab`} /> o un <I>ErrorRecord</I> si algo
                falla.
            </P>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Name,

                        [switch] $Public
                    )

                    Set-StrictMode -Version 3.0

                    $normalized = & (Join-Path $PSScriptRoot 'ConvertTo-ValidGitLabName.ps1') -Name $Name
                    $visibility = if ($Public.IsPresent) { 'public' } else { 'private' }
                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    $repository = [PSCustomObject]@{
                        Name       = $normalized
                        Visibility = $visibility
                        Status     = [PSCustomObject]@{
                            Created = $false
                            Reason  = ''
                        }
                    }

                    try {
                        & $invoker glab repo view $repository.Name | Out-Null
                        $repository.Status.Reason = '{0} already exists on GitLab.' -f $repository.Name
                    }
                    catch {
                        if ($PSCmdlet.ShouldProcess($normalized, "Create GitLab repository ($visibility)")) {
                            try {
                                $args = @('repo', 'create', $normalized, '--defaultBranch', 'main')
                                if ($Public) { $args += '--public' } else { $args += '--private' }

                                $result = & $invoker glab $args
                                $repository.Status.Created = $true
                                $repository.Status.Reason = $result
                            }
                            catch {
                                $repository.Status.Reason = $_
                            }
                        }
                        else {
                            $repository.Status.Reason = 'Creation cancelled by user.'
                        }
                    }

                    $repository
                `}
            >
                <span slot="title">New-GitLabRepository.ps1</span>
                <span slot="footer">
                    Devuelve objeto con <Mono>Status.Created</Mono> y <Mono>Status.Reason</Mono>
                    (texto, salida de <Mono>glab</Mono> o <I>ErrorRecord</I>), más
                    <Mono>Name</Mono>/<Mono>Visibility</Mono>.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitLabRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.MagnifyingGlass}>
                        <B>Idempotencia</B>: primero intenta <PowerShellInline
                            code="glab repo view"
                        />; si existe, solo informa; si no, procede a crear.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>glab repo view</B>: ejecuta <PowerShellInline
                            code="glab repo view $repository.Name"
                        /> solo para comprobar si el proyecto ya existe en GitLab. Si el comando
                        termina correctamente, asumimos que el repo está creado y solo rellenamos
                        <Mono>Status.Reason</Mono>; si lanza error, caemos en el <PowerShellInline
                            code="catch"
                        /> y pasamos a la lógica de creación.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>glab repo create</B>: construye el array <PowerShellInline
                            code="$args"
                        /> como <PowerShellInline
                            code="repo create $normalized --defaultBranch main"
                        />, añadiendo <PowerShellInline code="--public" /> o <PowerShellInline
                            code="--private"
                        /> según el parámetro <Mono>-Public</Mono>. <Mono>--defaultBranch
                            main</Mono> fija el nombre de la rama principal y los flags <Mono
                        >--public</Mono>/<Mono>--private</Mono> controlan la visibilidad del
                        proyecto en GitLab.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Salida rica</B>: <Mono>Status.Reason</Mono> puede ser texto, la salida de
                        <Mono>glab</Mono> o un <I>ErrorRecord</I>; útil para inspección y logs.
                    </ListItem>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>Confirmación opcional</B>: usa <I>ShouldProcess</I> para soportar <Mono
                        >-WhatIf</Mono>/<Mono>-Confirm</Mono>.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-set-gitlab-remote">
            <Heading
                headingLevel="h3" Icon={icons.Link}
                slot="heading"
            >
                Asignar remoto GitLab a un repo existente
            </Heading>

            <P>
                Este script conecta un repositorio local ya inicializado con un remoto en GitLab:
                valida que la ruta sea un repo Git, genera la URL a partir del usuario y el nombre
                normalizado, y luego crea o actualiza el remoto (por defecto <Mono>origin</Mono>) de
                forma <B>idempotente</B>. Devuelve un objeto con la acción realizada y la razón,
                útil para inspección y logs.
            </P>

            <PowerShellBlock
                code={`
                #Requires -Version 7.5
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                    [string] $Path,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $User,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Name,

                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Remote = 'origin'
                )

                Set-StrictMode -Version 3.0

                $testRepo = Join-Path $PSScriptRoot 'Test-GitRepository.ps1' -Resolve
                $convertName = Join-Path $PSScriptRoot 'ConvertTo-ValidGitLabName.ps1' -Resolve
                $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                if ((& $testRepo -Path $Path).Status -ne 'IsRepository') {
                    throw [System.InvalidOperationException]::new(
                        "Path '$Path' is not a valid Git repository."
                    )
                }

                $repoPath = (Resolve-Path -LiteralPath $Path -ErrorAction Stop).ProviderPath
                $remoteUrl = 'https://gitlab.com/{0}/{1}.git' -f $User, (& $convertName -Name $Name)

                $result = [PSCustomObject]@{
                    Path       = $repoPath
                    RemoteName = $Remote
                    RemoteUrl  = $remoteUrl
                    Action     = 'None'
                    Reason     = ''
                }

                $target = '{0} remote {1} -> {2}' -f $repoPath, $Remote, $remoteUrl
                if (!$PSCmdlet.ShouldProcess($target, 'Set Git remote')) {
                    $result.Action = 'Skipped'
                    $result.Reason = 'Operation cancelled by user.'
                }
                else {
                    try {
                        try {
                            & $invoker git -C $repoPath remote get-url $Remote | Out-Null
                            & $invoker git -C $repoPath remote set-url $Remote $remoteUrl | Out-Null
                            $result.Action = 'Updated'
                            $result.Reason = "Remote '$Remote' URL updated."
                        }
                        catch {
                            & $invoker git -C $repoPath remote add $Remote $remoteUrl | Out-Null
                            $result.Action = 'Added'
                            $result.Reason = "Remote '$Remote' created."
                        }
                    }
                    catch {
                        $result.Action = 'Failed'
                        $result.Reason = $_
                    }
                }

                $result
            `}
            >
                <span slot="title">Set-GitLabRemote.ps1</span>
                <span slot="footer">
                    Configura el remoto de un repositorio local hacia GitLab (por defecto <Mono
                    >origin</Mono>) y devuelve qué acción se ejecutó (<Mono>Added</Mono>, <Mono
                    >Updated</Mono>, <Mono>Skipped</Mono>, <Mono>Failed</Mono>).
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Set-GitRemote.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Eye}>
                        <B>Verificación del repo</B>: usa <PowerShellInline
                            code="Test-GitRepository.ps1"
                        /> para asegurarse de que <Mono>$Path</Mono> apunta a un repositorio Git
                        válido antes de tocar remotos; si no, lanza una <I
                        >InvalidOperationException</I>
                        con un mensaje claro.
                    </ListItem>

                    <ListItem icon={icons.Hash}>
                        <B>Nombre normalizado</B>: delega en <PowerShellInline
                            code="ConvertTo-ValidGitLabName.ps1"
                        /> la generación del <I>slug</I> del proyecto y construye la URL como
                        <Mono>https://gitlab.com/&lt;user&gt;/&lt;slug&gt;.git</Mono>.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Idempotencia del remoto</B>: primero intenta <PowerShellInline
                            code="git -C $repoPath remote get-url $Remote"
                        />; si el remoto existe, ejecuta <PowerShellInline
                            code="git -C $repoPath remote set-url $Remote $remoteUrl"
                        />, y si falla (por ejemplo, porque el remoto no existe) cae en el <I
                        >catch</I> interno y usa <PowerShellInline
                            code="git -C $repoPath remote add $Remote $remoteUrl"
                        />.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-publish-git-repository">
            <Heading
                headingLevel="h3" Icon={icons.Play}
                slot="heading"
            >
                Orquestar creación de repo y remoto
            </Heading>

            <P>
                Para cerrar el flujo, este script actúa como <B>orquestador</B>: crea (si hace
                falta) el repositorio remoto en GitLab y a continuación configura el remoto en el
                repositorio local apuntando a ese proyecto. Reutiliza los scripts anteriores,
                respeta <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" />
                y devuelve un objeto con el detalle de cada paso.
            </P>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $Path,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $User,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Name,

                        [switch] $Public,

                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Remote = 'origin'
                    )

                    Set-StrictMode -Version 3.0

                    $createGitLabRepo = Join-Path $PSScriptRoot 'New-GitLabRepository.ps1' -Resolve
                    $setGitRemote = Join-Path $PSScriptRoot 'Set-GitRemote.ps1' -Resolve

                    $forwardBoundParams = @{}
                    if ($PSBoundParameters.ContainsKey('WhatIf')) {
                        $forwardBoundParams['WhatIf'] = $PSBoundParameters['WhatIf']
                    }
                    if ($PSBoundParameters.ContainsKey('Confirm')) {
                        $forwardBoundParams['Confirm'] = $PSBoundParameters['Confirm']
                    }

                    $gitLab = & $createGitLabRepo -Name $Name -Public:$Public @forwardBoundParams

                    $remoteParams = @{}
                    $remoteParams += $forwardBoundParams
                    $remoteParams += @{ Path = $Path; User = $User; Name = $Name; Remote = $Remote }

                    $remoteResult = & $setGitRemote @remoteParams

                    [PSCustomObject]@{
                        Path   = $Path
                        GitLab = $gitLab
                        Remote = $remoteResult
                    }
                `}
            >
                <Fragment slot="title">Publish-GitRepository.ps1</Fragment>
                <span slot="footer">
                    Orquesta la creación del repositorio remoto en GitLab y la configuración del
                    remoto local, devolviendo un objeto con el resultado de ambos pasos.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Publish-GitRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>Propaga <Mono>-WhatIf</Mono>/<Mono>-Confirm</Mono></B>: construye
                        <Mono>$forwardBoundParams</Mono> a partir de <Mono>$PSBoundParameters</Mono>
                        y lo pasa a ambos scripts, asegurando que los ensayos y confirmaciones se
                        respeten de extremo a extremo.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Salida estructurada</B>: retorna un objeto con <Mono>Path</Mono>, más los
                        resultados completos de <Mono>GitLab</Mono> y <Mono>Remote</Mono>. Esto
                        permite inspeccionar qué ocurrió en cada etapa o registrar el resultado en
                        logs sin necesidad de parsear texto.
                    </ListItem>
                </List>
            </Explanation>

            <Info>
                <span slot="title">Ejemplo de uso</span>

                <PowerShellBlock
                    code={`
                        git init # Si aún no es un repo Git
                        $params = @{
                            User = 'tu-usuario' # Reemplaza con tu nombre de usuario de GitLab
                            Path = '.'
                            Name = (Get-Item -Path '.').Name
                        }
                        $result = ./git/Publish-GitRepository.ps1 @params -WhatIf
                    `}
                >
                    <span slot="title">Desde <Mono>dibs/scripts</Mono></span>
                </PowerShellBlock>

                <P>
                    Revisa <Mono>$result</Mono> para verificar que todo está en orden, luego ejecuta
                    sin <Mono>-WhatIf</Mono> para crear el repo y asignar el remoto. Usa <Mono
                    >-Confirm</Mono> para aprobar cada paso si prefieres mayor control.
                </P>
            </Info>

            <Question headingLevel="h4">
                <span slot="title">Verificar</span>

                <PowerShellBlock
                    code={`
                        # Revisar resultado
                        $result.GitLab.Status    # Created y Reason
                        $result.Remote.Action    # Added/Updated/Skipped/Failed

                        # Confirmar con Git
                        git remote -v
                    `}
                >
                    <span slot="title">Inspeccionar resultado</span>
                </PowerShellBlock>
            </Question>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-next-steps">
        <Heading
            headingLevel="h2" Icon={icons.Rocket}
            slot="heading"
        >
            Siguientes pasos
        </Heading>

        <P>
            Los scripts <B>no hacen commit ni push</B> para evitar cambios accidentales. La idea es
            que revises el estado del repo y confirmes conscientemente qué subirás. Además, conviene
            agregar un <Mono>.gitignore</Mono> antes de tu primer commit.
        </P>

        <PowerShellBlock
            code={`
                # Revisa estado y agrega .gitignore
                git status
                # Visita https://www.toptal.com/developers/gitignore/ para generar .gitignore

                # Primer commit y push
                git add .
                git commit -m "init: estructura y configuración inicial"
                git push origin main
            `}
        >
            <Fragment slot="title">Desde <Mono>dibs/scripts</Mono></Fragment>
            <span slot="footer">Publicar cambios manualmente</span>
        </PowerShellBlock>

        <Important>
            Si tu proyecto genera artefactos (por ejemplo, <Mono>bin/</Mono>, <Mono>obj/</Mono>,
            <Mono>dist/</Mono>, <Mono>node_modules/</Mono>, <Mono>*.env</Mono>), asegúrate de
            ignorarlos en <Mono>.gitignore</Mono> para evitar subir archivos innecesarios o
            sensibles.
        </Important>
    </NotesSection>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            <P>
                Conectamos todo lo aprendido sobre validaciones, salida tipada y <I>CLI</I> en un
                flujo completo de GitLab. Pasamos de comprobar si una carpeta es repo, a crear el
                proyecto remoto con <PowerShellInline code="glab" />, normalizar nombres y fijar el
                remoto de forma idempotente. El resultado es un set de scripts que puedes ejecutar
                sin miedo a duplicar recursos ni romper el estado local.
            </P>
            <P>
                La estructura orientada a objetos de salida y el soporte de <PowerShellInline
                    code="-WhatIf"
                />/<PowerShellInline code="-Confirm" /> dejan claro qué ocurrió en cada paso y te
                permiten ensayar antes de afectar el entorno. Esa transparencia hace que automatizar
                GitLab sea tan confiable como ejecutarlo todo a mano, pero con menos fricción.
            </P>
        </Fragment>

        <Fragment slot="key-points">
            <ListItem icon={icons.Terminal}>
                <B>Flujo completo automatizado:</B> desde <PowerShellInline code="glab repo view" />
                para detectar existentes hasta <PowerShellInline code="repo create" /> y la
                configuración del remoto con <Mono>git remote</Mono>, todo se ensambla sin pasos
                repetitivos.
            </ListItem>
            <ListItem icon={icons.Hash}>
                <B>Normalización y validaciones:</B> transformar nombres a <Mono>[a-z0-9-]</Mono> y
                verificar rutas antes de operar evita errores de sintaxis o rutas mal apuntadas.
            </ListItem>
            <ListItem icon={icons.ShieldCheck}>
                <B>Idempotencia y seguridad:</B> los scripts no sobreescriben sin revisar, exponen
                objetos con estado (<Mono>Status</Mono>/<Mono>Reason</Mono>) y soportan
                <Mono>-WhatIf</Mono>/<Mono>-Confirm</Mono> para probar sin riesgos.
            </ListItem>
            <ListItem icon={icons.GitBranch}>
                <B>Salida estructurada:</B> devolver objetos facilita registrar, auditar y encadenar
                resultados en orquestaciones mayores sin parsear texto.
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            <P>
                Automatizar GitLab con scripts idempotentes demuestra que podemos cuidar el estado
                del repositorio sin perder control: cada paso se documenta en la salida y puede
                ensayarse antes de ejecutarse. Esa disciplina es la base para flujos más complejos,
                ya sea en equipo o en proyectos personales.
            </P>
            <P>
                La clave no es solo crear repos rápido, sino diseñar automatizaciones que sean
                legibles, seguras y fáciles de adaptar. Con estos patrones en marcha, el siguiente
                paso es iterarlos en tus propios proyectos y ajustar el equilibrio entre rapidez y
                confianza.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <Footnotes>
        <Footnote index={1}>
            Una estrategia común para mitigar este problema es mantener un <B>mirror</B> del
            repositorio en GitHub (Git permite definir varios remotos). Sin embargo, esto puede
            complicar la gestión de <I>issues</I> o solicitudes de cambio (<I>merge requests</I> en
            GitLab, equivalentes a <I>pull requests</I> en GitHub), ya que habría que coordinar dos
            fuentes distintas de colaboración.
        </Footnote>
    </Footnotes>
</NotesLayout>
