---
import * as icons from "~/assets/img/icons";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Explanation, Important, Info, Note, Warning } from "~/components/ui/callouts";
import Question from "~/components/ui/callouts/Question.astro";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import Cons from "~/components/ui/procons/Cons.astro";
import ProCons from "~/components/ui/procons/ProCons.astro";
import Pros from "~/components/ui/procons/Pros.astro";
import { References, WebPage } from "~/components/ui/references";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Laboratorio 1: GitLab — crear repos y remotos" description="...">
    <ToDo
        client:only="react"
        metadata={{
            tasks: [
                "- [ ] Descripción para SE",
            ],
        }}
    />
    <Abstract>
        <P>
            Este laboratorio condensa varias lecciones en un flujo real: retomamos validaciones,
            salida tipada y herramientas de línea de comandos, y las combinamos en un proceso que
            puedes ejecutar de principio a fin sin pasos repetitivos.
        </P>
        <P>
            El hilo conductor es aprender a diseñar scripts como herramientas: <B>componibles</B>,
            <B>predecibles</B> y <B>fáciles de inspeccionar</B>. Verás contratos explícitos, salida
            estructurada e idempotencia con <PowerShellInline code="-WhatIf" />/<PowerShellInline
                code="-Confirm"
            />; al final tendrás un "flujo de automatización" de PowerShell listo para automatizar
            tareas similares en otros proyectos.
        </P>
    </Abstract>

    <NotesSection id="h2-intro">
        <Heading
            headingLevel="h2" Icon={icons.GitlabLogo}
            slot="heading"
        >
            Por qué GitLab y qué aprenderemos
        </Heading>

        <P>
            En este curso trabajaremos con <B href="https://gitlab.com">GitLab</B>. Es probable que
            ya tengas familiaridad con GitHub, pero GitLab propone un modelo distinto: integra
            repositorios, CI/CD y registro de paquetes en un mismo espacio. Esta visión integrada
            resulta especialmente útil para practicar el flujo completo de creación y publicación de
            bibliotecas de software sin depender de múltiples servicios externos.
        </P>

        <P>
            A lo largo de las unidades veremos cómo usar GitLab para <B>crear, versionar y
                publicar</B>
            bibliotecas. Más adelante aprovecharemos su <I>Package Registry</I> como mecanismo de
            distribución, aunque el foco del curso estará en la <B>orquestación local</B>
            (scripts, Gradle) y en comprender el proceso de construcción y publicación, sin llegar a
            implementar integración continua en GitLab.
        </P>

        <ProCons>
            <Pros title="Qué ganamos">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>CI/CD integrado</B>: GitLab incorpora su sistema de integración continua
                        (<I>GitLab CI/CD</I>) como parte nativa del proyecto. El modelo es similar a
                        <I>GitHub Actions</I>, pero con menos dependencia de servicios externos.
                        Aunque en este curso no lo utilizaremos, es útil como referencia para flujos
                        completos de publicación.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Registro de paquetes en el mismo entorno</B>: permite publicar y consumir
                        artefactos (bibliotecas, contenedores, etc.) sin salir de la plataforma. En
                        GitHub existe <I>GitHub Packages</I>, pero como un servicio más desacoplado.
                    </ListItem>

                    <ListItem icon={icons.Lock}>
                        <B>Opciones autogestionadas</B>: muchas organizaciones utilizan GitLab en
                        servidores propios, lo que facilita cumplir requisitos internos de
                        seguridad. GitHub también ofrece una variante empresarial (pagada), pero con
                        un modelo diferente de distribución.
                    </ListItem>

                    <ListItem icon={icons.Users}>
                        <B>Modelo de grupos y permisos detallado</B>: GitLab organiza repositorios
                        en grupos y subgrupos, lo que facilita estructurar proyectos relacionados.
                        GitHub ofrece organizaciones, pero con un modelo distinto de jerarquía.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>CLI oficial</B> mediante <PowerShellInline code="glab" />: permite crear
                        y gestionar proyectos desde la terminal. GitHub cuenta con <PowerShellInline
                            code="gh"
                        />, con un alcance comparable.
                    </ListItem>
                </List>
            </Pros>

            <Cons title="En qué topamos...">
                <List>
                    <ListItem icon={icons.CloudSlash}>
                        <B>Menor visibilidad pública</B>: GitHub sigue siendo el principal punto de
                        encuentro para proyectos abiertos, por lo que bibliotecas alojadas en GitLab
                        suelen tener menos exposición inicial.
                        <FootnoteRef index={1} />
                    </ListItem>

                    <ListItem icon={icons.Wrench}>
                        <B>Configuración más detallada en CI/CD</B>: GitLab ofrece un alto nivel de
                        control, lo que puede resultar más verboso al inicio si vienes desde GitHub.
                        No es un problema en este curso, pero sí un factor a considerar en proyectos
                        futuros.
                    </ListItem>

                    <ListItem icon={icons.Database}>
                        <B>Restricciones en la nube gratuita</B>: GitLab Cloud incluye límites de
                        almacenamiento y de minutos de CI que pueden sentirse más estrictos que los
                        de GitHub en su capa gratuita.
                    </ListItem>

                    <ListItem icon={icons.Student}>
                        <B>Sin equivalente directo a GitHub Classroom</B>: GitLab no incluye un
                        sistema integrado para gestionar entregas de estudiantes. Se pueden
                        construir alternativas, pero requieren más trabajo manual.
                    </ListItem>
                </List>
            </Cons>
        </ProCons>

        <P>
            En esta primera parte aprenderemos a:
            <List>
                <ListItem icon={icons.FolderPlus}>
                    Crear repositorios remotos automáticamente.
                </ListItem>
                <ListItem icon={icons.FolderOpen}>
                    Inicializar proyectos locales y enlazarlos con su remoto.
                </ListItem>
                <ListItem icon={icons.Play}>
                    Automatizar ambos pasos con un script para agilizar el flujo.
                </ListItem>
            </List>
        </P>
    </NotesSection>

    <NotesSection id="scripts">
        <Heading
            headingLevel="h2" Icon={icons.Terminal}
            slot="heading"
        >
            Scripts del laboratorio
        </Heading>

        <Important>
            <span slot="title">Requisitos previos</span>

            <P>
                Antes de comenzar, asegúrate de haber iniciado sesión en GitLab desde la línea de
                comandos con:
            </P>

            <PowerShellBlock code={`glab auth login`}>
                <span slot="title">Desde la terminal</span>
                <span slot="footer">Iniciar sesión en GitLab CLI</span>
            </PowerShellBlock>
        </Important>

        <P>
            Todos los scripts son idempotentes: puedes ejecutarlos varias veces sin generar
            duplicados ni inconsistencias.
        </P>

        <NotesSection id="h3-test-git-repository">
            <Heading
                headingLevel="h3" Icon={icons.MagnifyingGlass}
                slot="heading"
            >
                Probar si una carpeta es un repositorio Git
            </Heading>

            <P>
                Antes de crear un remoto o asignar <Mono>origin</Mono>, conviene verificar si la
                carpeta indicada <I>ya es</I> un repositorio Git.
            </P>

            <P>
                Este script actúa como <B>comprobación preliminar idempotente</B>: no modifica la
                carpeta; únicamente inspecciona su estado usando Git de forma segura. Así evitamos
                intentar leer o configurar remotos donde todavía no existe <Mono>.git/</Mono>, y
                podemos decidir condicionalmente qué otros scripts ejecutar.
            </P>

            <Info headingLevel="h4">
                <B slot="title">Contrato</B>

                Dada una ruta válida, siempre devuelve un objeto que indica si es o no un
                repositorio Git.
            </Info>

            <P>
                La lógica usa <PowerShellInline
                    code="git -C <ruta> rev-parse --is-inside-work-tree"
                />
                para comprobar sin cambiar el directorio actual. Captura excepciones y devuelve un
                resultado estable, sin romper la orquestación de scripts mayores.
            </P>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding()]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $Path
                    )

                    Set-StrictMode -Version 3.0

                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    $result = [PSCustomObject]@{
                        Status = 'Pending'
                        Error  = $null
                    }

                    # [!code focus:9]
                    try {
                        $repoPath = (Resolve-Path -LiteralPath $Path -ErrorAction Stop).ProviderPath
                        & $invoker git -C $repoPath rev-parse --is-inside-work-tree | Out-Null
                        $result.Status = 'IsRepository'
                    }
                    catch {
                        $result.Status = 'NotRepository'
                        $result.Error = $_
                    }

                    $result
                `}
            >
                <Fragment slot="title">Test-GitRepository.ps1</Fragment>
                <span slot="footer">
                    Devuelve objeto con <Mono>Status</Mono>: <Mono>IsRepository</Mono> o <Mono
                    >NotRepository</Mono>.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Test-GitRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Terminal}>
                        <B>Chequeo nativo</B>: <PowerShellInline
                            code="git -C <ruta> rev-parse --is-inside-work-tree"
                        /> verifica el estado sin cambiar el directorio actual. Desglose del
                        comando:
                        <List>
                            <ListItem icon={icons.TextT}>
                                <PowerShellInline code={`git`} />: el ejecutable de Git que invoca
                                los subcomandos.
                            </ListItem>

                            <ListItem icon={icons.Path}>
                                <PowerShellInline code={`-C <ruta>`} />: indica a Git que ejecute el
                                subcomando desde la carpeta especificada sin cambiar el directorio
                                del proceso actual.
                            </ListItem>

                            <ListItem icon={icons.Terminal}>
                                <PowerShellInline code={`rev-parse`} />: subcomando de Git usado
                                para obtener/parsear información interna y valores de configuración.
                            </ListItem>

                            <ListItem icon={icons.Check}>
                                <PowerShellInline code={`--is-inside-work-tree`} />: opción que hace
                                que <PowerShellInline code={`rev-parse`} /> devuelva "true" (por
                                stdout) y <I>ExitCode</I> 0 cuando la ruta está dentro de un work
                                tree; si no, el <I>ExitCode</I> será distinto de 0.
                            </ListItem>
                        </List>
                    </ListItem>
                    <ListItem icon={icons.Eye}>
                        <B>Resolución física</B>: <PowerShellInline
                            code="Resolve-Path -LiteralPath"
                        /> obtiene <Mono>ProviderPath</Mono> para evitar ambigüedades y fallar
                        temprano si la ruta es inválida.
                    </ListItem>

                    <ListItem icon={icons.MagicWand}>
                        <B>Manejo de errores</B>: cualquier excepción asigna <Mono>Status =
                            'NotRepository'</Mono> y preserva el detalle en <Mono>Error</Mono> para
                        inspección posterior sin detener otros scripts.
                    </ListItem>

                    <ListItem icon={icons.Info}>
                        <B>Salida estructurada</B>: retornar un objeto facilita componer condiciones
                        (<PowerShellInline code="if ($result.Status -eq 'IsRepository')" />) y
                        serializar resultados.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-convert-to-valid-gitlab-name">
            <Heading
                headingLevel="h3" Icon={icons.Hash}
                slot="heading"
            >
                Normalizar nombres para GitLab
            </Heading>

            <P>
                GitLab exige nombres de repositorio en minúsculas, sin espacios ni caracteres
                especiales (solo <Mono>[a-z0-9-]</Mono>). Este pequeño filtro convierte cualquier
                entrada —por ejemplo, <Mono>"R.E.M."</Mono>— en un <I>slug</I> válido como <Mono
                >"rem"</Mono>, y falla explícitamente en strings que no pueda convertir como <Mono
                >"菊池ひみこ"</Mono>. Lo usamos antes de crear el remoto para evitar errores de
                sintaxis y mantener nombres legibles y predecibles.
            </P>

            <Info headingLevel="h4">
                <B slot="title">Contrato</B>

                Toma un nombre arbitrario y devuelve un identificador válido para GitLab, o falla de
                forma explícita si no puede hacerlo. La normalización no intenta
                <Enquote>forzar</Enquote> un nombre válido: si el resultado no es significativo, el
                script falla.
            </Info>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding()]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Name
                    )

                    Set-StrictMode -Version 3.0

                    # [!code focus:7]
                    $normalized = $Name.ToLowerInvariant() -replace '\\s+', '-' -replace '[^a-z0-9-]', ''
                    if ([string]::IsNullOrWhiteSpace($normalized)) {
                        throw [System.ArgumentException]::new(
                            "Name '$Name' is not valid after normalizing to '$normalized' (only [a-z0-9-])."
                        )
                    }

                    $normalized
                `}
            >
                <Fragment slot="title">ConvertTo-ValidGitLabName.ps1</Fragment>
                <Fragment slot="footer">
                    Retorna el nombre normalizado o lanza excepción si el resultado está vacío.
                </Fragment>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/ConvertTo-ValidGitLabName.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.TextT}>
                        <B>Minúsculas invariantes</B>: <PowerShellInline
                            code=".ToLowerInvariant()"
                        /> convierte sin depender de la cultura local (evita casos como "I/İ" en
                        turco).
                    </ListItem>

                    <ListItem icon={icons.Eraser}>
                        <B>Limpieza de caracteres</B>: <PowerShellInline
                            code="-replace '\\s+', '-'"
                        /> cambia espacios por guiones; <PowerShellInline
                            code="-replace '[^a-z0-9-]', ''"
                        /> elimina todo lo que no sea alfanumérico o guion.
                    </ListItem>
                </List>
            </Explanation>

            <P>
                Este tipo de normalización es común al integrar herramientas externas (APIs,
                registries, CI/CD), donde los nombres visibles para las personas deben mapearse a
                identificadores técnicos válidos.
            </P>
        </NotesSection>

        <NotesSection id="h3-new-gitlab-repo-status">
            <Heading
                headingLevel="h3" Icon={icons.GitBranch}
                slot="heading"
            >
                Crear repo remoto en GitLab
            </Heading>

            <P>
                Este script crea un repositorio remoto de forma <B>idempotente</B>: primero consulta
                si existe y, solo si no existe, intenta crearlo. Devuelve un objeto con
                <PowerShellInline code={`Name`} />, <PowerShellInline code={`Visibility`} /> y
                <PowerShellInline code={`Status { Created; Reason }`} />.
            </P>

            <Info headingLevel="h4">
                <B slot="title">Contrato</B>
                Si el repo existe, no hace cambios; si no existe, intenta crearlo (respetando
                <PowerShellInline>-WhatIf</PowerShellInline>/<PowerShellInline
                >-Confirm</PowerShellInline>) y siempre retorna un objeto describiendo el resultado.
            </Info>

            <P>
                Aquí <PowerShellInline code={`Reason`} /> funciona como un campo de diagnóstico:
                prioriza registrar “qué pasó” sobre imponer un único tipo. Por eso puede ser texto,
                la salida de <Mono>glab</Mono> o un <I>ErrorRecord</I> si algo falla.
            </P>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Name,

                        [switch] $Public
                    )

                    Set-StrictMode -Version 3.0

                    # [!code focus:12]
                    $normalized = & (Join-Path $PSScriptRoot 'ConvertTo-ValidGitLabName.ps1') -Name $Name
                    $visibility = if ($Public.IsPresent) { 'public' } else { 'private' }
                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    $repository = [PSCustomObject]@{
                        Name       = $normalized
                        Visibility = $visibility
                        Status     = [PSCustomObject]@{
                            Created = $false
                            Reason  = ''
                        }
                    }

                    try {
                        # [!code focus:1]
                        & $invoker glab repo view $repository.Name | Out-Null
                        $repository.Status.Reason = '{0} already exists on GitLab.' -f $repository.Name
                    }
                    catch {
                        if ($PSCmdlet.ShouldProcess($normalized, "Create GitLab repository ($visibility)")) {
                            try {
                                # [!code focus:4]
                                $args = @('repo', 'create', $normalized, '--defaultBranch', 'main')
                                if ($Public) { $args += '--public' } else { $args += '--private' }

                                $result = & $invoker glab $args
                                $repository.Status.Created = $true
                                $repository.Status.Reason = $result
                            }
                            catch {
                                $repository.Status.Reason = $_
                            }
                        }
                        else {
                            $repository.Status.Reason = 'Creation cancelled by user.'
                        }
                    }

                    $repository
                `}
            >
                <span slot="title">New-GitLabRepository.ps1</span>
                <span slot="footer">
                    Devuelve objeto con <Mono>Status.Created</Mono> y <Mono>Status.Reason</Mono>
                    (texto, salida de <Mono>glab</Mono> o <I>ErrorRecord</I>), más
                    <Mono>Name</Mono>/<Mono>Visibility</Mono>.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/New-GitLabRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation>
                <List>
                    <ListItem icon={icons.MagnifyingGlass}>
                        <B>Idempotencia</B>: primero intenta <PowerShellInline
                            code="glab repo view"
                        />; si existe, solo informa; si no, procede a crear.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>glab repo view</B>: ejecuta <PowerShellInline
                            code="glab repo view $repository.Name"
                        /> solo para comprobar si el proyecto ya existe en GitLab. Si el comando
                        termina correctamente, asumimos que el repo está creado y solo rellenamos
                        <PowerShellInline>Status.Reason</PowerShellInline>; si lanza error, caemos
                        en el <PowerShellInline code="catch" /> y pasamos a la lógica de creación.
                        Un fallo aquí puede significar <Enquote>no existe</Enquote>, pero también
                        permisos o conectividad; por eso el script preserva el detalle en
                        <PowerShellInline>Status.Reason</PowerShellInline>.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>glab repo create</B>: construye el array <PowerShellInline
                            code="$args"
                        /> como <PowerShellInline
                            code="repo create $normalized --defaultBranch main"
                        />, añadiendo <PowerShellInline code="--public" /> o <PowerShellInline
                            code="--private"
                        /> según el parámetro <PowerShellInline>-Public</PowerShellInline>.
                        <PowerShellInline>--defaultBranch main</PowerShellInline> fija el nombre de
                        la rama principal y los flags <PowerShellInline
                        >--public</PowerShellInline>/<PowerShellInline>--private</PowerShellInline>
                        controlan la visibilidad del proyecto en GitLab.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Salida rica</B>: <PowerShellInline>Status.Reason</PowerShellInline> puede
                        ser texto, la salida de
                        <PowerShellInline>glab</PowerShellInline> o un <I>ErrorRecord</I>; útil para
                        inspección y logs.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-set-gitlab-remote">
            <Heading
                headingLevel="h3" Icon={icons.Link}
                slot="heading"
            >
                Asignar remoto GitLab a un repo existente
            </Heading>

            <P>
                Este script conecta un repositorio local ya inicializado con un remoto en GitLab:
                valida que la ruta sea un repo Git, genera la URL a partir del usuario y el nombre
                normalizado, y luego crea o actualiza el remoto (por defecto <Mono>origin</Mono>) de
                forma <B>idempotente</B>. Devuelve un objeto con la acción realizada y la razón,
                útil para inspección y logs.
            </P>

            <Info headingLevel="h4">
                <B slot="title">Contrato</B>
                Si la ruta no es un repo Git, falla explícitamente; si lo es, configura el remoto y
                siempre retorna un objeto describiendo la acción (<Mono>Added</Mono>/<Mono
                >Updated</Mono>/<Mono>Skipped</Mono>/<Mono>Failed</Mono>).
            </Info>

            <Note headingLevel="h4">
                Configurar el remoto no autentica ni hace <I>push</I>; para publicar luego
                necesitarás credenciales (HTTPS con token o SSH).
            </Note>

            <Warning headingLevel="h4">
                <span slot="title">Supuesto</span>

                Esta versión asume GitLab.com (<Mono>https://gitlab.com/...</Mono>); en GitLab
                autogestionado la URL base cambia.
            </Warning>

            <PowerShellBlock
                code={`
                #Requires -Version 7.5
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                    [string] $Path,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $User,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Name,

                    [ValidateNotNullOrWhiteSpace()]
                    [string] $Remote = 'origin'
                )

                Set-StrictMode -Version 3.0

                # [!code focus:2]
                $testRepo = Join-Path $PSScriptRoot 'Test-GitRepository.ps1' -Resolve
                $convertName = Join-Path $PSScriptRoot 'ConvertTo-ValidGitLabName.ps1' -Resolve
                $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                # [!code focus:5]
                if ((& $testRepo -Path $Path).Status -ne 'IsRepository') {
                    throw [System.InvalidOperationException]::new(
                        "Path '$Path' is not a valid Git repository."
                    )
                }

                $repoPath = (Resolve-Path -LiteralPath $Path -ErrorAction Stop).ProviderPath
                # [!code focus:1]
                $remoteUrl = 'https://gitlab.com/{0}/{1}.git' -f $User, (& $convertName -Name $Name)

                $result = [PSCustomObject]@{
                    Path       = $repoPath
                    RemoteName = $Remote
                    RemoteUrl  = $remoteUrl
                    Action     = 'None'
                    Reason     = ''
                }

                $target = '{0} remote {1} -> {2}' -f $repoPath, $Remote, $remoteUrl
                if (!$PSCmdlet.ShouldProcess($target, 'Set Git remote')) {
                    $result.Action = 'Skipped'
                    $result.Reason = 'Operation cancelled by user.'
                }
                else {
                    try {
                        try {
                            # [!code focus:2]
                            & $invoker git -C $repoPath remote get-url $Remote | Out-Null
                            & $invoker git -C $repoPath remote set-url $Remote $remoteUrl | Out-Null
                            $result.Action = 'Updated'
                            $result.Reason = "Remote '$Remote' URL updated."
                        }
                        catch {
                            # [!code focus:1]
                            & $invoker git -C $repoPath remote add $Remote $remoteUrl | Out-Null
                            $result.Action = 'Added'
                            $result.Reason = "Remote '$Remote' created."
                        }
                    }
                    catch {
                        $result.Action = 'Failed'
                        $result.Reason = $_
                    }
                }

                $result
            `}
            >
                <span slot="title">Set-GitLabRemote.ps1</span>
                <span slot="footer">
                    Configura el remoto de un repositorio local hacia GitLab (por defecto <Mono
                    >origin</Mono>) y devuelve qué acción se ejecutó (<Mono>Added</Mono>, <Mono
                    >Updated</Mono>, <Mono>Skipped</Mono>, <Mono>Failed</Mono>).
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Set-GitLabRemote.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.Eye}>
                        <B>Verificación del repo</B>: usa <PowerShellInline
                            code="Test-GitRepository.ps1"
                        /> para asegurarse de que <Mono>$Path</Mono> apunta a un repositorio Git
                        válido antes de tocar remotos; si no, lanza una <I
                        >InvalidOperationException</I>
                        con un mensaje claro.
                    </ListItem>

                    <ListItem icon={icons.Hash}>
                        <B>Nombre normalizado</B>: delega en <PowerShellInline
                            code="ConvertTo-ValidGitLabName.ps1"
                        /> la generación del <I>slug</I> del proyecto y construye la URL como
                        <Mono>https://gitlab.com/&lt;user&gt;/&lt;slug&gt;.git</Mono>.
                    </ListItem>

                    <ListItem icon={icons.Terminal}>
                        <B>Idempotencia del remoto</B>: primero intenta <PowerShellInline
                            code="git -C $repoPath remote get-url $Remote"
                        />; si el remoto existe, ejecuta <PowerShellInline
                            code="git -C $repoPath remote set-url $Remote $remoteUrl"
                        />, y si falla (por ejemplo, porque el remoto no existe) cae en el <I
                        >catch</I> interno y usa <PowerShellInline
                            code="git -C $repoPath remote add $Remote $remoteUrl"
                        />.
                    </ListItem>

                    <ListItem icon={icons.ShieldCheck}>
                        <B>Confirmación opcional</B>: soporta <Mono>-WhatIf</Mono>/<Mono
                        >-Confirm</Mono>
                        para simular cambios o pedir confirmación antes de modificar remotos.
                    </ListItem>
                </List>
            </Explanation>
        </NotesSection>

        <NotesSection id="h3-publish-git-repository">
            <Heading
                headingLevel="h3" Icon={icons.Play}
                slot="heading"
            >
                Orquestar creación de repo y remoto
            </Heading>

            <P>
                Para cerrar el flujo, este script actúa como <B>orquestador</B>: crea (si hace
                falta) el repositorio remoto en GitLab y a continuación configura el remoto en el
                repositorio local apuntando a ese proyecto. Reutiliza los scripts anteriores,
                respeta <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" />
                y devuelve un objeto con el detalle de cada paso.
            </P>

            <Info headingLevel="h4">
                <B slot="title">Contrato</B>
                Intenta garantizar que <span class="text-primary">(1)</span> el repo remoto exista y
                <span class="text-primary">(2)</span> el remoto local apunte a él; el resultado
                siempre indica qué ocurrió en cada etapa.
            </Info>

            <Note headingLevel="h4">
                Aquí <Enquote>publish</Enquote> significa <I>preparar la publicación</I> (repo
                remoto + remoto local). Este script no hace <Mono>commit</Mono> ni <Mono>push</Mono>
                (esta decisión es intencionada).
            </Note>

            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                        [string] $Path,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $User,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Name,

                        [switch] $Public,

                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Remote = 'origin'
                    )

                    Set-StrictMode -Version 3.0

                    # [!code focus:19]
                    $createGitLabRepo = Join-Path $PSScriptRoot 'New-GitLabRepository.ps1' -Resolve
                    $setGitRemote = Join-Path $PSScriptRoot 'Set-GitRemote.ps1' -Resolve

                    $forwardBoundParams = @{}
                    if ($PSBoundParameters.ContainsKey('WhatIf')) {
                        $forwardBoundParams['WhatIf'] = $PSBoundParameters['WhatIf']
                    }
                    if ($PSBoundParameters.ContainsKey('Confirm')) {
                        $forwardBoundParams['Confirm'] = $PSBoundParameters['Confirm']
                    }

                    $gitLab = & $createGitLabRepo -Name $Name -Public:$Public @forwardBoundParams

                    $remoteParams = @{}
                    $remoteParams += $forwardBoundParams
                    $remoteParams += @{ Path = $Path; User = $User; Name = $Name; Remote = $Remote }

                    $remoteResult = & $setGitRemote @remoteParams

                    [PSCustomObject]@{
                        Path   = $Path
                        GitLab = $gitLab
                        Remote = $remoteResult
                    }
                `}
            >
                <Fragment slot="title">Publish-GitRepository.ps1</Fragment>
                <span slot="footer">
                    Orquesta la creación del repositorio remoto en GitLab y la configuración del
                    remoto local, devolviendo un objeto con el resultado de ambos pasos.
                </span>
                <DibsSourceLink
                    slot="source" repo="scripts"
                    file="git/Publish-GitRepository.ps1"
                />
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.ShieldCheck}>
                        <B>Propaga <PowerShellInline>-WhatIf</PowerShellInline>/<PowerShellInline
                            >-Confirm</PowerShellInline></B>: construye
                        <PowerShellInline>$forwardBoundParams</PowerShellInline> a partir de
                        <PowerShellInline>$PSBoundParameters</PowerShellInline> y lo pasa a ambos
                        scripts, asegurando que los ensayos y confirmaciones se respeten de extremo
                        a extremo.
                    </ListItem>

                    <ListItem icon={icons.Package}>
                        <B>Salida estructurada</B>: retorna un objeto con <PowerShellInline
                        >Path</PowerShellInline>, más los resultados completos de <PowerShellInline
                        >GitLab</PowerShellInline> y <PowerShellInline>Remote</PowerShellInline>.
                        Esto permite inspeccionar qué ocurrió en cada etapa o registrar el resultado
                        en logs sin necesidad de parsear texto.
                    </ListItem>
                </List>
            </Explanation>

            <Info headingLevel="h4">
                <span slot="title">Ejemplo de uso</span>

                <PowerShellBlock
                    code={`
                        git init # Si aún no es un repo Git
                        $params = @{
                            User = 'tu-usuario' # Reemplaza con tu nombre de usuario de GitLab
                            Path = '.'
                            Name = (Get-Item -Path '.').Name
                        }
                        $result = ./git/Publish-GitRepository.ps1 @params -WhatIf
                    `}
                >
                    <span slot="title">Desde <Mono>dibs/scripts</Mono></span>
                </PowerShellBlock>

                <P>
                    Revisa <PowerShellInline>$result</PowerShellInline> para verificar que todo está
                    en orden, luego ejecuta sin <PowerShellInline>-WhatIf</PowerShellInline> para
                    crear el repo y asignar el remoto. Usa <PowerShellInline
                    >-Confirm</PowerShellInline> para aprobar cada paso si prefieres mayor control.
                </P>

                <P>
                    Si quieres confirmar el lado remoto, puedes inspeccionarlo con <PowerShellInline
                        code="glab repo view <nombre>"
                    />.
                </P>
            </Info>

            <Question headingLevel="h4">
                <span slot="title">Verificar</span>

                <PowerShellBlock
                    code={`
                        # Revisar resultado
                        $result.GitLab.Status    # Created y Reason
                        $result.Remote.Action    # Added/Updated/Skipped/Failed

                        # Confirmar con Git
                        git remote -v
                    `}
                >
                    <span slot="title">Inspeccionar resultado</span>
                </PowerShellBlock>
            </Question>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-next-steps">
        <Heading
            headingLevel="h2" Icon={icons.Rocket}
            slot="heading"
        >
            Siguientes pasos
        </Heading>

        <P>
            Los scripts <B>no hacen commit ni push</B> para evitar cambios accidentales. La idea es
            que revises el estado del repo y confirmes conscientemente qué subirás. Además, conviene
            agregar un <Mono>.gitignore</Mono> antes de tu primer commit.
        </P>

        <P>
            Esta decisión separa la <B>automatización de infraestructura</B> (crear repos, remotos,
            validar estado) de las <B>decisiones sobre el contenido del código</B> (qué archivos
            versionar y cuándo publicarlos).
        </P>

        <P>
            El primer commit suele incluir solo la estructura inicial, configuración y documentación
            básica del proyecto. Además, es recomendable agregar un <Mono>.gitignore</Mono> antes de
            ese primer commit.
        </P>

        <P>
            Asegúrate de estar en la rama correcta (<Mono>main</Mono>) antes de hacer <Mono
            >push</Mono>.
        </P>

        <PowerShellBlock
            code={`
                # Revisa estado y agrega .gitignore
                git status
                # Visita https://www.toptal.com/developers/gitignore/ para generar .gitignore

                # Primer commit y push
                git add .
                git commit -m "init: estructura y configuración inicial"
                git push origin main
            `}
        >
            <Fragment slot="title">Desde <Mono>dibs/scripts</Mono></Fragment>
            <span slot="footer">Publicar cambios manualmente</span>
        </PowerShellBlock>

        <Important>
            Si tu proyecto genera artefactos (por ejemplo, <Mono>bin/</Mono>, <Mono>obj/</Mono>,
            <Mono>dist/</Mono>, <Mono>node_modules/</Mono>, <Mono>*.env</Mono>), asegúrate de
            ignorarlos en <Mono>.gitignore</Mono> para evitar subir archivos innecesarios o
            sensibles.
        </Important>
    </NotesSection>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            <P>
                Conectamos validaciones, salida tipada y <I>CLI</I> en un flujo completo. Pasamos de
                comprobar si una carpeta es repo, a normalizar nombres, crear el proyecto remoto con
                <PowerShellInline code="glab" /> y fijar el remoto de forma idempotente.
            </P>
            <P>
                La salida estructurada y el soporte de <PowerShellInline
                    code="-WhatIf"
                />/<PowerShellInline code="-Confirm" /> hacen visibles las decisiones del flujo y
                permiten ensayar antes de afectar el entorno. Esa observabilidad —contratos claros +
                resultados inspeccionables— reduce fricción sin perder control.
            </P>
        </Fragment>

        <Fragment slot="key-points">
            <ListItem icon={icons.Terminal}>
                <B>Flujo completo automatizado:</B> desde <PowerShellInline code="glab repo view" />
                para detectar existentes hasta <PowerShellInline code="glab repo create" /> y la
                configuración del remoto con <PowerShellInline>git remote</PowerShellInline>, todo
                se ensambla sin pasos repetitivos.
            </ListItem>

            <ListItem icon={icons.Hash}>
                <B>Normalización y validaciones:</B> transformar nombres a <Mono>[a-z0-9-]</Mono> y
                verificar rutas antes de operar evita errores de sintaxis o rutas mal apuntadas.
            </ListItem>

            <ListItem icon={icons.ShieldCheck}>
                <B>Idempotencia y seguridad:</B> los scripts no sobreescriben sin revisar, exponen
                objetos con estado (<Mono>Status</Mono>/<Mono>Reason</Mono>) y soportan
                <PowerShellInline code="-WhatIf" />/<PowerShellInline code="-Confirm" /> para probar
                sin riesgos.
            </ListItem>

            <ListItem icon={icons.GitBranch}>
                <B>Salida estructurada:</B> devolver objetos facilita registrar, auditar y encadenar
                resultados en orquestaciones mayores sin parsear texto.
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            <P>
                El objetivo no es “GitLab”, sino el patrón: automatizar infraestructura y
                validaciones manteniendo humana la decisión del contenido. Idempotencia +
                confirmación + salida estructurada es una combinación transferible.
            </P>

            <P>
                Con estos bloques listos, el siguiente paso del curso es el <B>pipeline de
                    PowerShell</B>: encadenar scripts que devuelven objetos (no texto) y construir
                orquestadores que puedas reutilizar para bootstrap de proyectos, tareas de build o
                publicación de artefactos.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <References>
        <Fragment slot="recommended">
            <WebPage title="Gitlab CLI (glab)" url="https://docs.gitlab.com/cli/">
                <Link slot="location" href="https://docs.gitlab.com/">GitLab Docs</Link>
                <Fragment slot="description">
                    Documentación oficial de GitLab CLI (<PowerShellInline>glab</PowerShellInline>),
                    la herramienta de línea de comandos para interactuar con GitLab. Cubre
                    autenticación (OAuth y tokens), gestión de repositorios, <I>merge requests</I>,
                    CI/CD pipelines y releases. Útil como referencia para los comandos usados en el
                    laboratorio (<PowerShellInline>glab auth login</PowerShellInline>,
                    <PowerShellInline>glab repo create</PowerShellInline>,
                    <PowerShellInline>glab repo view</PowerShellInline>) y para explorar capacidades
                    avanzadas de automatización con GitLab.
                </Fragment>
            </WebPage>
        </Fragment>
    </References>

    <Footnotes>
        <Footnote index={1}>
            Una estrategia común para mitigar este problema es mantener un <B>mirror</B> del
            repositorio en GitHub (Git permite definir varios remotos). Sin embargo, esto puede
            complicar la gestión de <I>issues</I> o solicitudes de cambio (<I>merge requests</I> en
            GitLab, equivalentes a <I>pull requests</I> en GitHub), ya que habría que coordinar dos
            fuentes distintas de colaboración.
        </Footnote>
    </Footnotes>
</NotesLayout>
