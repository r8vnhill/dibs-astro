---
import * as icons from "~/assets/img/icons";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import {
    TableBody,
    TableCaption,
    TableCell,
    TableHeader,
    TableRow,
} from "~/components/starwind/table";
import Table from "~/components/starwind/table/Table.astro";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Important,
    Info,
    More,
    Note,
    Question,
    Tip,
    Warning,
} from "~/components/ui/callouts";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { Mono } from "~/components/ui/font";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import { DibsSourceLink, Link } from "~/components/ui/links";
import NushellLink from "~/components/ui/links/NushellLink.astro";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, Book, References, WebPage } from "~/components/ui/references";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import LinksLayout from "~/layouts/LinksLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Manejo de errores terminantes en PowerShell"
    description="Guía práctica de manejo de errores terminantes en PowerShell: promover fallos a terminantes con -ErrorAction Stop, capturarlos con try/catch/finally y ejecutar comandos externos de forma segura con Get-Command. Mencionamos errores no terminantes solo como contraste; los veremos más adelante con el pipeline."
    timeMultiplier={1.5} git={{ user: "r8vnhill", repo: "dibs-scripts" }}
>
    <Abstract>
        <P>
            Al terminar esta lección podrás <B>controlar el flujo con errores terminantes</B> en
            PowerShell: promover fallos con <PowerShellInline code="-ErrorAction Stop" />,
            capturarlos con <PowerShellInline code="try" />/<PowerShellInline code="catch" />/
            <PowerShellInline code="finally" /> y devolver <B>salida estructurada</B> en lugar de
            texto suelto. Nos centraremos en errores <B>terminantes</B>; los errores
            <I>no terminantes</I> aparecerán solo como contraste y los estudiaremos en detalle más
            adelante, cuando entremos en el <I>pipeline</I>.
        </P>

        <P>
            También aprenderás un <B>patrón seguro para ejecutar comandos externos</B>: resolver el
            binario real, ejecutarlo de forma inequívoca, capturar su resultado y <B>elevar fallos
                con contexto</B> cuando corresponda, para evitar scripts frágiles o dependientes del
            entorno. El ejercicio final consolida estas ideas implementando un <I>fallback</I>
            simple entre herramientas, priorizando <B>capacidades reales</B> por sobre suposiciones.
        </P>
    </Abstract>

    <NotesSection id="h2-terminating-errors">
        <Heading
            headingLevel="h2" Icon={icons.Warning}
            slot="heading"
        >
            Errores terminantes
        </Heading>

        <P>
            En un shell orientado a automatización y pipelines como PowerShell, no todos los fallos
            deben detener la ejecución. A menudo procesas <B>muchos elementos</B> (archivos, filas,
            recursos remotos) y necesitas <B>registrar errores por ítem</B> sin abortar el lote
            completo: estos son errores <I>no terminantes</I>.
        </P>

        <P>
            En cambio, cuando una operación es crítica (por ejemplo, escribir o borrar datos),
            conviene <B>elevar el error a terminante</B> para detener el flujo y manejarlo
            explícitamente con <PowerShellInline code="try" />/<PowerShellInline code="catch" />.
            PowerShell modela esta distinción de forma explícita y proporciona mecanismos como
            <PowerShellInline code="-ErrorAction" /> y
            <PowerShellInline code="$ErrorActionPreference" />
            para <B>promover</B> errores no terminantes a terminantes cuando el script lo requiere.
        </P>

        <P>
            <I>Ojo:</I> <PowerShellInline code="try" />/<PowerShellInline code="catch" />
            solo captura errores <B>terminantes</B>. Esto no es un detalle accidental: los errores
            no terminantes están pensados para <B>reportar problemas sin romper el flujo</B>,
            mientras que <PowerShellInline code="try" />/<PowerShellInline code="catch" /> está
            diseñado para el <B>control explícito del flujo</B> ante fallos críticos. En última
            instancia, PowerShell nos permite decidir si los errores
            <I>informan</I> o <I>definen</I> el comportamiento del programa.
        </P>

        <Definition headingLevel="h3">
            <Fragment slot="title">
                Error <B>no</B> terminante
            </Fragment>

            <P>
                Un <B>error no terminante</B> registra la falla pero <I>continúa</I> la ejecución.
                Es útil cuando procesas un conjunto de elementos y quieres un reporte <B>por
                    elemento</B> de qué funcionó y qué falló, sin detener todo ante el primer error.
                Solo lo mencionamos aquí como contexto; lo veremos con más detalle cuando abordemos
                el <I>pipeline</I>, donde resulta especialmente relevante.
            </P>
        </Definition>

        <Definition headingLevel="h3">
            <Fragment slot="title">Error terminante</Fragment>

            <P>
                Un <B>error terminante</B> <I>interrumpe</I> inmediatamente el flujo. Úsalo cuando
                la operación es crítica (crear/escribir/borrar datos relevantes, cambios de estado,
                CI/CD), promoviendo fallos con
                <PowerShellInline code="-ErrorAction Stop" /> y manejándolos con <PowerShellInline
                    code="try"
                />/<PowerShellInline code="catch" />/<PowerShellInline code="finally" />.
            </P>

            <P>
                En CI/CD suele ser deseable <B>fallar rápido</B> para evitar despliegues
                inconsistentes o estados intermedios.
            </P>
        </Definition>

        <Tip headingLevel="h3">
            <Fragment slot="title">Regla práctica</Fragment>
            <P>
                Si un fallo invalida el resultado del script, conviértelo en terminante; si solo
                invalida <I>un elemento</I>, suele ser mejor tratarlo como no terminante (registrar
                y continuar).
            </P>
        </Tip>

        <P>
            Este ejemplo implementa una copia <B>segura y predecible</B> con <PowerShellInline
                code="ShouldProcess"
            /> para confirmación, y elevación de errores a <I>terminantes</I> para capturarlos con
            <PowerShellInline code="catch" />. El bloque <PowerShellInline code="finally" />
            garantiza una <B>salida estructurada</B> con el <I>estado</I> de la operación, incluso
            ante fallos o cancelaciones.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5 
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ })]
                    # [!code focus:1]
                    [string] $Source,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                    # [!code focus:1]
                    [string] $Destination,

                    [switch] $Recurse
                )

                Set-StrictMode -Version 3.0

                # [!code focus:6]
                $result = @{
                    Source      = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Source)
                    Destination = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Destination)
                }
                $result.Target = Join-Path $result.Destination (Split-Path -Leaf $result.Source)

                # [!code focus:1]
                try {
                    $shouldProcess = $PSCmdlet.ShouldProcess($result.Source, 'Copy to {0}' -f $result.Destination)
                    # [!code focus:2]
                    if ($shouldProcess) {
                        if (Test-Path -LiteralPath $result.Target) {
                            # [!code focus:2]
                            $result.Status = 'Skipped'
                            $result.Reason = ('Target already exists: {0}' -f $result.Target)
                        }
                        # [!code focus:1]
                        else {
                            $copyParams = @{
                                LiteralPath = $result.Source
                                Destination = $result.Destination
                                Recurse     = $Recurse
                                # [!code focus:1]
                                ErrorAction = 'Stop'
                            }

                            # [!code focus:2]
                            Copy-Item @copyParams
                            $result.Status = 'Copied'
                        }
                    }
                    # [!code focus:3]
                    else {
                        # Make cancellation explicit so callers don't need to infer it from missing Status
                        $result.Status = 'Cancelled'
                        $result.Reason = 'ShouldProcess returned False (confirmation declined or -WhatIf)'
                    }
                }
                # [!code focus:1]
                catch {
                    $result.Status = 'Failed'
                    # [!code focus:4]
                    $result.Error = [PSCustomObject]@{
                        Kind    = $_.Exception.GetType().Name
                        Message = $_.Exception.Message
                    }
                }
                # [!code focus:1]
                finally {
                    [PSCustomObject]$result
                }
            `}
        >
            <Fragment slot="title"
            >Copia segura con <Mono>ShouldProcess</Mono> y salida estructurada</Fragment>
            <DibsSourceLink
                repo="scripts" file="operations/Copy-ItemStrict.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <P>
                El objetivo del diseño no es solo copiar archivos: es <B>comunicar explícitamente
                    qué ocurrió</B>, sin obligar al consumidor a inferirlo desde excepciones o
                salida textual.
            </P>

            <List>
                <ListItem icon={icons.Path}>
                    <B>Rutas normalizadas y destino final:</B>
                    <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath()" />
                    resuelve rutas absolutas; <PowerShellInline
                        code="Join-Path ... (Split-Path -Leaf ...)"
                    /> compone el <Mono>Target</Mono>.
                </ListItem>

                <ListItem icon={icons.Package}>
                    <B>Validación temprana:</B> <PowerShellInline
                        code="[ValidateScript({ Test-Path ... })]"
                    />
                    asegura que el origen existe y que el destino es un contenedor.
                </ListItem>

                <ListItem icon={icons.HandPalm}>
                    <B><PowerShellInline code="-ErrorAction Stop" />:</B> promueve fallos de
                    <PowerShellInline code="Copy-Item" /> a <I>terminantes</I> para entrar en
                    <PowerShellInline code="catch" />.
                </ListItem>

                <ListItem icon={icons.Table}>
                    <B>Salida estructurada:</B> en <PowerShellInline code="finally" /> devolvemos
                    <PowerShellInline code="$result" /> con <Mono>Source/Destination/Target</Mono>,
                    <Mono>Status</Mono> y, cuando aplica, <Mono>Reason</Mono> o <Mono>Error</Mono>.
                </ListItem>
            </List>

            <P>
                <Mono>Cancelled</Mono> se modela de forma explícita para evitar ambigüedad: el
                script no <I>falló</I>, simplemente <B>no ejecutó la acción</B> (decisión del
                usuario o <PowerShellInline code="-WhatIf" />).
            </P>
        </Explanation>

        <Info headingLevel="h3">
            <span slot="title">Estados posibles del resultado</span>
            <List>
                <ListItem icon={icons.CheckCircle}>
                    <Mono>Copied</Mono>: la copia se realizó correctamente.
                </ListItem>
                <ListItem icon={icons.HandPalm}>
                    <Mono>Skipped</Mono>: el destino ya existía.
                </ListItem>
                <ListItem icon={icons.XCircle}>
                    <Mono>Cancelled</Mono>: <PowerShellInline code="ShouldProcess" /> devolvió
                    <Mono>false</Mono>.
                </ListItem>
                <ListItem icon={icons.Bug}>
                    <Mono>Failed</Mono>: ocurrió un error terminante durante la operación.
                </ListItem>
            </List>
        </Info>

        <Info headingLevel="h3">
            <span slot="title">Uso</span>

            <P>
                Ejecuta el script desde la terminal pasando un archivo y una carpeta destino, para
                centrarnos en el <B>contrato del script</B> antes de introducir pipelines:
            </P>

            <PowerShellBlock
                code={`
                    # Preparación mínima
                    $dest = 'backup'
                    if (!(Test-Path -LiteralPath $dest)) {
                        New-Item -ItemType Directory -Path $dest
                    }

                    # Ensayo con -WhatIf -> 'Cancelled'
                    $w = ./Copy-ItemStrict.ps1 -Source './Copy-ItemStrict.ps1' -Destination $dest -WhatIf
                    $w.Status
                    $w.Reason

                    # Copia real -> 'Copied' (primera vez) o 'Skipped'
                    $r = ./Copy-ItemStrict.ps1 -Source './Copy-ItemStrict.ps1' -Destination $dest
                    $r.Status
                    $r.Target
                `}
            >
                <Fragment slot="title">Usar y leer el resultado (breve, sin pipeline)</Fragment>
            </PowerShellBlock>
        </Info>

        <P>
            Más adelante veremos cómo esta salida estructurada permite <B>encadenar decisiones en
                pipelines</B>, sin depender de <PowerShellInline code="try" />/<PowerShellInline
                code="catch"
            /> externos.
        </P>

        <Question headingLevel="h4">
            <List>
                <ListItem icon={icons.Play}
                >Repite la copia para observar <Mono>Skipped</Mono> y el <Mono
                    >Reason</Mono>.</ListItem>
                <ListItem icon={icons.Folder}
                >Intenta copiar una carpeta sin <Mono>-Recurse</Mono> para ver <Mono>Failed</Mono> y
                    leer <Mono>Error.Kind</Mono>/<Mono>Error.Message</Mono>.</ListItem>
            </List>
        </Question>

        <More headingLevel="h4">
            <span slot="title">Esquema de salida y estabilidad</span>

            <P>
                Este ejemplo define un <B>contrato explícito</B>: siempre devuelve
                <Mono>Source/Destination/Target</Mono> y añade <Mono>Status</Mono> para que el
                consumidor no tenga que <I>inferir</I> qué pasó leyendo excepciones o texto. Nombrar
                <Mono>Cancelled</Mono> de forma directa evita el antipatrón de asumir que
                <Enquote>no se hizo nada</Enquote> solo porque falta información, algo frágil en
                automatización.
            </P>

            <Warning headingLevel="h5">
                <span slot="title">Hay un compromiso</span>

                Un esquema <B>estable/tabular</B> (mismas propiedades siempre, ideal para filtrar o
                agrupar por <Mono>Status</Mono> en un pipeline) versus uno <B>flexible</B>
                (propiedades opcionales según el caso). Aquí <I>todavía no usamos el pipeline</I>,
                así que privilegiamos claridad por encima de rigidez total.
            </Warning>

            <Tip headingLevel="h5">
                <span slot="title">Regla práctica</span>

                Si otros scripts consumirán tu salida, prefiere un <B>esquema estable</B>; si es
                consumo humano puntual, puedes permitir más flexibilidad.
            </Tip>

            <Note headingLevel="h5">
                Al construir con <PowerShellInline code={`@{}`} /> (<I>hashtable</I>) puedes <I
                >perder el orden</I> de propiedades. Si necesitas un orden fijo (por ejemplo, para
                una tabla), crea el <PowerShellInline code="[PSCustomObject]" /> desde el inicio y
                agrega propiedades con <PowerShellInline code="Add-Member" />.
            </Note>
        </More>

        <More headingLevel="h4">
            <span slot="title"><PowerShellInline code="catch" /> tipado</span>

            <P>
                Puedes definir varios bloques <PowerShellInline code={`catch`} /> para distintos
                tipos de excepción y cerrar con uno genérico. Ordénalos de los más específicos a los
                más generales.
            </P>

            <PowerShellBlock
                code={`
                    try {
                        Copy-Item @copyParams
                    }
                    catch [System.UnauthorizedAccessException] {
                        Write-Warning ('Permisos insuficientes: {0}' -f $_.Exception.Message)
                    }
                    catch [System.IO.IOException] {
                        Write-Warning ('Problema de E/S: {0}' -f $_.Exception.Message)
                    }
                    catch {
                        Write-Warning ('Error {0}: {1}' -f $_.Exception.GetType().Name, $_.Exception.Message)
                    }
                `}
            >
                <Fragment slot="title">Orden de <Mono>catch</Mono> y uso práctico</Fragment>
            </PowerShellBlock>

            <P>
                En PowerShell es común incluir un <PowerShellInline code={`catch`} /> genérico
                porque muchos cmdlets encapsulan las excepciones .NET dentro de objetos
                <PowerShellInline code={`[ErrorRecord]`} />. En la práctica esto implica que el
                <I>tipo de excepción original</I> no siempre es el que llega al
                <PowerShellInline code={`catch`} />, por lo que tipar puede fallar. El
                <PowerShellInline code={`catch`} /> genérico actúa como <B>última línea de
                    defensa</B>: garantiza que el error no se pierda ni quede sin manejar.
            </P>

            <Tip headingLevel="h5">
                <span slot="title">Regla práctica</span>

                Tipa <PowerShellInline code={`catch`} /> solo cuando esperas un fallo concreto y
                recurrente; mantén siempre un <PowerShellInline code={`catch`} /> genérico como
                respaldo. En ambos casos, el objetivo es convertir el error en <B>información
                    útil</B> (por ejemplo en <Mono>Error</Mono>) para quien consuma el resultado.
            </Tip>
        </More>
    </NotesSection>

    <NotesSection id="h2-verify-external-commands">
        <Heading
            headingLevel="h2" Icon={icons.MagnifyingGlass}
            slot="heading"
        >
            Verificar y ejecutar comandos externos con seguridad
        </Heading>

        <P>
            Patrón simple: resolver el binario real con <PowerShellInline code="Get-Command" />,
            ejecutarlo con el <I>call operator</I> <PowerShellInline code="&" />, y validar
            <PowerShellInline code="$LASTEXITCODE" />. Devuelve un objeto con datos útiles para logs
            o para controlar el flujo.
        </P>

        <PowerShellBlock
            code={`
            #Requires -Version 7.5
            [CmdletBinding()]
            param(
                [Parameter(Mandatory)]
                [ValidateNotNullOrWhiteSpace()]
                [string] $Name,

                [Parameter(ValueFromRemainingArguments)]
                [ValidateNotNull()]
                [string[]] $Rest = @()
            )

            Set-StrictMode -Version 3.0

            $cmds = @(Get-Command -Name $Name -CommandType Application -ErrorAction Stop)
            if ($cmds.Count -gt 1) {
                Write-Warning ("Multiple executables named '{0}' were found. Using: {1}" -f 
                    $Name, $cmds[0].Source)
            }
            $path = $cmds[0].Source

            $originalEncoding = [Console]::OutputEncoding
            try {
                [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
                # [!code highlight:1]
                $out = & $path @Rest 2>&1
            }
            finally {
                [Console]::OutputEncoding = $originalEncoding
            }

            if ($LASTEXITCODE -eq 0) {
                [PSCustomObject]@{
                    ToolPath = $path
                    ExitCode = $LASTEXITCODE
                    Output   = $out
                }
            }
            else {
                $nl = [Environment]::NewLine
                $msg = ('{0} {1} returned exit code {2}.{3}Output:{3}{4}' -f $Name, ($Rest -join ' '), 
                    $LASTEXITCODE, $nl, ($out -join $nl))
                throw [System.Exception]::new($msg)
            }
        `}
        >
            <Fragment slot="title">Wrapper seguro para comandos externos</Fragment>
            <DibsSourceLink
                repo="scripts" file="tools/Invoke-Tool.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.ArrowElbowRight}>
                    <B><PowerShellInline code="ValueFromRemainingArguments" />:</B> todo lo que
                    quede después de <PowerShellInline code="-Name" /> se captura en
                    <PowerShellInline code="$Rest" /> <I>sin intentar interpretarlo como parámetros
                        del script</I>. Así puedes pasar flags arbitrarios al binario:
                    <PowerShellInline code="Invoke-Tool -Name git -C . status --porcelain" />.
                </ListItem>

                <ListItem icon={icons.MagnifyingGlass}>
                    <B><PowerShellInline code="Get-Command ... -ErrorAction Stop" />:</B> resuelve
                    el ejecutable real (solo de tipo <I>Application</I>) a partir de todos los
                    candidatos que encuentra (devuelve una colección). Aquí usamos una heurística
                    simple (<I>primer candidato</I>), suficiente para scripts controlados; si el
                    entorno es más complejo, puedes filtrar por ruta/versión. Con <PowerShellInline
                        code="-ErrorAction Stop"
                    /> convertimos <Enquote>no encontrado</Enquote> en error terminante.
                </ListItem>

                <ListItem icon={icons.ShieldCheck}>
                    <B>Seguridad (PATH hijacking):</B> resolver el binario con <PowerShellInline
                        code="Get-Command"
                    /> y ejecutar su ruta (<PowerShellInline code="$path" />) reduce el riesgo de
                    invocar <I>otro</I> ejecutable con el mismo nombre por manipulación del
                    <Mono>PATH</Mono>.
                </ListItem>

                <ListItem icon={icons.BracketsSquare}>
                    <B>Forzar arreglo con <PowerShellInline code="@()" />:</B> envolver la llamada a
                    <PowerShellInline code="Get-Command" /> en
                    <PowerShellInline code="@(...)" /> garantiza que el resultado sea siempre un
                    arreglo (0, 1 o más elementos). De este modo <PowerShellInline code=".Count" />
                    y la indexación (<PowerShellInline code="$cmds[0]" />) funcionan de forma
                    consistente sin errores sorpresa cuando solo hay un candidato o ninguno.
                </ListItem>

                <ListItem icon={icons.LinkSimple}>
                    <B><PowerShellInline code="[CommandInfo].Source" />:</B> ruta absoluta al
                    binario resuelto (p. ej.,
                    <Mono>C:\Program Files\Git\cmd\git.exe</Mono>). Se usa para invocarlo de forma
                    inequívoca.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <B><PowerShellInline code="[Console]::OutputEncoding" />:</B> establece UTF-8
                    temporalmente para capturar <I>stdout/stderr</I> con caracteres especiales. Se
                    restaura en <PowerShellInline code="finally" /> para no afectar la sesión.
                </ListItem>

                <ListItem icon={icons.Play}>
                    <B>Línea clave: <PowerShellInline code="$out = & $path @Rest 2>&1" />:</B>
                    ejecuta el binario (<PowerShellInline code="&" />), pasa argumentos sin
                    reinterpretarlos (<PowerShellInline code="@Rest" />) y captura <I>stdout</I> +
                    <I>stderr</I> juntos (<PowerShellInline code="2>&1" />).
                </ListItem>

                <ListItem icon={icons.CheckCircle}>
                    <B><PowerShellInline code="$LASTEXITCODE" />:</B> código de salida del proceso
                    nativo. <PowerShellInline code="0" /> = éxito; cualquier otro se trata como
                    error y se eleva con un mensaje detallado. Nota: <PowerShellInline
                        code="$LASTEXITCODE"
                    /> solo aplica a procesos nativos; los cmdlets de PowerShell reportan fallos vía
                    errores, no por exit codes.
                </ListItem>

                <ListItem icon={icons.Siren}>
                    <B><PowerShellInline code="throw [System.Exception]::new($msg)" />:</B> promueve
                    el fallo a error terminante con contexto (comando, argumentos, código y salida),
                    ideal para CI/CD y manejo en niveles superiores con <PowerShellInline
                        code="try"
                    />/<PowerShellInline code="catch" />.
                </ListItem>
            </List>
        </Explanation>

        <More headingLevel="h3">
            <span slot="title">Arreglos en PowerShell</span>

            <P>
                En PowerShell, un <B>arreglo</B> (<PowerShellInline code={`[T[]]`} />) es una
                colección ordenada de elementos. Es, además, la forma “natural” de representar
                <I>cero, uno o muchos</I> resultados: muchos comandos devuelven un arreglo cuando
                hay múltiples valores. Para normalizar, envolver una expresión en <PowerShellInline
                    code="@()"
                /> garantiza que el resultado sea siempre un arreglo (aunque tenga 0 o 1 elemento).
                Declaras un arreglo vacío con <PowerShellInline code="@()" /> o simplemente listando
                valores separados por comas:
            </P>

            <PowerShellBlock
                code={`
                    # Arreglo vacío
                    $empty = @()

                    # Arreglo con valores
                    $tools = @('git', 'curl', 'wget')
                    # O simplemente:
                    $tools = 'git', 'curl', 'wget'

                    # Acceso por índice (base cero)
                    $tools[0]  # 'git'
                    $tools[1]  # 'curl'

                    # Contar elementos
                    $tools.Count  # 3
                `}
            >
                <Fragment slot="title">Sintaxis básica de arreglos</Fragment>
            </PowerShellBlock>

            <P>
                En <PowerShellInline code="Invoke-Tool.ps1" />, el parámetro <PowerShellInline
                    code="$Rest"
                /> es un arreglo de strings (<PowerShellInline code="[string[]]" />) que captura
                todos los argumentos restantes gracias a <PowerShellInline
                    code="ValueFromRemainingArguments"
                />. Luego, <PowerShellInline code="@Rest" /> (splatting) expande ese arreglo como
                argumentos individuales al comando nativo. Esto evita un error común: pasar
                <PowerShellInline code="$Rest" /> sin splatting enviaría el arreglo como <I>un
                    solo</I>
                argumento.
            </P>

            <Important headingLevel="h4">
                Los arreglos son de tamaño fijo; operaciones como <PowerShellInline code={`+=`} />
                crean un nuevo arreglo.
            </Important>
        </More>

        <More headingLevel="h3">
            <span slot="title">Streams de salida en PowerShell</span>

            <P>
                PowerShell no se limita a imprimir texto: maneja múltiples <I
                    href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams"
                >streams de salida</I>, lo que permite separar mensajes de éxito, errores,
                advertencias, depuración, etc. Esto hace posible <Link
                    href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection"
                >redirigirlos</Link> o tratarlos de forma independiente en un mismo script.
            </P>

            <P>
                La idea clave para esta etapa es simple: distinguir entre <B>datos</B> y
                <B>mensajes</B>. En la práctica, devolver objetos (por ejemplo un <PowerShellInline
                    code="[PSCustomObject]"
                />) por el pipeline es equivalente a usar <PowerShellInline code="Write-Output" />.
            </P>

            <P>
                De momento solo nos interesa la <B>idea general</B>: el stream <Mono>1</Mono> se usa
                para la salida normal, y el resto (2–6) sirven para errores, advertencias, mensajes
                verbosos, depuración, etc. El stream <Mono>6</Mono> (Information) es útil para
                mensajes informativos que el consumidor puede mostrar, suprimir o redirigir según su
                configuración. Más adelante veremos con detalle cómo usar
                <PowerShellInline code="Write-Error" /> para <B>propagar errores no terminantes en
                    el pipeline</B>; por ahora nos apoyaremos sobre todo en
                <B>salida estructurada</B> y dejaremos la responsabilidad de <I>imprimir en
                    pantalla</I> a quien consuma estos scripts (otros cmdlets, pipelines o
                herramientas de automatización), que decidirán qué mostrar, cuándo y cómo.
            </P>

            <Table>
                <TableCaption>
                    Streams de PowerShell
                </TableCaption>

                <TableHeader>
                    <TableRow>
                        <TableCell>Stream</TableCell>
                        <TableCell>Descripción</TableCell>
                        <TableCell>Write&nbsp;Cmdlet</TableCell>
                    </TableRow>
                </TableHeader>

                <TableBody>
                    <TableRow>
                        <TableCell>1</TableCell>
                        <TableCell>Éxito (Output)</TableCell>
                        <TableCell><PowerShellInline code="Write-Output" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>2</TableCell>
                        <TableCell>Error</TableCell>
                        <TableCell><PowerShellInline code="Write-Error" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>3</TableCell>
                        <TableCell>Warning</TableCell>
                        <TableCell><PowerShellInline code="Write-Warning" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>4</TableCell>
                        <TableCell>Verbose</TableCell>
                        <TableCell><PowerShellInline code="Write-Verbose" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>5</TableCell>
                        <TableCell>Debug</TableCell>
                        <TableCell><PowerShellInline code="Write-Debug" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>6</TableCell>
                        <TableCell>Information</TableCell>
                        <TableCell><PowerShellInline code="Write-Information" /></TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>n/a</TableCell>
                        <TableCell>Progress</TableCell>
                        <TableCell><PowerShellInline code="Write-Progress" /></TableCell>
                    </TableRow>
                </TableBody>
            </Table>
        </More>
    </NotesSection>

    <Exercise headingLevel="h2">
        <Fragment slot="title">
            Fallback por comando
        </Fragment>

        <Fragment slot="requirements">
            <List>
                <ListItem icon={icons.MagnifyingGlass}>
                    Implementa <PowerShellInline code={`Invoke-WebRequestByFallback.ps1`} /> que
                    intente ejecutar una tarea usando una <I>cadena de alternativas</I> de binarios.
                    No interrogues el sistema operativo; en su lugar, <B>resuelve comandos</B> (con
                    <PowerShellInline code={`Invoke-Tool.ps1`} />) y usa
                    <PowerShellInline code={`try`} />/<PowerShellInline code={`catch`} /> para
                    avanzar al siguiente. La idea es que el comportamiento dependa de la
                    <B>disponibilidad real</B> de herramientas, no del “entorno declarado”
                    (plataforma/versión).
                </ListItem>

                <ListItem icon={icons.DownloadSimple}>
                    Escenario propuesto (puedes elegir otro): <B>descargar un archivo</B> probando
                    primero <Mono>wget</Mono> y luego <Mono>curl</Mono>.
                </ListItem>

                <ListItem icon={icons.CursorClick}>
                    El script debe:
                    <List>
                        <ListItem icon={icons.BracketsCurly}>
                            <B>Interfaz:</B> recibir <PowerShellInline code={`-Uri`} /> y
                            <PowerShellInline code={`-OutFile`} /> (obligatorios).
                        </ListItem>

                        <ListItem icon={icons.ArrowElbowRight}>
                            <B>Estrategia de fallback:</B> intentar <Mono>wget</Mono>; si falla,
                            intentar <Mono>curl</Mono> (en el <PowerShellInline code={`catch`} />).
                        </ListItem>

                        <ListItem icon={icons.Siren}>
                            <B>Fallos explícitos:</B> si ambos fallan, <PowerShellInline
                                code={`throw`}
                            /> con un mensaje consolidado.
                        </ListItem>

                        <ListItem icon={icons.Table}>
                            <B>Contrato de salida:</B> devolver un objeto estructurado con el estado
                            de la operación.
                        </ListItem>

                        <ListItem icon={icons.Target}>
                            <B>Objetivo:</B> la descarga es un pretexto; lo importante es modelar
                            una cadena de alternativas con fallos explícitos y un resultado
                            verificable.
                        </ListItem>
                    </List>
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="notes">
            <Definition headingLevel="h4">
                <PowerShellInline code={`wget`} slot="title" />

                <P>
                    Descargador común en Linux/BSD; puede instalarse en macOS/Windows. Usa
                    <PowerShellInline code="-O" /> para definir el archivo de salida.
                </P>

                <PowerShellBlock
                    code={`
                        # Descargar a un archivo específico
                        wget -O "<OutFile>" "<Uri>"

                        # Ejemplo
                        wget -O "./download/file.txt" "https://example.com/file.txt"
                    `}
                >
                    <Fragment slot="title">Uso básico con <Mono>wget</Mono></Fragment>
                </PowerShellBlock>
            </Definition>

            <Definition headingLevel="h4">
                <PowerShellInline code={`curl`} slot="title" />

                <P>
                    Cliente de transferencia que viene preinstalado en macOS y muchas distros Linux;
                    en Windows 10+ suele estar disponible. Úsalo con <PowerShellInline code="-L" />
                    para seguir redirecciones y
                    <PowerShellInline code="-o" /> para especificar archivo de salida.
                </P>

                <PowerShellBlock
                    code={`
                        # Descargar siguiendo redirecciones
                        curl -L -o "<OutFile>" "<Uri>"

                        # Ejemplo
                        curl -L -o "./download/file.txt" "https://example.com/file.txt"
                    `}
                >
                    <span slot="title">Uso básico con <PowerShellInline code={`curl`} /></span>
                </PowerShellBlock>
            </Definition>
        </Fragment>

        <Fragment slot="use">
            <PowerShellBlock
                code={`
                    $params = @{
                        Uri     = 'https://www.toptal.com/developers/gitignore/api/powershell,windows,linux,macos,visualstudiocode'
                        OutFile = '.gitignore'
                        Verbose = $true
                    }
                    ./Invoke-WebRequestByFallback.ps1 @params
                `}
            >
                <Fragment slot="title">Ejecución</Fragment>
            </PowerShellBlock>
        </Fragment>

        <Fragment slot="hints">
            <List>
                <ListItem icon={icons.LinkSimple}>
                    Usa <PowerShellInline code="Join-Path ... -Resolve" /> para obtener la ruta real
                    de <Mono>Invoke-Tool.ps1</Mono> y fallar temprano si no existe.
                    <PowerShellBlock
                        code={`
                            $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve
                            # Ejemplo de uso con call operator (&) y argumentos:
                            & $invoker wget -O './out.txt' 'https://example.com/file.txt'
                        `}
                    >
                        <Fragment slot="title">Invocador seguro</Fragment>
                        <span slot="footer">
                            <PowerShellInline code="-Resolve" /> valida la ruta en tiempo de inicio;
                            evita fallos tardíos.
                        </span>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.ShieldCheck}>
                    Prefiere tipar <PowerShellInline code="[uri] $Uri" /> y validar el esquema en
                    lugar de
                    <PowerShellInline code={`[string]`} />:
                    <PowerShellBlock
                        code={`
                            [Parameter(Mandatory)]
                            [ValidateScript({ $_.Scheme -in @('http','https') })]
                            [uri] $Uri
                        `}
                    >
                        <Fragment slot="title">Validación de URL robusta</Fragment>
                        <span slot="footer">
                            El tipo <PowerShellInline code={`[uri]`} /> parsea la dirección; el
                            <PowerShellInline code={`[ValidateScript]`} /> asegura <Mono
                            >http/https</Mono>.
                        </span>
                    </PowerShellBlock>
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateScript({ $_.Scheme -in @('http','https') })]
                        [uri] $Uri,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $OutFile
                    )

                    Set-StrictMode -Version 3.0

                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    if ($PSCmdlet.ShouldProcess("$Uri to $OutFile", 'Download file')) {
                        try {
                            & $invoker wget -O $OutFile $Uri
                            [PSCustomObject]@{
                                Uri    = $Uri
                                OutFile = $OutFile
                                Tool   = 'wget'
                                Status = 'Success'
                            }
                        }
                        catch {
                            Write-Warning ('wget failed: {0}' -f $_.Exception.Message)
                            try {
                                & $invoker curl -L -o $OutFile $Uri
                                [PSCustomObject]@{
                                    Uri    = $Uri
                                    OutFile = $OutFile
                                    Tool   = 'curl'
                                    Status = 'Success'
                                }
                            }
                            catch {
                                Write-Warning ('curl failed: {0}' -f $_.Exception.Message)
                                throw [System.Exception]::new("Both wget and curl failed to download $Uri")
                            }
                        }
                    }
                `}
            >
                <Fragment slot="title">Solución de referencia</Fragment>
                <DibsSourceLink
                    repo="scripts" file="operations/Invoke-WebRequestByFallback.ps1"
                    slot="source"
                />
            </PowerShellBlock>
        </Fragment>
    </Exercise>

    <ConclusionsLayout>
        <P slot="conclusions">
            El hilo conductor de esta lección es que, en PowerShell, <B>el manejo de errores es una
                decisión de diseño</B> y una herramienta explícita de <B>control de flujo</B>.
            Cuando la integridad importa, eleva fallos con
            <PowerShellInline code="-ErrorAction Stop" /> y manéjalos con
            <PowerShellInline code="try" />/<PowerShellInline code="catch" />/<PowerShellInline
                code="finally"
            />; cuando buscas reportar sin interrumpir, prefiere errores no terminantes. Al ejecutar
            binarios externos, resuélvelos primero (<PowerShellInline code="Get-Command" />),
            ejecútalos con <PowerShellInline code="&" /> y valida con
            <PowerShellInline code="$LASTEXITCODE" /> o un wrapper como
            <PowerShellInline code={`Invoke-Tool.ps1`} />, devolviendo <B>salida estructurada</B>
            en lugar de texto plano.
        </P>

        <Fragment slot="key-points">
            <ListItem icon={icons.HandPalm}>
                Promueve errores críticos con <PowerShellInline code="-ErrorAction Stop" /> para
                activar <PowerShellInline code={`catch`} /> donde puedas decidir cómo reaccionar.
            </ListItem>

            <ListItem icon={icons.Bug}>
                En <PowerShellInline code={`catch`} />, <PowerShellInline code="$_" /> es el
                <PowerShellInline code={`[ErrorRecord]`} /> (tipo y mensaje en
                <PowerShellInline code={`$_.Exception`} />).
            </ListItem>

            <ListItem icon={icons.MagnifyingGlass}>
                Resuelve binarios con <PowerShellInline code="Get-Command -ErrorAction Stop" /> y
                llama al path real.
            </ListItem>

            <ListItem icon={icons.Play}>
                Ejecuta con <PowerShellInline code="&" /> y valida con
                <PowerShellInline code="$LASTEXITCODE" /> (o tu wrapper).
            </ListItem>

            <ListItem icon={icons.ArrowsLeftRight}>
                <PowerShellInline code="2>&1" /> mezcla <I>stderr</I> en <I>stdout</I> para capturar
                todo en una variable cuando te convenga simplificar el flujo.
            </ListItem>
        </Fragment>

        <P slot="takeaways">
            <B>El buen manejo de errores es diseño, no accidente.</B> Elevar fallos a terminantes,
            envolver herramientas externas y devolver objetos no es “ser más estricto”: es ser
            <B>más predecible</B>. Si registras con intención, priorizas la salida estructurada
            sobre el texto suelto y <I><Enquote>fail loudly</Enquote></I> cuando corresponde, tus
            scripts serán más confiables, portables y fáciles de mantener.
        </P>
    </ConclusionsLayout>

    <LinksLayout title="Comparativas y otros ecosistemas">
        <NushellLink />
    </LinksLayout>

    <References>
        <Fragment slot="recommended">
            <Book
                chapter="Handling errors"
                bookTitle="Learn PowerShell in a Month of Lunches, fourth edition: Covers Windows, Linux, and MacOS"
                pages={[279, 286]}
            >
                <AuthorList slot="authors" authors={[{ firstName: "Travis", lastName: "Plunk" }]} />

                <span slot="description">
                    Capítulo práctico sobre manejo de errores en PowerShell que explica la
                    diferencia entre errores no terminantes y excepciones, cómo forzar excepciones
                    con <PowerShellInline code="-ErrorAction Stop" />
                    para poder capturarlas con
                    <PowerShellInline code="try" />/<PowerShellInline
                        code="catch"
                    />/<PowerShellInline code="finally" />, y el papel de <PowerShellInline
                        code="$Error"
                    />, <PowerShellInline code="-ErrorVariable" />
                    (incluyendo el uso de <PowerShellInline code="+" /> para acumular) y
                    <PowerShellInline code="$ErrorActionPreference" />. Advierte contra malas
                    prácticas como silenciar errores globalmente, y muestra cuándo registrar,
                    continuar o detener según el objetivo del script. Incluye patrones para comandos
                    nativos y métodos .NET (cuándo ajustar temporalmente las preferencias), y
                    ejemplos de <PowerShellInline code="catch" /> tipados. Ideal para entender qué
                    registrar, cómo reaccionar ante fallos y cómo diseñar herramientas que fallen de
                    forma explícita y depurable.
                </span>
            </Book>
        </Fragment>

        <Fragment slot="additional">
            <Book
                chapter="Errors and exceptions"
                bookTitle="Windows PowerShell in Action, Third Edition"
                pages={[531, 562]}
            >
                <AuthorList
                    slot="authors"
                    authors={[
                        {
                            firstName: "Bruce",
                            lastName: "Payette",
                            url: "https://www.goodreads.com/author/show/441636.Bruce_Payette",
                        },
                        {
                            firstName: "Richard",
                            lastName: "Siddaway",
                            url: "https://www.goodreads.com/author/show/4742136.Richard_Siddaway",
                        },
                    ]}
                />

                <Fragment slot="description">
                    Capítulo estructurado sobre el sistema de manejo de errores de PowerShell como
                    herramienta de <B>automatización crítica</B>. Explica la distinción fundamental
                    entre errores <B>terminantes</B> (que interrumpen el flujo) y <B>no
                        terminantes</B> (que continúan pero registran fallos), alineados con el
                    modelo de streaming de PowerShell. Cubre objetos <PowerShellInline
                        code="ErrorRecord"
                    /> con sus propiedades ricas (<Mono>Exception</Mono>,
                    <Mono>TargetObject</Mono>, <Mono>CategoryInfo</Mono>, <Mono
                    >InvocationInfo</Mono>), cómo capturar errores usando redirección
                    (<PowerShellInline code="2>&1" />), el parámetro <PowerShellInline
                        code="-ErrorVariable"
                    />, y variables de estado (<PowerShellInline code="$?" />, <PowerShellInline
                        code="$LASTEXITCODE"
                    />). Incluye patrones para diagnosticar y gestionar errores en scripts,
                    especialmente útil para entender cuándo un fallo debe detener la ejecución y
                    cuándo debe reportarse sin interrumpir un pipeline.
                </Fragment>
            </Book>

            <WebPage
                title="about_Redirection"
                url="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection"
            >
                <Link href="https://learn.microsoft.com/en-us/powershell" slot="location"
                >la documentación oficial de PowerShell</Link>
                <Fragment slot="description">
                    Breve guía de <B>redirección en PowerShell</B>: explica cómo enviar salida a
                    archivos y combinar flujos (éxito, error, warning, etc.) usando
                    <PowerShellInline code={`Out-File`} />,
                    <PowerShellInline code={`Tee-Object`} /> y <B>operadores de redirección</B>
                    (<PowerShellInline code={`>`} />, <PowerShellInline code={`>>`} />,
                    <PowerShellInline code={`n>&1`} />, <PowerShellInline code={`*>`} />). Incluye
                    tabla de flujos redireccionables, cambios en <B>PowerShell&nbsp;7.4</B> para
                    redirigir
                    <I>stdout</I> de comandos nativos (conservando bytes), ejemplos prácticos
                    (fusionar
                    <PowerShellInline code={`2>&1`} />, redirigir todos los flujos, suprimir <I
                    >Information/Host</I>), efectos de <I>Action Preferences</I>, consideraciones de
                    <I>codificación y ancho</I> de salida, y notas sobre confusiones comunes con
                    <PowerShellInline code={`>`} /> vs. comparadores (<PowerShellInline
                        code={`-gt`}
                    />, <PowerShellInline code={`-lt`} />).
                </Fragment>
            </WebPage>

            <WebPage
                title="about_Try_Catch_Finally"
                url="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_try_catch_finally"
            >
                <Link href="https://learn.microsoft.com/en-us/powershell" slot="location"
                >la documentación oficial de PowerShell</Link>

                <Fragment slot="description">
                    Descripción formal de cómo <B>usar <PowerShellInline
                            code="try"
                        />/<PowerShellInline code="catch" />/<PowerShellInline code="finally" />
                        para manejar errores terminantes</B>
                    en PowerShell. Presenta la sintaxis general de los bloques, muestra cómo
                    envolver código que puede fallar, cómo disponer de varios bloques
                    <PowerShellInline code="catch" /> (genéricos y tipados) y en qué orden se
                    evalúan, y explica qué ocurre con las excepciones no capturadas. Detalla la
                    relación con <PowerShellInline code="trap" /> y con las preferencias de error,
                    cómo acceder a la información de la excepción vía <PowerShellInline
                        code="$_"
                    />/<PowerShellInline code="$PSItem" /> y las propiedades de
                    <PowerShellInline code="[ErrorRecord]" /> (<Mono>CategoryInfo</Mono>,
                    <Mono>TargetObject</Mono>, etc.), y cómo usar <PowerShellInline
                        code="finally"
                    /> para liberar recursos o dejar el sistema en un estado consistente. Incluye
                    ejemplos prácticos y notas sobre buenas prácticas para escribir bloques
                    <PowerShellInline code="catch" /> claros y seguros.
                </Fragment>
            </WebPage>
        </Fragment>
    </References>
</NotesLayout>
