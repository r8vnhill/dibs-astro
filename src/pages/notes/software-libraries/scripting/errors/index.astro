---
import * as icons from "~/assets/img/icons";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import {
    TableBody,
    TableCaption,
    TableCell,
    TableHeader,
    TableRow,
} from "~/components/starwind/table";
import Table from "~/components/starwind/table/Table.astro";
import {
    Abstract,
    Definition,
    Exercise,
    Explanation,
    Info,
    More,
    Question,
} from "~/components/ui/callouts";
import { PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { Mono } from "~/components/ui/font";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, Book, References, WebPage } from "~/components/ui/references";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Manejo de errores terminantes en PowerShell"
    description="Guía práctica de manejo de errores terminantes en PowerShell: promover fallos a terminantes con -ErrorAction Stop, capturarlos con try/catch/finally y ejecutar comandos externos de forma segura con Get-Command. Mencionamos errores no terminantes solo como contraste; los veremos más adelante con el pipeline."
    timeMultiplier={1.5} git={{ user: "r8vnhill", repo: "dibs-scripts" }}
>
    <Abstract>
        <P>
            Esta lección enseña a <B>controlar el flujo con errores terminantes</B> en PowerShell:
            promover fallos con
            <PowerShellInline code="-ErrorAction Stop" />, capturarlos con
            <PowerShellInline code="try" />/<PowerShellInline code="catch" />/<PowerShellInline
                code="finally"
            /> y registrar resultados de forma clara mediante salida estructurada. Esta lección se
            centra en <B>errores terminantes</B>. Los <I>no terminantes</I> se mencionan solo para
            contraste: no detienen el flujo y sirven principalmente para reportar advertencias; los
            veremos en detalle más adelante cuando trabajemos con el <I>pipeline</I>, donde cobran
            mayor relevancia.
        </P>

        <P>
            Se introduce un <B>patrón para ejecutar comandos externos de forma segura</B>: resolver
            el binario real con
            <PowerShellInline code="Get-Command" />, invocarlo con <PowerShellInline code="&" />,
            capturar salida/errores (<PowerShellInline code="2>&1" />), validar <PowerShellInline
                code="$LASTEXITCODE"
            /> y elevar con contexto si falla (p. ej., wrapper <PowerShellInline
                code="Invoke-Tool.ps1"
            />). El ejercicio propone practicar estos conceptos implementando un <I>fallback</I>
            simple entre dos comandos de descarga.
        </P>
    </Abstract>

    <NotesSection id="h2-terminating-errors">
        <Heading
            headingLevel="h2" Icon={icons.Warning}
            slot="heading"
        >
            Errores terminantes
        </Heading>

        <P>
            En un shell orientado a automatización y pipelines como PowerShell, no todos los fallos
            deben detener la ejecución: a menudo procesas <B>muchos elementos</B> (archivos, filas,
            recursos remotos) y necesitas <B>registrar errores por ítem</B> sin abortar el lote
            completo (errores <I>no terminantes</I>). En cambio, cuando una operación es crítica (p.
            ej., escribir/borrar datos relevantes), conviene <B>elevar el error a terminante</B>
            para detener el flujo y manejarlo con <PowerShellInline code="try" />/<PowerShellInline
                code="catch"
            />. PowerShell modela explícitamente esta distinción y te da controles como
            <PowerShellInline code="-ErrorAction" /> y <PowerShellInline
                code="$ErrorActionPreference"
            /> para <B>escalar</B> fallos no terminantes a terminantes cuando lo requiera el guion,
            mientras que <PowerShellInline code="try" />/<PowerShellInline code="catch" /> solo
            captura errores <B>terminantes</B>. Esto permite equilibrar <B>robustez en lote</B> y <B
            >seguridad en operaciones críticas</B> dentro del mismo lenguaje.
        </P>

        <Definition headingLevel="h3">
            <Fragment slot="title">
                Error <B>no</B> terminante
            </Fragment>

            <P>
                Un <B>error no terminante</B> registra la falla pero <I>continúa</I> la ejecución.
                Es útil cuando procesas un conjunto de elementos y quieres obtener un reporte de qué
                funcionó y qué falló, sin detener todo ante el primer error. Solo lo mencionamos
                aquí como contexto; lo veremos con más detalle cuando abordemos el <I>pipeline</I>,
                donde resulta especialmente relevante.
            </P>
        </Definition>

        <Definition headingLevel="h3">
            <Fragment slot="title">Error terminante</Fragment>

            <P>
                Un <B>error terminante</B> <I>interrumpe</I> inmediatamente el flujo. Úsalo cuando
                la operación es crítica (crear/escribir/borrar datos relevantes, cambios de estado,
                CI/CD), promoviendo fallos con
                <PowerShellInline code="-ErrorAction Stop" /> y manejándolos con <PowerShellInline
                    code="try"
                />/<PowerShellInline code="catch" />/<PowerShellInline code="finally" />.
            </P>
        </Definition>

        <P>
            Este ejemplo implementa una copia <B>segura</B> con <PowerShellInline
                code="ShouldProcess"
            /> y elevación de errores a <I>terminantes</I> para capturarlos con
            <PowerShellInline code="catch" />. El bloque <PowerShellInline code="finally" /> siempre
            devuelve un objeto con <I>estado</I> de la operación.
        </P>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5 
                [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ })]
                    # [!code focus:1]
                    [string] $Source,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [ValidateScript({ Test-Path -LiteralPath $_ -PathType Container })]
                    # [!code focus:1]
                    [string] $Destination,

                    [switch] $Recurse
                )

                Set-StrictMode -Version 3.0

                # [!code focus:6]
                $result = @{
                    Source      = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Source)
                    Destination = $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Destination)
                }
                $result.Target = Join-Path $result.Destination (Split-Path -Leaf $result.Source)

                # [!code focus:1]
                try {
                    $shouldProcess = $PSCmdlet.ShouldProcess($result.Source, 'Copy to {0}' -f $result.Destination)
                    # [!code focus:2]
                    if ($shouldProcess) {
                        if (Test-Path -LiteralPath $result.Target) {
                            # [!code focus:2]
                            $result.Status = 'Skipped'
                            $result.Reason = ('Target already exists: {0}' -f $result.Target)
                        }
                        # [!code focus:1]
                        else {
                            $copyParams = @{
                                LiteralPath = $result.Source
                                Destination = $result.Destination
                                Recurse     = $Recurse
                                # [!code focus:1]
                                ErrorAction = 'Stop'
                            }

                            # [!code focus:2]
                            Copy-Item @copyParams
                            $result.Status = 'Copied'
                        }
                    }
                    # [!code focus:3]
                    else {
                        # Make cancellation explicit so callers don't need to infer it from missing Status
                        $result.Status = 'Cancelled'
                        $result.Reason = 'ShouldProcess returned False (confirmation declined or -WhatIf)'
                    }
                }
                # [!code focus:1]
                catch {
                    $result.Status = 'Failed'
                    # [!code focus:4]
                    $result.Error = [PSCustomObject]@{
                        Kind    = $_.Exception.GetType().Name
                        Message = $_.Exception.Message
                    }
                }
                # [!code focus:1]
                finally {
                    [PSCustomObject]$result
                }
            `}
        >
            <Fragment slot="title"
            >Copia segura con <Mono>ShouldProcess</Mono> y salida estructurada</Fragment>
            <DibsSourceLink
                repo="scripts" file="operations/Copy-ItemStrict.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.Path}>
                    <B>Rutas normalizadas y destino final:</B>
                    <PowerShellInline code="$PSCmdlet.GetUnresolvedProviderPathFromPSPath()" />
                    resuelve rutas absolutas; <PowerShellInline
                        code="Join-Path ... (Split-Path -Leaf ...)"
                    /> compone el <Mono>Target</Mono>.
                </ListItem>

                <ListItem icon={icons.Package}>
                    <B>Validación temprana:</B> <PowerShellInline
                        code="[ValidateScript({ Test-Path ... })]"
                    />
                    asegura que el origen existe y que el destino es un contenedor.
                </ListItem>

                <ListItem icon={icons.HandPalm}>
                    <B><PowerShellInline code="-ErrorAction Stop" />:</B> promueve fallos de
                    <PowerShellInline code="Copy-Item" /> a <I>terminantes</I> para entrar en
                    <PowerShellInline code="catch" />.
                </ListItem>

                <ListItem icon={icons.Table}>
                    <B>Salida estructurada:</B> en <PowerShellInline code="finally" /> devolvemos
                    <PowerShellInline code="$result" /> con <Mono>Source/Destination/Target</Mono>,
                    <Mono>Status</Mono> y, cuando aplica, <Mono>Reason</Mono> o <Mono>Error</Mono>.
                </ListItem>
            </List>
        </Explanation>

        <Info headingLevel="h3">
            <span slot="title">Uso</span>

            <P>
                Ejecuta el script desde la terminal pasando un archivo y una carpeta destino:
            </P>

            <PowerShellBlock
                code={`
                    # Preparación mínima
                    $dest = 'backup'
                    if (!(Test-Path -LiteralPath $dest)) {
                        New-Item -ItemType Directory -Path $dest
                    }

                    # Ensayo con -WhatIf -> 'Cancelled'
                    $w = ./Copy-ItemStrict.ps1 -Source './Copy-ItemStrict.ps1' -Destination $dest -WhatIf
                    $w.Status
                    $w.Reason

                    # Copia real -> 'Copied' (primera vez) o 'Skipped'
                    $r = ./Copy-ItemStrict.ps1 -Source './Copy-ItemStrict.ps1' -Destination $dest
                    $r.Status
                    $r.Target
                `}
            >
                <Fragment slot="title">Usar y leer el resultado (breve, sin pipeline)</Fragment>
            </PowerShellBlock>
        </Info>

        <Question headingLevel="h4">
            <List>
                <ListItem icon={icons.Play}
                >Repite la copia para observar <Mono>Skipped</Mono> y el <Mono
                    >Reason</Mono>.</ListItem>
                <ListItem icon={icons.Folder}
                >Intenta copiar una carpeta sin <Mono>-Recurse</Mono> para ver <Mono>Failed</Mono> y
                    leer <Mono>Error.Kind</Mono>/<Mono>Error.Message</Mono>.</ListItem>
            </List>
        </Question>

        <More headingLevel="h4">
            <span slot="title">Esquema de salida y estabilidad</span>

            <P>
                Cuando se <I>omite</I>, <I>copia</I> o <I>falla</I>, el ejemplo adjunta
                <Mono>Status</Mono> y, según el caso, <Mono>Reason</Mono> o <Mono>Error</Mono>. Si
                <PowerShellInline code="ShouldProcess" /> es rechazado (confirmación o
                <PowerShellInline code="-WhatIf" />), aquí marcamos <Mono>Cancelled</Mono> de forma
                explícita. Una alternativa más simple es devolver solo el objeto base (<Mono
                >Source/Destination/Target</Mono>) sin <Mono>Status</Mono>, pero eso <B>varía el
                    esquema</B> entre ramas.
            </P>

            <P>
                Decide qué prefieres para tus consumidores: un esquema <B>estable/tabular</B>
                (mismas propiedades siempre, ideal para filtrar/seleccionar en pipeline) o uno más
                <B>flexible/JSON</B> (propiedades opcionales según el caso). En estas notas <I
                >todavía no trabajamos con el pipeline</I>, así que priorizamos claridad y registro
                por sobre la rigidez del esquema.
            </P>

            <P>
                Nota: al construir con <Mono>@{}</Mono> (<I>hashtable</I>) se puede <I>perder el
                    orden</I> de propiedades; si necesitas orden estable (p. ej., para salida
                tabular), puedes crear un <PowerShellInline code="[PSCustomObject]" /> desde el
                comienzo y agregar propiedades con <PowerShellInline code="Add-Member" />. Aquí
                elegimos la opción más simple con fines ilustrativos.
            </P>
        </More>

        <More headingLevel="h4">
            <span slot="title"><PowerShellInline code="catch" /> tipado</span>

            <P>
                Puedes definir varios bloques <PowerShellInline code={`catch`} /> para distintos
                tipos de excepción y cerrar con uno genérico. Ordénalos de los más específicos a los
                más generales.
            </P>

            <PowerShellBlock
                code={`
                    try {
                        Copy-Item @copyParams
                    }
                    catch [System.UnauthorizedAccessException] {
                        Write-Warning ('Permisos insuficientes: {0}' -f $_.Exception.Message)
                    }
                    catch [System.IO.IOException] {
                        Write-Warning ('Problema de E/S: {0}' -f $_.Exception.Message)
                    }
                    catch {
                        Write-Warning ('Error {0}: {1}' -f $_.Exception.GetType().Name, $_.Exception.Message)
                    }
                `}
            >
                <Fragment slot="title">Orden de <Mono>catch</Mono> y uso práctico</Fragment>
            </PowerShellBlock>

            <P>
                En PowerShell es común incluir un <PowerShellInline code={`catch`} /> genérico
                porque muchos cmdlets encapsulan las excepciones .NET dentro de objetos
                <PowerShellInline code={`[ErrorRecord]`} />, cuyas categorías o tipos varían entre
                proveedores. Esto dificulta predecir el tipo exacto, por lo que un bloque genérico
                suele ser una red de seguridad útil. Aun así, cuando anticipes escenarios típicos
                (permisos, E/S), añade <PowerShellInline code={`catch`} /> tipados para mensajes más
                claros.
            </P>

            <P>
                En este apunte usaremos principalmente <PowerShellInline code={`catch`} /> genéricos
                para simplificar los ejemplos, aunque en contextos reales conviene combinar ambos
                tipos según el grado de control y legibilidad que busques.
            </P>
        </More>
    </NotesSection>

    <NotesSection id="h2-verify-external-commands">
        <Heading
            headingLevel="h2" Icon={icons.MagnifyingGlass}
            slot="heading"
        >
            Verificar y ejecutar comandos externos con seguridad
        </Heading>

        <P>
            Patrón simple: resolver el binario real con <PowerShellInline code="Get-Command" />,
            ejecutarlo con el <I>call operator</I> <PowerShellInline code="&" />, y validar
            <PowerShellInline code="$LASTEXITCODE" />. Devuelve un objeto con datos útiles para logs
            o para controlar el flujo.
        </P>

        <PowerShellBlock
            code={`
            #Requires -Version 7.5
            [CmdletBinding()]
            param(
                [Parameter(Mandatory)]
                [ValidateNotNullOrWhiteSpace()]
                [string] $Name,

                # [!code focus:3]
                [Parameter(ValueFromRemainingArguments)]
                [ValidateNotNull()]
                [string[]] $Rest = @()
            )

            Set-StrictMode -Version 3.0

            # [!code focus:1]
            $cmds = Get-Command -Name $Name -CommandType Application -ErrorAction Stop
            if ($cmds.Count -gt 1) {
                Write-Warning ("Multiple executables named '{0}' were found. Using: {1}" -f 
                    $Name, $cmds[0].Source)
            }
            $path = $cmds[0].Source

            $originalEncoding = [Console]::OutputEncoding
            try {
                [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
                $out = & $path @Rest 2>&1
            }
            finally {
                [Console]::OutputEncoding = $originalEncoding
            }

            if ($LASTEXITCODE -eq 0) {
                [PSCustomObject]@{
                    ToolPath = $path
                    ExitCode = $LASTEXITCODE
                    Output   = $out
                }
            }
            else {
                $nl = [Environment]::NewLine
                $msg = ('{0} {1} returned exit code {2}.{3}Output:{3}{4}' -f $Name, ($Rest -join ' '), 
                    $LASTEXITCODE, $nl, ($out -join $nl))
                throw [System.Exception]::new($msg)
            }
        `}
        >
            <Fragment slot="title">Wrapper seguro para comandos externos</Fragment>
            <DibsSourceLink
                repo="scripts" file="tools/Invoke-Tool.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "Aquí voy, tengo que agregar una explicación breve sobre arreglos",
                ],
            }}
        />

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.ArrowElbowRight}>
                    <B><PowerShellInline code="ValueFromRemainingArguments" />:</B> todo lo que
                    quede después de
                    <PowerShellInline code="-Name" /> se captura en <PowerShellInline
                        code="$Rest"
                    /> <I>sin intentar parsearlo como parámetros del script</I>. Así puedes pasar
                    flags arbitrarios al binario:
                    <PowerShellInline code="Invoke-Tool -Name git -C . status --porcelain" />.
                </ListItem>

                <ListItem icon={icons.MagnifyingGlass}>
                    <B><PowerShellInline code="Get-Command ... -ErrorAction Stop" />:</B> resuelve
                    el ejecutable real (solo de tipo <I>Application</I>). Con <PowerShellInline
                        code="-ErrorAction Stop"
                    /> convertimos
                    <Enquote>no encontrado</Enquote> en error terminante. El objeto devuelto es
                    <PowerShellInline code="[System.Management.Automation.CommandInfo]" />.
                </ListItem>

                <ListItem icon={icons.LinkSimple}>
                    <B><PowerShellInline code="[CommandInfo].Source" />:</B> ruta absoluta al
                    binario resuelto (p. ej.,
                    <Mono>C:\Program Files\Git\cmd\git.exe</Mono>). Se usa para invocarlo de forma
                    inequívoca.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <B><PowerShellInline code="[Console]::OutputEncoding" />:</B> establece UTF-8
                    temporalmente para capturar <I>stdout/stderr</I> con caracteres especiales. Se
                    restaura en <PowerShellInline code="finally" /> para no afectar la sesión.
                </ListItem>

                <ListItem icon={icons.Play}>
                    <B>Línea clave: <PowerShellInline code="$out = & $path @Rest 2>&1" />:</B>
                    <List>
                        <ListItem icon={icons.ArrowRight}>
                            <I>call operator</I> <PowerShellInline code="&" /> ejecuta el binario.
                        </ListItem>

                        <ListItem icon={icons.BracketsCurly}>
                            Splatting <PowerShellInline code="@Rest" /> pasa los argumentos tal cual
                            (array → args).
                        </ListItem>

                        <ListItem icon={icons.ArrowsLeftRight}>
                            <B><PowerShellInline code="2>&1" />:</B> combina los flujos de salida
                            estándar (<I>stdout</I>) y error estándar (<I>stderr</I>) en uno solo.
                            En PowerShell (y en sistemas heredados de Unix), los números representan
                            los <I>streams</I>:
                            <List>
                                <ListItem icon={icons.NumberCircleOne}>
                                    <PowerShellInline code="1" /> → salida estándar (<I>stdout</I>),
                                    lo que normalmente imprime el programa.
                                </ListItem>

                                <ListItem icon={icons.NumberCircleTwo}>
                                    <PowerShellInline code="2" /> → salida de error (<I>stderr</I>),
                                    donde van los mensajes de error.
                                </ListItem>

                                <ListItem icon={icons.CaretRight}>
                                    <PowerShellInline code=">" /> redirige la salida hacia otro
                                    destino, y
                                    <PowerShellInline code="&" /> indica que ese destino es otro
                                    flujo.
                                </ListItem>
                            </List>

                            Por lo tanto, <PowerShellInline code="2>&1" /> significa literalmente
                            <I><Enquote>redirige el flujo 2 (errores) al mismo lugar que el flujo 1
                                    (salida estándar)</Enquote></I>, lo que permite capturar todo
                            (mensajes y errores) en la misma variable <PowerShellInline
                                code="$out"
                            />.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.CheckCircle}>
                    <B><PowerShellInline code="$LASTEXITCODE" />:</B> código de salida del proceso
                    nativo.
                    <PowerShellInline code="0" /> = éxito; cualquier otro se trata como error y se
                    eleva con un mensaje detallado.
                </ListItem>

                <ListItem icon={icons.Siren}>
                    <B><PowerShellInline code="throw [System.Exception]::new($msg)" />:</B> promueve
                    el fallo a error terminante con contexto (comando, argumentos, código y salida),
                    ideal para CI/CD y manejo en niveles superiores con <PowerShellInline
                        code="try"
                    />/<PowerShellInline code="catch" />.
                </ListItem>
            </List>
        </Explanation>

        <More headingLevel="h3">
            <span slot="title">Streams de salida en PowerShell</span>

            <P>
                PowerShell no se limita a imprimir texto: maneja múltiples <I
                    href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams"
                >streams de salida</I>, lo que permite separar mensajes de éxito, errores,
                advertencias, depuración, etc. Esto hace posible <Link
                    href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection"
                >redirigirlos</Link> o tratarlos de forma independiente en un mismo script.
            </P>

            <P>
                En particular, <PowerShellInline code="Write-Error" /> escribe en el <I>error
                    stream</I> (2), lo que puede interrumpir pipelines o marcar la ejecución como
                fallida. En estos apuntes evitaremos usarlo para no introducir demasiados conceptos
                nuevos, y en su lugar preferiremos <PowerShellInline code="Write-Warning" /> o
                <PowerShellInline code="Write-Verbose" />. Sin embargo, es importante conocer que
                existe y que forma parte del sistema de streams.
            </P>

            <Table>
                <TableCaption>
                    Streams de PowerShell
                </TableCaption>

                <TableHeader>
                    <TableRow>
                        <TableCell>
                            Stream
                        </TableCell>

                        <TableCell>
                            Descripción
                        </TableCell>

                        <TableCell>
                            Write&nbsp;Cmdlet
                        </TableCell>
                    </TableRow>
                </TableHeader>

                <TableBody>
                    <TableRow>
                        <TableCell>
                            1
                        </TableCell>

                        <TableCell>
                            Éxito (Output)
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Output" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            2
                        </TableCell>

                        <TableCell>
                            Error
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Error" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            3
                        </TableCell>

                        <TableCell>
                            Warning
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Warning" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            4
                        </TableCell>

                        <TableCell>
                            Verbose
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Verbose" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            5
                        </TableCell>

                        <TableCell>
                            Debug
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Debug" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            6
                        </TableCell>

                        <TableCell>
                            Information
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Information" />
                        </TableCell>
                    </TableRow>

                    <TableRow>
                        <TableCell>
                            n/a
                        </TableCell>

                        <TableCell>
                            Progress
                        </TableCell>

                        <TableCell>
                            <PowerShellInline code="Write-Progress" />
                        </TableCell>
                    </TableRow>
                </TableBody>
            </Table>
        </More>
    </NotesSection>

    <Exercise headingLevel="h2">
        <Fragment slot="title">
            Fallback por comando
        </Fragment>

        <Fragment slot="requirements">
            <List>
                <ListItem icon={icons.MagnifyingGlass}>
                    Implementa <PowerShellInline code={`Invoke-WebRequestByFallback.ps1`} /> que
                    intente ejecutar una tarea usando una <I>cadena de alternativas</I> de binarios.
                    No interrogues el sistema operativo; en su lugar, <B>resuelve comandos</B> (con
                    <PowerShellInline code={`Invoke-Tool.ps1`} />) y usa
                    <PowerShellInline code={`try`} />/<PowerShellInline code={`catch`} /> para
                    avanzar al siguiente.
                </ListItem>

                <ListItem icon={icons.DownloadSimple}>
                    Escenario propuesto (puedes elegir otro): <B>descargar un archivo</B> probando
                    primero <Mono>wget</Mono> y luego <Mono>curl</Mono>.
                </ListItem>

                <ListItem icon={icons.CursorClick}>
                    El script debe:
                    <List>
                        <ListItem icon={icons.LinkSimple}>
                            Recibir <PowerShellInline code={`-Uri`} /> (obligatorio) y
                            <PowerShellInline code={`-OutFile`} /> (obligatorio).
                        </ListItem>

                        <ListItem icon={icons.HandPalm}>
                            Probar <Mono>wget</Mono> dentro de <PowerShellInline
                                code={`try`}
                            />/<PowerShellInline code={`catch`} /> con <PowerShellInline
                                code={`-ErrorAction Stop`}
                            />.
                        </ListItem>

                        <ListItem icon={icons.ArrowElbowRight}>
                            Si <Mono>wget</Mono> falla, capturar el error y probar <Mono>curl</Mono>
                            en el bloque
                            <PowerShellInline code={`catch`} /> (anidando otro <PowerShellInline
                                code={`try`}
                            />).
                        </ListItem>

                        <ListItem icon={icons.Siren}>
                            Si ambos fallan, <PowerShellInline code={`throw`} /> con un mensaje
                            consolidado.
                        </ListItem>

                        <ListItem icon={icons.Table}>
                            Devuelve un objeto estructurado con el estado de la operación.
                        </ListItem>
                    </List>
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="notes">
            <Definition headingLevel="h4">
                <PowerShellInline code={`wget`} slot="title" />

                <P>
                    Descargador común en Linux/BSD; puede instalarse en macOS/Windows. Usa
                    <PowerShellInline code="-O" /> para definir el archivo de salida.
                </P>

                <PowerShellBlock
                    code={`
                        # Descargar a un archivo específico
                        wget -O "<OutFile>" "<Uri>"

                        # Ejemplo
                        wget -O "./download/file.txt" "https://example.com/file.txt"
                    `}
                >
                    <Fragment slot="title">Uso básico con <Mono>wget</Mono></Fragment>
                </PowerShellBlock>
            </Definition>

            <Definition headingLevel="h4">
                <PowerShellInline code={`curl`} slot="title" />

                <P>
                    Cliente de transferencia que viene preinstalado en macOS y muchas distros Linux;
                    en Windows 10+ suele estar disponible. Úsalo con <PowerShellInline code="-L" />
                    para seguir redirecciones y
                    <PowerShellInline code="-o" /> para especificar archivo de salida.
                </P>

                <PowerShellBlock
                    code={`
                        # Descargar siguiendo redirecciones
                        curl -L -o "<OutFile>" "<Uri>"

                        # Ejemplo
                        curl -L -o "./download/file.txt" "https://example.com/file.txt"
                    `}
                >
                    <span slot="title">Uso básico con <PowerShellInline code={`curl`} /></span>
                </PowerShellBlock>
            </Definition>
        </Fragment>

        <Fragment slot="use">
            <PowerShellBlock
                code={`
                    $params = @{
                        Uri     = 'https://www.toptal.com/developers/gitignore/api/powershell,windows,linux,macos,visualstudiocode'
                        OutFile = '.gitignore'
                        Verbose = $true
                    }
                    ./Invoke-WebRequestByFallback.ps1 @params
                `}
            >
                <Fragment slot="title">Ejecución</Fragment>
            </PowerShellBlock>
        </Fragment>

        <Fragment slot="hints">
            <List>
                <ListItem icon={icons.LinkSimple}>
                    Usa <PowerShellInline code="Join-Path ... -Resolve" /> para obtener la ruta real
                    de <Mono>Invoke-Tool.ps1</Mono> y fallar temprano si no existe.
                    <PowerShellBlock
                        code={`
                            $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve
                            # Ejemplo de uso con call operator (&) y argumentos:
                            & $invoker wget -O './out.txt' 'https://example.com/file.txt'
                        `}
                    >
                        <Fragment slot="title">Invocador seguro</Fragment>
                        <span slot="footer">
                            <PowerShellInline code="-Resolve" /> valida la ruta en tiempo de inicio;
                            evita fallos tardíos.
                        </span>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.ShieldCheck}>
                    Prefiere tipar <PowerShellInline code="[uri] $Uri" /> y validar el esquema en
                    lugar de
                    <PowerShellInline code={`[string]`} />:
                    <PowerShellBlock
                        code={`
                            [Parameter(Mandatory)]
                            [ValidateScript({ $_.Scheme -in @('http','https') })]
                            [uri] $Uri
                        `}
                    >
                        <Fragment slot="title">Validación de URL robusta</Fragment>
                        <span slot="footer">
                            El tipo <PowerShellInline code={`[uri]`} /> parsea la dirección; el
                            <PowerShellInline code={`[ValidateScript]`} /> asegura <Mono
                            >http/https</Mono>.
                        </span>
                    </PowerShellBlock>
                </ListItem>
            </List>
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateScript({ $_.Scheme -in @('http','https') })]
                        [uri] $Uri,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $OutFile
                    )

                    Set-StrictMode -Version 3.0

                    $invoker = Join-Path $PSScriptRoot '..' 'tools' 'Invoke-Tool.ps1' -Resolve

                    if ($PSCmdlet.ShouldProcess("$Uri to $OutFile", 'Download file')) {
                        try {
                            & $invoker wget -O $OutFile $Uri
                            [PSCustomObject]@{
                                Uri    = $Uri
                                OutFile = $OutFile
                                Tool   = 'wget'
                                Status = 'Success'
                            }
                        }
                        catch {
                            Write-Warning ('wget failed: {0}' -f $_.Exception.Message)
                            try {
                                & $invoker curl -L -o $OutFile $Uri
                                [PSCustomObject]@{
                                    Uri    = $Uri
                                    OutFile = $OutFile
                                    Tool   = 'curl'
                                    Status = 'Success'
                                }
                            }
                            catch {
                                Write-Warning ('curl failed: {0}' -f $_.Exception.Message)
                                throw [System.Exception]::new("Both wget and curl failed to download $Uri")
                            }
                        }
                    }
                `}
            >
                <Fragment slot="title">Solución de referencia</Fragment>
                <DibsSourceLink
                    repo="scripts" file="operations/Invoke-WebRequestByFallback.ps1"
                    slot="source"
                />
            </PowerShellBlock>
        </Fragment>
    </Exercise>

    <ConclusionsLayout>
        <P slot="conclusions">
            El hilo conductor de la lección es <B>controlar el flujo a través de los errores</B>.
            Cuando la integridad importa, promueve fallos con <PowerShellInline
                code="-ErrorAction Stop"
            /> y manéjalos con
            <PowerShellInline code="try" />/<PowerShellInline code="catch" />/<PowerShellInline
                code="finally"
            />; cuando buscas reportar sin interrumpir, usa errores no terminantes. Al ejecutar
            binarios externos, resuélvelos primero (<PowerShellInline code="Get-Command" />),
            ejecútalos con <PowerShellInline code="&" />
            y valida con <PowerShellInline code="$LASTEXITCODE" /> o un wrapper como
            <PowerShellInline code={`Invoke-Tool.ps1`} />.
        </P>

        <Fragment slot="key-points">
            <ListItem icon={icons.HandPalm}>
                Promueve errores críticos con <PowerShellInline code="-ErrorAction Stop" /> para
                activar
                <PowerShellInline code={`catch`} />.
            </ListItem>

            <ListItem icon={icons.Bug}>
                En <PowerShellInline code={`catch`} />, <PowerShellInline code="$_" /> es el
                <PowerShellInline code={`[ErrorRecord]`} /> (tipo y mensaje en <PowerShellInline
                    code={`$_.Exception`}
                />).
            </ListItem>

            <ListItem icon={icons.MagnifyingGlass}>
                Resuelve binarios con <PowerShellInline code="Get-Command -ErrorAction Stop" /> y
                llama al path real.
            </ListItem>

            <ListItem icon={icons.Play}>
                Ejecuta con <PowerShellInline code="&" /> y valida con <PowerShellInline
                    code="$LASTEXITCODE"
                /> (o tu wrapper).
            </ListItem>

            <ListItem icon={icons.ArrowsLeftRight}>
                <PowerShellInline code="2>&1" /> mezcla <I>stderr</I> en <I>stdout</I> para capturar
                todo en una variable.
            </ListItem>

            <ListItem icon={icons.Table}>
                Devuelve <PowerShellInline code="[PSCustomObject]" /> para salida estructurada y
                consumible.
            </ListItem>

            <ListItem icon={icons.BracketsCurly}>
                <PowerShellInline code="@{ }" /> (hashtable) agrupa datos/params; perfecto para <I
                >splatting</I>.
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            <P>
                <B>El buen manejo de errores es diseño, no accidente.</B> Trata los errores como
                datos: promuévelos cuando la integridad esté en juego, o toléralos cuando el
                objetivo sea reportar sin interrumpir. Compón tus soluciones en torno a <I
                >capacidades</I> (comandos disponibles) y no a suposiciones del entorno. Registra
                con intención, devuelve resultados estructurados y <I><Enquote>fail
                        loudly</Enquote></I> cuando sea necesario. Si adoptas estos patrones
                (terminantes, observabilidad, wrapper de binarios y fallback), tus scripts serán más
                confiables, portables y fáciles de mantener.
            </P>
        </Fragment>
    </ConclusionsLayout>

    <References>
        <Fragment slot="recommended">
            <Book
                chapter="Handling errors"
                bookTitle="Learn PowerShell in a Month of Lunches, fourth edition: Covers Windows, Linux, and MacOS"
                pages={[279, 286]}
            >
                <AuthorList slot="authors" authors={[{ firstName: "Travis", lastName: "Plunk" }]} />

                <span slot="description">
                    Capítulo práctico sobre manejo de errores en PowerShell que explica la
                    diferencia entre errores no terminantes y excepciones, cómo forzar excepciones
                    con <PowerShellInline code="-ErrorAction Stop" />
                    para poder capturarlas con
                    <PowerShellInline code="try" />/<PowerShellInline
                        code="catch"
                    />/<PowerShellInline code="finally" />, y el papel de <PowerShellInline
                        code="$Error"
                    />, <PowerShellInline code="-ErrorVariable" />
                    (incluyendo el uso de <PowerShellInline code="+" /> para acumular) y
                    <PowerShellInline code="$ErrorActionPreference" />. Advierte contra malas
                    prácticas como silenciar errores globalmente, y muestra cuándo registrar,
                    continuar o detener según el objetivo del script. Incluye patrones para comandos
                    nativos y métodos .NET (cuándo ajustar temporalmente las preferencias), y
                    ejemplos de <PowerShellInline code="catch" /> tipados. Ideal para entender qué
                    registrar, cómo reaccionar ante fallos y cómo diseñar herramientas que fallen de
                    forma explícita y depurable.
                </span>
            </Book>
        </Fragment>

        <Fragment slot="additional">
            <WebPage
                title="about_Redirection"
                url="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection"
            >
                <Link href="https://learn.microsoft.com/en-us/powershell" slot="location"
                >la documentación oficial de PowerShell</Link>
                <Fragment slot="description">
                    Breve guía de <B>redirección en PowerShell</B>: explica cómo enviar salida a
                    archivos y combinar flujos (éxito, error, warning, etc.) usando
                    <PowerShellInline code={`Out-File`} />,
                    <PowerShellInline code={`Tee-Object`} /> y <B>operadores de redirección</B>
                    (<PowerShellInline code={`>`} />, <PowerShellInline code={`>>`} />,
                    <PowerShellInline code={`n>&1`} />, <PowerShellInline code={`*>`} />). Incluye
                    tabla de flujos redireccionables, cambios en <B>PowerShell&nbsp;7.4</B> para
                    redirigir
                    <I>stdout</I> de comandos nativos (conservando bytes), ejemplos prácticos
                    (fusionar
                    <PowerShellInline code={`2>&1`} />, redirigir todos los flujos, suprimir <I
                    >Information/Host</I>), efectos de <I>Action Preferences</I>, consideraciones de
                    <I>codificación y ancho</I> de salida, y notas sobre confusiones comunes con
                    <PowerShellInline code={`>`} /> vs. comparadores (<PowerShellInline
                        code={`-gt`}
                    />, <PowerShellInline code={`-lt`} />).
                </Fragment>
            </WebPage>
        </Fragment>
    </References>
</NotesLayout>
