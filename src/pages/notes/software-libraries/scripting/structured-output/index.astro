---
import * as icons from "$icons";
import fs from "fs";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Table, TableBody, TableCell, TableHeader, TableRow } from "~/components/starwind/table";
import { Abstract, Definition, Explanation, Important, Info, More, Tip } from "~/components/ui/callouts";
import { OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import ToDo from "~/components/utils/ToDo";
import { NotesSection } from "~/layouts";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";

const newPersonPSCustomCode = fs.readFileSync(
    "src/fragments/notes/software-libraries/scripting/structured-output/New-Person.fragment.ps1",
    "utf8",
);
---

<NotesLayout
    title="Salida estructurada en PowerShell"
    description="Si estás leyendo esto es porque se me olvidó agregar la descripción. Se agradece si me lo recuerdas."
    timeMultiplier={1.5} git={{ repo: "dibs-scripts", user: "r8vnhill" }}
>
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-hash-tables">
        <Heading
            headingLevel="h2" Icon={icons.BracketsCurly}
            slot="heading"
        >
            Diccionarios (<PowerShellInline code="@{ }" />)
        </Heading>

        <Definition headingLevel="h3">
            <span slot="title">Diccionarios en PowerShell</span>

            <P>
                En PowerShell, los diccionarios se crean con la sintaxis
                <PowerShellInline code="@{ Clave = Valor }" />. Son tablas de hash que agrupan pares <I>clave–valor</I>
                y permiten acceder a cada valor por su nombre.
            </P>
        </Definition>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $FirstName,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $LastName
                )

                @{
                    FirstName = $FirstName
                    LastName  = $LastName
                }
            `}
        >
            <Fragment slot="title">Script que retorna un diccionario</Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" ref="6b3cbfeaf6820f6289c5f8f30db34c526797bf29"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.BracketsCurly}>
                    La sintaxis es <PowerShellInline code="@{ Clave1 = Valor1; Clave2 = Valor2 }" />. Cada par está
                    separado por punto y coma o salto de línea.
                </ListItem>

                <ListItem icon={icons.Key}>
                    Las claves son únicas; si se repite una, su valor anterior se sobrescribe.
                </ListItem>

                <ListItem icon={icons.Warning}>
                    <I><B>No</B></I> se garantiza el orden de inserción de los elementos.
                </ListItem>
            </List>
        </Explanation>

        <Info headingLevel="h3" icon={icons.PlayCircle}>
            <span slot="title">Uso</span>

            <PowerShellBlock
                code={`
            $result = ./New-Person.ps1 -FirstName Miles -LastName Edgeworth

            # Acceder a los valores
            $result.FirstName   # Miles
            $result["LastName"] # Edgeworth

            # Mutar el diccionario (agregar y modificar valores)
            $result.Age = 25

            # Mostrar el nuevo estado del diccionario
            $result
        `}
            >
                <Fragment slot="title">Desde <Mono>dibs/scripts/models/</Mono></Fragment>
                <span slot="footer">
                    Los diccionarios en PowerShell son <I>mutables</I>: puedes agregar, modificar o eliminar pares
                    <I>clave–valor</I> en cualquier momento.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h3">
                <List>
                    <ListItem icon={icons.Code}>
                        <B>Tipo:</B> el resultado es un <PowerShellInline code="[hashtable]" />, que almacena los pares
                        <I>clave–valor</I>.
                    </ListItem>

                    <ListItem icon={icons.CursorClick}>
                        <B>Acceso:</B> usa <PowerShellInline code="$h.Clave" /> o <PowerShellInline
                            code='$h["Clave"]'
                        /> para leer valores.
                    </ListItem>

                    <ListItem icon={icons.Pencil}>
                        <B>Mutabilidad:</B> puedes agregar o modificar elementos con <PowerShellInline
                            code="$h.Clave = Valor"
                        /> (incluso si <I>no existe</I>) y eliminarlos con <PowerShellInline
                            code='Remove-Item -Key "Clave"'
                        />.
                    </ListItem>
                </List>
            </Explanation>
        </Info>

        <NotesSection id="h3-splatting-dictionaries">
            <Heading
                headingLevel="h3" Icon={icons.ArrowsLeftRight}
                slot="heading"
            >
                Splatting: pasar diccionarios como parámetros
            </Heading>

            <P>
                En PowerShell puedes <Enquote>desempaquetar</Enquote> un
                <PowerShellInline code="[hashtable]" /> como parámetros nombrados usando el operador <PowerShellInline
                    code="@"
                /> (<I>splatting</I>). Esto mejora legibilidad, evita líneas largas y facilita mantener scripts.
            </P>

            <PowerShellBlock
                code={`
                    # Diccionario de parámetros
                    $copyParams = @{
                        Path        = './data/input.txt'
                        Destination = './backup'
                        Force       = $true
                        Verbose     = $true
                    }

                    # Splatting: pasa las claves como parámetros nombrados
                    Copy-Item @copyParams

                    # Mutabilidad: se puede modificar antes de reutilizar
                    $copyParams.Recurse = $true
                    Copy-Item @copyParams
                `}
            >
                <Fragment slot="title">Diccionario → parámetros</Fragment>
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose -Recurse
            `}
            >
                <Fragment slot="title">Equivalencia</Fragment>
                <span slot="footer">
                    Splatting y parámetros explícitos ejecutan lo mismo; cambia sólo la forma de escribirlo. Nota como
                    reducimos la duplicación de código y hacemos las líneas más cortas.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.BracketsCurly}>
                        <PowerShellInline code="@{ Clave = Valor }" /> crea un diccionario (<PowerShellInline
                            code="[hashtable]"
                        />).
                    </ListItem>
                    <ListItem icon={icons.ArrowsLeftRight}>
                        <PowerShellInline code="@diccionario" /> aplica sus pares como parámetros nombrados del cmdlet.
                    </ListItem>
                    <ListItem icon={icons.Info}>
                        Los valores <PowerShellInline code="[bool]" /> se interpretan como <I>switches</I> de presencia
                        o ausencia.
                    </ListItem>
                </List>
            </Explanation>

            <Important headingLevel="h4">
                Usaremos <I>diccionarios</I> para valores transitorios y <I>splatting</I>. Para salida estructurada,
                preferiremos <PowerShellInline code="[PSCustomObject]" />.
            </Important>

            <More headingLevel="h4">
                <span slot="title">Continuación de líneas con <PowerShellInline code={"`"} /></span>

                <P>
                    Una alternativa a usar <I>splatting</I> para separar líneas largas es usar el carácter de <Enquote
                    >escape</Enquote> (<PowerShellInline code={"`"} />) al final de la línea. Sin embargo, esto
                    <B>no se recomienda</B> fuera de casos muy puntuales, ya que es propenso a errores difíciles de
                    detectar. El caracter especial <PowerShellInline code={"`"} /> <B>debe ser</B> el último de la
                    línea.
                </P>

                <PowerShellBlock
                    code={`
                        # Esto funciona
                        Write-Output \`
                            "Hello, World!"
                        # Pero...
                        Write-Output \` # ...esto ya no
                            "Hello, World!"
                    `}
                >
                    <span slot="title">Ejemplos de continuación de línea válido e inválido</span>
                    <span slot="footer">
                        El espacio después del <PowerShellInline code={"`"} /> (y antes de <PowerShellInline
                            code={`#`}
                        />) en la segunda llamada hace que falle.
                    </span>
                </PowerShellBlock>

                <P>
                    PowerShell recomienda otras formas de continuar líneas, puedes encontrar más información en la
                    <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing#line-continuation"
                    >documentación oficial</Link>.
                </P>
            </More>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-pscustomobject">
        <Heading
            headingLevel="h2" Icon={icons.Table}
            slot="heading"
        >
            Objetos personalizados
        </Heading>

        <PowerShellBlock code={newPersonPSCustomCode}>
            <Fragment slot="title">
                Crear un objeto fuertemente tipado con <PowerShellInline code={`[PSCustomObject]`} />
            </Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" line={13}
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <B><PowerShellInline code={`[PSCustomObject]@{ ... }`} />:</B> Es un <Enquote>type
                accelerator</Enquote><FootnoteRef index={1} /> que convierte un <PowerShellInline
                code={`[hashtable]`}
            /> en una instancia de <PowerShellInline code={`[PSCustomObject]`} />. Observa que lo único que cambia
            respecto del ejemplo con un diccionario es el prefijo <PowerShellInline code={`[PSCustomObject]`} />. Dentro
            sigues declarando <I>propiedades</I> con pares <PowerShellInline code={`Nombre = Valor`} />. El resultado es
            un objeto con propiedades reales (no solo entradas en un diccionario), apto para mostrarse en tabla y para
            interoperar con el ecosistema de cmdlets de salida.
        </Explanation>

        <NotesSection id="h3-pscustomobject-benefits">
            <Heading
                headingLevel="h3" Icon={icons.GridFour}
                slot="heading"
            >
                Beneficios de <PowerShellInline code="[PSCustomObject]" /> frente a <PowerShellInline
                    code="[hashtable]"
                />
            </Heading>

            <ToDo
                client:only="react"
                metadata={{
                    tasks: [
                        "Tengo que revisar esta sección para asegurarme de que todo está correcto y bien explicado.",
                    ],
                }}
            />

            <P>
                Aunque las <PowerShellInline code="[hashtable]" /> son útiles como estructuras clave–valor,
                <PowerShellInline code="[PSCustomObject]" /> ofrece ventajas importantes al generar salida estructurada
                o devolver datos desde funciones. Además, encaja mejor con el modelo de encadenamiento de comandos
                (pipeline) que veremos más adelante.
            </P>

            <List>
                <ListItem icon={icons.Table}>
                    <I>Salida tabular predecible:</I> las propiedades se muestran como columnas y conservan el orden en
                    que fueron declaradas.

                    <PowerShellBlock
                        code={`
          # Hashtable: mapa clave–valor (no tiene propiedades reales)
          $pokemonHT = @{
              Name  = "Toxtricity"
              Types = @("Electric", "Poison")
          }
          # Intentar seleccionar columnas por nombre no produce el resultado esperado
          Format-Table -Property Name, Types -InputObject $pokemonHT

          # PSCustomObject: convierte claves en propiedades reales (ideal para salida)
          $pokemonPSCO = [PSCustomObject]$pokemonHT

          # Ahora sí: columnas y valores aparecen como se espera
          Format-Table -Property Name, Types -InputObject $pokemonPSCO
        `}
                    >
                        <span slot="title">
                            Diferencia práctica: <PowerShellInline code="[hashtable]" /> vs <PowerShellInline
                                code="[PSCustomObject]"
                            />
                        </span>
                        <span slot="footer">
                            Este comportamiento coincide con lo descrito por la comunidad: un <em>hashtable</em> no se
                            comporta como un objeto con propiedades al formatear columnas específicas; convertir a <code
                            >[PSCustomObject]</code>
                            evita esa sorpresa.
                        </span>
                    </PowerShellBlock>

                    <Note>
                        Discusión de referencia: “Why PS Custom Object?” — plantea precisamente que
                        <I>Format-Table Name, Location</I> con hashtable no muestra columnas como se esperaría, mientras
                        que un <PowerShellInline code="[PSCustomObject]" /> sí lo hace. Además, se menciona que a los
                        objetos personalizados se les puede asociar <em>TypeNames</em> y propiedades de visualización
                        por defecto para controlar su salida.
                        <br />
                        <Link href="https://forums.powershell.org/t/why-ps-custom-object/10826/2"
                        >PowerShell.org — Why PS Custom Object?</Link>
                    </Note>
                </ListItem>

                <ListItem icon={icons.Tag}>
                    <I>Control de presentación (TypeNames y propiedades por defecto):</I> a los
                    <PowerShellInline code="[PSCustomObject]" /> se les puede asignar un <em>TypeName</em> y definir qué
                    propiedades se muestran por defecto, mejorando la legibilidad sin perder datos. Para más detalles
                    sobre cómo el sistema de tipos extiende estos comportamientos, consulta:
                    <Link
                        href="https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_Types.ps1xml"
                    >
                        about_Types.ps1xml (Microsoft Learn)
                    </Link>.
                </ListItem>

                <ListItem icon={icons.Puzzle}>
                    <I>Compatibilidad con el encadenamiento de comandos:</I> muchos comandos esperan objetos con
                    propiedades claras para seleccionar campos por nombre y aplicar formateadores. Los
                    <PowerShellInline code="[PSCustomObject]" /> están pensados para encajar en ese modelo. No
                    entraremos en detalles aquí; basta con saber que más adelante esta elección facilita el flujo de
                    trabajo.
                </ListItem>
            </List>
        </NotesSection>
    </NotesSection>

    <Footnotes>
        <Footnote index={1}>
            Los <I>type accelerators</I> son atajos definidos por PowerShell que permiten instanciar tipos .NET sin
            escribir su nombre completo. Por ejemplo, <PowerShellInline code="[PSCustomObject]" /> es un acelerador de
            <PowerShellInline code="[System.Management.Automation.PSObject]" />. Existen muchos otros, como
            <PowerShellInline code="[hashtable]" /> para <PowerShellInline code="[System.Collections.Hashtable]" /> o
            <PowerShellInline code="[ValidateSet]" /> para <PowerShellInline
                code="[System.Management.Automation.ValidateSetAttribute]"
            />. Puedes aprender más sobre ellos con:
            <PowerShellBlock
                code={`
                    # Mostrar la lista completa de type accelerators disponibles
                    [PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get

                    # Obtener documentación adicional
                    Get-Help about_Type_Accelerators
                `}
            >
                <Fragment slot="title">Explorar los type accelerators</Fragment>
            </PowerShellBlock>
        </Footnote>
    </Footnotes>

    {
        /*

        <NotesSection id="h2-compare">
            <Heading
                headingLevel="h2" Icon={icons.ArrowsLeftRight}
                slot="heading"
            >
                Diferencias y usos
            </Heading>

            <Explanation>
                <Table>
                    <TableHeader>
                        <TableRow>
                            <TableCell>Aspecto</TableCell>
                            <TableCell>Hash table</TableCell>
                            <TableCell>PSCustomObject</TableCell>
                        </TableRow>
                    </TableHeader>

                    <TableBody>
                        <TableRow>
                            <TableCell>Tipo</TableCell>
                            <TableCell>[hashtable]</TableCell>
                            <TableCell>[pscustomobject]</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Acceso</TableCell>
                            <TableCell>$h['Clave']</TableCell>
                            <TableCell>$o.Propiedad</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Orden</TableCell>
                            <TableCell>Desordenado (usa [ordered] para mantenerlo)</TableCell>
                            <TableCell>Ordenado por defecto</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Mutabilidad</TableCell>
                            <TableCell>Mutable (puedes agregar o quitar claves)</TableCell>
                            <TableCell>Generalmente inmutable</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Ideal para</TableCell>
                            <TableCell>Configuraciones, parámetros o diccionarios</TableCell>
                            <TableCell>Datos tabulares, reportes o exportación</TableCell>
                        </TableRow>
                    </TableBody>
                </Table>
            </Explanation>
        </NotesSection>

        <NotesSection id="h2-apply">
            <Heading
                headingLevel="h2" Icon={icons.Wrench}
                slot="heading"
            >
                Aplicaciones prácticas
            </Heading>

            <List>
                <ListItem icon={icons.FileText}>
                    Crear reportes:
                    <PowerShellInline code="[pscustomobject]@{ Nombre = $n; Estado = $e; Fecha = Get-Date }" />.
                </ListItem>

                <ListItem icon={icons.Export}>
                    Exportar resultados:
                    <PowerShellInline code="$data | Export-Csv -Path './salida.csv' -NoTypeInformation" />.
                </ListItem>

                <ListItem icon={icons.Code}>
                    Definir configuraciones o parámetros con
                    <PowerShellInline code="@{ }" /> y pasarlos mediante
                    <I>splatting</I>:
                    <PowerShellInline code="Invoke-Script @config" />.
                </ListItem>
            </List>
        </NotesSection>

        <ConclusionsLayout>
            <P slot="conclusions">
                La <B>salida estructurada</B> convierte scripts en herramientas que pueden interoperar: en lugar de texto,
                producen datos reutilizables. Las hash tables son útiles para agrupar pares clave–valor, mientras que los
                objetos personalizados permiten entregar resultados consistentes y exportables.
            </P>

            <Fragment slot="key-points">
                <ListItem icon={icons.BracketsCurly}>
                    Usa <PowerShellInline code="@{ }" /> para agrupar claves y valores.
                </ListItem>
                <ListItem icon={icons.Table}>
                    Convierte esa tabla en un objeto legible con
                    <PowerShellInline code="[pscustomobject]" />.
                </ListItem>
                <ListItem icon={icons.Export}>
                    Aprovecha su formato tabular para exportar fácilmente a CSV o JSON.
                </ListItem>
            </Fragment>
        </ConclusionsLayout>
            */
    }
</NotesLayout>
