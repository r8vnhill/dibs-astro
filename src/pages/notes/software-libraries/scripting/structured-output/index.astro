---
import * as icons from "$icons";
import fs from "fs";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Definition, Exercise, Explanation, Important, Info, More, Warning } from "~/components/ui/callouts";
import { OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { References, WebPage } from "~/components/ui/references";
import { NotesSection } from "~/layouts";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";

const newPersonPSCustomCode = fs.readFileSync(
    "src/fragments/notes/software-libraries/scripting/structured-output/New-Person.fragment.ps1",
    "utf8",
);
---

<NotesLayout
    title="Salida estructurada en PowerShell"
    description="Aprende a producir salida estructurada en PowerShell para que tus scripts comuniquen datos de forma clara y reutilizable. Esta lección explica cómo usar diccionarios ([hashtable]) para almacenar configuraciones o pasar parámetros, y cómo convertirlos en objetos personalizados ([PSCustomObject]) para obtener resultados tabulares consistentes. Incluye un ejercicio práctico donde crearás un comando que devuelve un resultado de éxito o fallo simulado."
    git={{ repo: "dibs-scripts", user: "r8vnhill" }}
>
    <Abstract>
        <P>
            Esta lección introduce la idea de generar <I>salida estructurada</I> en PowerShell, un paso esencial para
            construir scripts reutilizables y fáciles de integrar con otros comandos. En lugar de imprimir texto sin
            formato, aprenderás a devolver datos en estructuras que PowerShell y otras herramientas pueden interpretar,
            visualizar y filtrar con facilidad.
        </P>

        <P>
            Comenzamos explorando los diccionarios (<PowerShellInline code="[hashtable]" />) como forma básica de
            agrupar pares clave–valor, útiles para almacenar configuraciones o pasar parámetros mediante <I
            >splatting</I>. Luego avanzamos hacia <PowerShellInline code="[PSCustomObject]" />, que permite producir
            resultados con propiedades reales y una presentación tabular consistente. La lección culmina con un pequeño
            ejercicio práctico donde crearás un comando que simula una comprobación de conexión y devuelve un objeto con
            el resultado de éxito o fallo, reforzando la utilidad de esta representación estructurada.
        </P>
    </Abstract>

    <NotesSection id="h2-hash-tables">
        <Heading
            headingLevel="h2" Icon={icons.BracketsCurly}
            slot="heading"
        >
            Diccionarios
        </Heading>

        <Definition headingLevel="h3">
            <span slot="title">Diccionarios en PowerShell</span>

            <P>
                En PowerShell, los diccionarios se crean con la sintaxis
                <PowerShellInline code="@{ Clave = Valor }" />. Son tablas de hash que agrupan pares <I>clave–valor</I>
                y permiten acceder a cada valor por su nombre.
            </P>
        </Definition>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $FirstName,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $LastName
                )

                @{
                    FirstName = $FirstName
                    LastName  = $LastName
                }
            `}
        >
            <Fragment slot="title">Script que retorna un diccionario</Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" ref="6b3cbfeaf6820f6289c5f8f30db34c526797bf29"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.BracketsCurly}>
                    La sintaxis es <PowerShellInline code="@{ Clave1 = Valor1; Clave2 = Valor2 }" />. Cada par está
                    separado por punto y coma o salto de línea.
                </ListItem>

                <ListItem icon={icons.Key}>
                    Las claves son únicas; si se repite una, su valor anterior se sobrescribe.
                </ListItem>

                <ListItem icon={icons.Warning}>
                    <I><B>No</B></I> se garantiza el orden de inserción de los elementos.
                </ListItem>
            </List>
        </Explanation>

        <Info headingLevel="h3" icon={icons.PlayCircle}>
            <span slot="title">Uso</span>

            <PowerShellBlock
                code={`
                    $result = ./New-Person.ps1 -FirstName Miles -LastName Edgeworth

                    # Acceder a los valores
                    $result.FirstName   # Miles
                    $result["LastName"] # Edgeworth

                    # Mutar el diccionario (agregar y modificar valores)
                    $result.Age = 25

                    # Mostrar el nuevo estado del diccionario
                    $result
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/scripts/models/</Mono></Fragment>
                <span slot="footer">
                    Los diccionarios en PowerShell son <I>mutables</I>: puedes agregar, modificar o eliminar pares
                    <I>clave–valor</I> en cualquier momento.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h3">
                <List>
                    <ListItem icon={icons.Code}>
                        <B>Tipo:</B> el resultado es un <PowerShellInline code="[hashtable]" />, que almacena los pares
                        <I>clave–valor</I>.
                    </ListItem>

                    <ListItem icon={icons.CursorClick}>
                        <B>Acceso:</B> usa <PowerShellInline code="$h.Clave" /> o <PowerShellInline
                            code='$h["Clave"]'
                        /> para leer valores.
                    </ListItem>

                    <ListItem icon={icons.Pencil}>
                        <B>Mutabilidad:</B> puedes agregar o modificar elementos con <PowerShellInline
                            code="$h.Clave = Valor"
                        /> (incluso si <I>no existe</I>) y eliminarlos con <PowerShellInline
                            code='Remove-Item -Key "Clave"'
                        />.
                    </ListItem>
                </List>
            </Explanation>
        </Info>

        <NotesSection id="h3-splatting-dictionaries">
            <Heading
                headingLevel="h3" Icon={icons.ArrowsLeftRight}
                slot="heading"
            >
                Splatting: pasar diccionarios como parámetros
            </Heading>

            <P>
                En PowerShell puedes <Enquote>desempaquetar</Enquote> un
                <PowerShellInline code="[hashtable]" /> como parámetros nombrados usando el operador <PowerShellInline
                    code="@"
                /> (<I>splatting</I>). Esto mejora legibilidad, evita líneas largas y facilita mantener scripts.
            </P>

            <PowerShellBlock
                code={`
                    # Diccionario de parámetros
                    $copyParams = @{
                        Path        = './data/input.txt'
                        Destination = './backup'
                        Force       = $true
                        Verbose     = $true
                    }

                    # Splatting: pasa las claves como parámetros nombrados
                    Copy-Item @copyParams

                    # Mutabilidad: se puede modificar antes de reutilizar
                    $copyParams.Recurse = $true
                    Copy-Item @copyParams
                `}
            >
                <Fragment slot="title">Diccionario → parámetros</Fragment>
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose -Recurse
            `}
            >
                <Fragment slot="title">Equivalencia</Fragment>
                <span slot="footer">
                    Splatting y parámetros explícitos ejecutan lo mismo; cambia sólo la forma de escribirlo. Nota como
                    reducimos la duplicación de código y hacemos las líneas más cortas.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.BracketsCurly}>
                        <PowerShellInline code="@{ Clave = Valor }" /> crea un diccionario (<PowerShellInline
                            code="[hashtable]"
                        />).
                    </ListItem>
                    <ListItem icon={icons.ArrowsLeftRight}>
                        <PowerShellInline code="@diccionario" /> aplica sus pares como parámetros nombrados del cmdlet.
                    </ListItem>
                    <ListItem icon={icons.Info}>
                        Los valores <PowerShellInline code="[bool]" /> se interpretan como <I>switches</I> de presencia
                        o ausencia.
                    </ListItem>
                </List>
            </Explanation>

            <Important headingLevel="h4">
                Usaremos <I>diccionarios</I> para valores transitorios y <I>splatting</I>. Para salida estructurada,
                preferiremos <PowerShellInline code="[PSCustomObject]" />.
            </Important>

            <More headingLevel="h4">
                <span slot="title">Continuación de líneas con <PowerShellInline code={"`"} /></span>

                <P>
                    Una alternativa a usar <I>splatting</I> para separar líneas largas es usar el carácter de <Enquote
                    >escape</Enquote> (<PowerShellInline code={"`"} />) al final de la línea. Sin embargo, esto
                    <B>no se recomienda</B> fuera de casos muy puntuales, ya que es propenso a errores difíciles de
                    detectar. El caracter especial <PowerShellInline code={"`"} /> <B>debe ser</B> el último de la
                    línea.
                </P>

                <PowerShellBlock
                    code={`
                        # Esto funciona
                        Write-Output \`
                            "Hello, World!"
                        # Pero...
                        Write-Output \` # ...esto ya no
                            "Hello, World!"
                    `}
                >
                    <span slot="title">Ejemplos de continuación de línea válido e inválido</span>
                    <span slot="footer">
                        El espacio después del <PowerShellInline code={"`"} /> (y antes de <PowerShellInline
                            code={`#`}
                        />) en la segunda llamada hace que falle.
                    </span>
                </PowerShellBlock>

                <P>
                    PowerShell recomienda otras formas de continuar líneas, puedes encontrar más información en la
                    <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing#line-continuation"
                    >documentación oficial</Link>.
                </P>
            </More>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-pscustomobject">
        <Heading
            headingLevel="h2" Icon={icons.Table}
            slot="heading"
        >
            Objetos personalizados
        </Heading>

        <PowerShellBlock code={newPersonPSCustomCode}>
            <Fragment slot="title">
                Crear un objeto fuertemente tipado con <PowerShellInline code={`[PSCustomObject]`} />
            </Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" line={13}
                ref="a4dfcdd1f7950134079eeb1e3fafdba682947b76"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <B><PowerShellInline code={`[PSCustomObject]@{ ... }`} />:</B> Es un <Enquote>type
                accelerator</Enquote><FootnoteRef index={1} /> que convierte un <PowerShellInline
                code={`[hashtable]`}
            /> en una instancia de <PowerShellInline code={`[PSCustomObject]`} />. Observa que lo único que cambia
            respecto del ejemplo con un diccionario es el prefijo <PowerShellInline code={`[PSCustomObject]`} />. Dentro
            sigues declarando <I>propiedades</I> con pares <PowerShellInline code={`Nombre = Valor`} />. El resultado es
            un objeto con propiedades reales (no solo entradas en un diccionario), apto para mostrarse en tabla y para
            interoperar con el ecosistema de cmdlets de salida.
        </Explanation>

        <NotesSection id="h3-pscustomobject-benefits">
            <Heading
                headingLevel="h3" Icon={icons.GridFour}
                slot="heading"
            >
                Beneficios de <PowerShellInline code="[PSCustomObject]" /> frente a <PowerShellInline
                    code="[hashtable]"
                /><FootnoteRef index={2} />
            </Heading>

            <P>
                Aunque las <PowerShellInline code="[hashtable]" /> son útiles como estructuras clave–valor,
                <PowerShellInline code="[PSCustomObject]" /> ofrece ventajas importantes al generar salida estructurada
                o devolver datos desde cmdlets. Además, encaja mejor con el modelo de encadenamiento de comandos
                (pipeline) que veremos más adelante.
            </P>

            <List>
                <ListItem icon={icons.Table}>
                    <I>Salida tabular predecible:</I> las propiedades se muestran como columnas y conservan el orden en
                    que fueron declaradas.

                    <PowerShellBlock
                        code={`
                            # Hashtable: mapa clave–valor (no tiene propiedades reales)
                            $pokemonHT = @{
                                Name  = "Toxtricity"
                                Types = @("Electric", "Poison")
                            }
                            # Intentar seleccionar columnas por nombre no produce el resultado esperado
                            Format-Table -Property Name, Types -InputObject $pokemonHT

                            # PSCustomObject: convierte claves en propiedades reales (ideal para salida)
                            $pokemonPSCO = [PSCustomObject]$pokemonHT

                            # Ahora sí: columnas y valores aparecen como se espera
                            Format-Table -Property Name, Types -InputObject $pokemonPSCO
                        `}
                    >
                        <span slot="title">
                            Diferencia práctica: <PowerShellInline code="[hashtable]" /> vs <PowerShellInline
                                code="[PSCustomObject]"
                            />
                        </span>
                        <span slot="footer">
                            Este comportamiento coincide con lo descrito por la comunidad: un <I>hashtable</I> no se
                            comporta como un objeto con propiedades al formatear columnas específicas; convertir a
                            <PowerShellInline code={`[PSCustomObject]`} /> evita esa sorpresa.
                        </span>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.Tag}>
                    <I>Control de presentación (TypeNames y propiedades por defecto):</I> a los
                    <PowerShellInline code="[PSCustomObject]" /> se les puede asignar un <I>TypeName</I> y definir qué
                    propiedades se muestran por defecto, mejorando la legibilidad sin perder datos. Para más detalles
                    sobre cómo el sistema de tipos extiende estos comportamientos, consulta:
                    <PowerShellBlock code={`
                        Get-Help about_Types.ps1xml
                    `}>
                        <Fragment slot="title">Explorar cómo utilizar <Mono>Types.ps1xml</Mono></Fragment>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.Pipe}>
                    <I>Compatibilidad con el pipeline:</I> muchos comandos esperan objetos con propiedades claras para
                    seleccionar campos por nombre y aplicar formateadores. Los <PowerShellInline
                        code="[PSCustomObject]"
                    /> están pensados para encajar en ese modelo. No entraremos en detalles aquí; basta con saber que
                    más adelante esta elección facilita el flujo de trabajo.
                </ListItem>
            </List>
        </NotesSection>

        <Important headingLevel="h3">
            En este curso utilizaremos <PowerShellInline code="[PSCustomObject]" /> para mantener la simplicidad y
            centrarnos en la forma de los datos. Si necesitas reglas más estrictas, métodos, herencia o contratos de
            tipos más claros para herramientas y módulos, considera migrar a <I>clases</I>.
        </Important>

        <More headingLevel="h3">
            <span slot="title">Clases y salida tipada</span>

            <P>
                PowerShell permite definir <I>clases</I> para modelar datos con propiedades y métodos, aprovechando
                conceptos conocidos de OOP (encapsulación y herencia). Usarlas mejora el autocompletado del editor y
                ayuda a detectar errores de tipos al escribir. Para describir el tipo de salida de una <I>función</I>
                existe el atributo <PowerShellInline code="[OutputType()]" /> (útil para documentación y tooling), pero
                a nivel de <I>script</I> no podemos declarar un tipo de salida explícito (esta es una ventaja de usar
                funciones o módulos que puedes considerar más adelante).
            </P>

            <P>
                A continuación definimos una clase <PowerShellInline code={`[Person]`} /> en un módulo (<Mono
                >.psm1</Mono>) y luego la usamos desde un script (<Mono>.ps1</Mono>) para crear y devolver un objeto.
            </P>

            <PowerShellBlock
                code={`
                    class Person {
                        [string] $FirstName
                        [string] $LastName

                        Person([string] $first, [string] $last) {
                            $this.FirstName = $first
                            $this.LastName  = $last
                        }

                        [string] ToString() {
                            return '{0} {1}' -f $this.FirstName, $this.LastName
                        }
                    }
                `}
            >
                <span slot="title">Definir un tipo de datos con <code>class</code> (módulo .psm1)</span>
                <span slot="footer">
                    Un archivo <Mono>.psm1</Mono> es un <I>módulo</I> de PowerShell: puede exportar tipos (clases),
                    funciones u otros elementos para ser reutilizados. Aquí sólo definimos la clase <PowerShellInline
                        code={`[Person]`}
                    />.
                    <br />
                    A diferencia de los scripts y funciones, los <I>métodos</I> deben tener un <PowerShellInline
                        code={`return`}
                    /> explícito para devolver valores.
                </span>
                <DibsSourceLink
                    slot="source" file="models/Person.psm1"
                    repo="scripts"
                />
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                    using module ./Person.psm1

                    #Requires -Version 7.5
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $FirstName,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $LastName
                    )

                    # Función local al script (no se exporta): deja el flujo claro y permite reutilizar internamente.
                    function Script:New-Person {
                        [OutputType([Person])]
                        param ()

                        [Person]::new($FirstName, $LastName)
                    }

                    # Devolver la instancia tipada como salida del script
                    New-Person
                `}
            >
                <span slot="title">Usar el módulo y devolver una instancia tipada (script <Mono>.ps1</Mono>)</span>

                <span slot="footer">
                    <B>Notas breves:</B>
                    <ul style="list-style-type: disc; margin-left: 1.5rem">
                        <li>
                            <PowerShellInline code={`using module ./Person.psm1`} /> carga el módulo con la clase
                            <PowerShellInline code={`[Person]`} />.
                        </li>
                        <li>
                            El prefijo <PowerShellInline code={`Script:`} /> hace que <PowerShellInline
                                code={`New-Person`}
                            /> sea <I>local</I> al script (no se exporta).
                        </li>
                        <li>La salida del script es el objeto <PowerShellInline code={`[Person]`} /> recién creado.</li>
                    </ul>
                </span>
                <DibsSourceLink
                    slot="source" file="models/New-PersonClass.ps1"
                    repo="scripts"
                />
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                    $person = ./New-PersonClass.ps1 -FirstName Naoki -LastName Urasawa
                    $person.ToString()  # "Naoki Urasawa"
                    $person.FirstName   # "Naoki"
                    $person.LastName    # "Urasawa"
                `}
            >
                <span slot="title">Desde <Mono>scripts/models/</Mono></span>
            </PowerShellBlock>

            <P>
                Para aprender más consulta la documentación oficial:
            </P>

            <PowerShellBlock code={`Get-Help about_Classes`}>
                <Fragment slot="title">Explorar la documentación de clases</Fragment>
            </PowerShellBlock>
        </More>
    </NotesSection>

    <Exercise headingLevel="h2">
        <span slot="title">Comando con resultado de éxito o fallo</span>

        <Fragment slot="requirements">
            <P>
                Diseña un script llamado <PowerShellInline code="Test-ConnectionSummary.ps1" /> que simule la
                comprobación de conectividad hacia un servidor y devuelva un resultado estructurado. El script debe
                aceptar un único parámetro: <PowerShellInline code="[string] $Address" />.
            </P>
            <P>
                La salida debe ser un objeto <PowerShellInline code="[PSCustomObject]" /> con tres propiedades:
            </P>
            <List>
                <ListItem icon={icons.Circle}>
                    <Mono>Address</Mono>: el nombre recibido como parámetro.
                </ListItem>
                <ListItem icon={icons.CheckCircle}>
                    <Mono>Status</Mono>: un <PowerShellInline code="[bool]" /> que indique si la conexión fue exitosa o
                    fallida.
                </ListItem>
                <ListItem icon={icons.Clock}>
                    <Mono>CheckedAt</Mono>: la fecha y hora de la comprobación (usa <PowerShellInline
                        code="Get-Date"
                    />).
                </ListItem>
            </List>
            <P>No es necesario conectarse realmente; puedes simular el resultado.</P>
        </Fragment>

        <P slot="notes">
            Para simular la conexión, usa una heurística simple: devolver éxito si el address cumple la expresión
            regular
            <PowerShellInline code={`'^[A-Za-z0-9-]+(?:\\.[A-Za-z0-9-]+)*(?::\\d+)?$'`} />.<FootnoteRef index={3} />
        </P>

        <Fragment slot="use">
            <PowerShellBlock
                code={`
                    $res1 = ./Test-ConnectionSummary.ps1 -Address "toshihiko.kifuken.jp"
                    $res2 = ./Test-ConnectionSummary.ps1 -Address "shokujinki@net"
                    Format-Table -InputObject $res1, $res2
                `}
            >
                <span slot="title">Ejemplo de ejecución</span>
                <span slot="footer" class="text-sm">Inspirado en <I href="https://myanimelist.net/anime/1454/Kemonozume"
                    >Kemonozume</I></span>
            </PowerShellBlock>

            <OutputBlock
                code={`
                    Address              Status CheckedAt
                    -------              ------ ---------
                    toshihiko.kifuken.jp   True 10/17/2025 8:55:44 PM
                    shokujinki@net        False 10/17/2025 8:55:44 PM
                `}
            />
        </Fragment>

        <Fragment slot="solution">
            <PowerShellBlock
                code={`
                    #Requires -Version 7.5
                    [CmdletBinding()]
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $Address
                    )

                    [PSCustomObject]@{
                        Address   = $Address
                        Status    = $Address -match '^[A-Za-z0-9-]+(?:\\.[A-Za-z0-9-]+)*(?::\\d+)?$'
                        CheckedAt = Get-Date
                    }
                `}
            >
                <Fragment slot="title">Solución de referencia</Fragment>
                <span slot="footer">
                    La salida es tabular y consistente gracias a <PowerShellInline code="[PSCustomObject]" />. No se usa
                    manejo de errores; la decisión de éxito/fallo se basa únicamente en la expresión regular.
                </span>
            </PowerShellBlock>
        </Fragment>
    </Exercise>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            En esta lección vimos cómo modelar datos en PowerShell para producir <I>salida estructurada</I>. Partimos
            con diccionarios (<PowerShellInline code="[hashtable]" />) —útiles para valores transitorios y <I
            >splatting</I>— y luego pasamos a <PowerShellInline code="[PSCustomObject]" />, que convierte claves en <I
            >propiedades reales</I> y ofrece una presentación tabular consistente. También señalamos, de forma breve,
            que esta elección facilita el encadenamiento de comandos que veremos más adelante. La idea práctica: usa
            diccionarios para configurar/parametrizar, y <PowerShellInline code="[PSCustomObject]" /> cuando quieras
            devolver datos.
        </Fragment>

        <Fragment slot="key-points">
            <ListItem icon={icons.BracketsCurly}>
                <B>Diccionarios:</B> <PowerShellInline code="@{ Clave = Valor }" />; mutables, acceso por punto o
                índice, sin garantía de orden de inserción.
            </ListItem>

            <ListItem icon={icons.ArrowsLeftRight}>
                <B>Splatting:</B> usa <PowerShellInline code="@params" /> para pasar diccionarios como parámetros;
                mejora legibilidad y evita líneas largas duplicadas.
            </ListItem>

            <ListItem icon={icons.Table}>
                <B><PowerShellInline code="[PSCustomObject]" />:</B> <PowerShellInline
                    code="[PSCustomObject]@{ ... }"
                /> crea objetos con propiedades reales; la salida se muestra en columnas de forma predecible.
            </ListItem>

            <ListItem icon={icons.Lightning}>
                <B>Type accelerators:</B> <PowerShellInline code="[PSCustomObject]" /> es un acelerador; es decir, una
                forma abreviada de instanciar el tipo adecuado para salida estructurada.
            </ListItem>

            <ListItem icon={icons.FlowArrow}>
                <B>Cuándo usar qué:</B> diccionarios para configuración y parámetros; <PowerShellInline
                    code="[PSCustomObject]"
                /> para devolver resultados y que otras herramientas/comandos los consuman fácilmente.
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            Prefiere <PowerShellInline code="[PSCustomObject]" /> cuando el objetivo sea <I>comunicar datos</I>:
            obtendrás columnas claras, nombres de campos estables y objetos listos para ser reutilizados. Reserva los
            diccionarios para
            <I>armar llamadas</I> y <I>configurar</I> comandos. Con este criterio simple tus scripts serán más legibles
            hoy y, cuando conozcas el encadenamiento de comandos, gran parte del trabajo ya estará hecho.
        </Fragment>
    </ConclusionsLayout>

    <References>
        <Fragment slot="recommended">
            <WebPage
                title="Everything you wanted to know about PSCustomObject"
                url="https://learn.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject"
                location="Microsoft Learn"
            >
                <Fragment slot="description">
                    <P>
                        Ofrece una guía completa —desde lo básico hasta lo avanzado— sobre el uso de <PowerShellInline
                            code={`[PSCustomObject]`}
                        /> en PowerShell para crear datos estructurados. Explica cómo convertir diccionarios en objetos,
                        agregar o quitar propiedades dinámicamente, clonar instancias y definir comportamientos
                        personalizados mediante <PowerShellInline code={`Add-Member`} /> o <PowerShellInline
                            code={`Update-TypeData`}
                        />.
                    </P>
                    <P>
                        También aborda la importancia del <I>type system</I> de PowerShell: cómo asignar
                        <PowerShellInline code={`PSTypeName`} />, establecer propiedades por defecto para mejorar la
                        presentación en consola y definir tipos personalizados reutilizables en funciones y scripts.
                        Finalmente, el texto enfatiza que dominar <PowerShellInline code={`[PSCustomObject]`} /> permite
                        producir salidas limpias, coherentes y tipadas, facilitando la interoperabilidad y el
                        mantenimiento de los scripts.
                    </P>
                </Fragment>
            </WebPage>
        </Fragment>

        {
            /*
            <Fragment slot="additional">
                ...
            </Fragment> */
        }
    </References>

    <Footnotes>
        <Footnote index={1}>
            Los <I>type accelerators</I> son atajos definidos por PowerShell que permiten instanciar tipos .NET sin
            escribir su nombre completo. Por ejemplo, <PowerShellInline code="[PSCustomObject]" /> es un acelerador de
            <PowerShellInline code="[System.Management.Automation.PSObject]" />. Existen muchos otros, como
            <PowerShellInline code="[hashtable]" /> para <PowerShellInline code="[System.Collections.Hashtable]" /> o
            <PowerShellInline code="[ValidateSet]" /> para <PowerShellInline
                code="[System.Management.Automation.ValidateSetAttribute]"
            />. Puedes aprender más sobre ellos con:
            <PowerShellBlock
                code={`
                    # Mostrar la lista completa de type accelerators disponibles
                    [PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get

                    # Obtener documentación adicional
                    Get-Help about_Type_Accelerators
                `}
            >
                <Fragment slot="title">Explorar los type accelerators</Fragment>
            </PowerShellBlock>
        </Footnote>

        <Footnote index={2}>
            Discusión de referencia: <Link href="https://forums.powershell.org/t/why-ps-custom-object/10826/2"
            >Why PS Custom Object?</Link>
        </Footnote>

        <Footnote index={3}>
            <ul style="list-style-type: disc; margin-left: 1.5rem">
                <li>
                    <PowerShellInline code={`'[A-Za-z0-9-]+'`} />: etiqueta inicial (letras, dígitos, guiones).
                </li>
                <li>
                    <PowerShellInline code={`'(?:\\.[A-Za-z0-9-]+)*'`} />: cero o más etiquetas separadas por puntos
                    (soporta <Mono>localhost</Mono> y <Mono>sub.example.com</Mono>).
                </li>
                <li>
                    <PowerShellInline code={`'(?::\\d+)?'`} />: opcional <Mono>:puerto</Mono> (uno o más dígitos).
                </li>
                <li>
                    Ancla <PowerShellInline code={`'^...$'`} /> para que coincida toda la cadena.
                </li>
            </ul>
            <I>Ejemplos:</I>
            <ul style="list-style-type: disc; margin-left: 1.5rem">
                <li>
                    Coincide: <Mono>example.com</Mono>, <Mono>localhost</Mono>, <Mono>sub.domain.co</Mono>, <Mono
                    >example.com:8080</Mono>, <Mono>192.168.1.1:3000</Mono>
                </li>
                <li>
                    No coincide: <Mono>::1</Mono> (IPv6), cadenas con espacios o caracteres inválidos.
                </li>
            </ul>
            <Warning headingLevel="h5">
                Es intencionalmente permisiva: no valida rangos de octetos IPv4 (p. ej. <Mono>999.999.999.999</Mono>
                pasaría) ni cumple estrictamente RFC para nombres de host. Úsala sólo como heurística ilustrativa. Para
                validación robusta (IPv6 completo, rangos de puerto 0–65535, reglas exactas RFC) conviene usar
                parsers/librerías o validaciones adicionales (por ejemplo utilizando el type accelerator
                <PowerShellInline code={`[IPAddress]`} />).
            </Warning>
        </Footnote>
    </Footnotes>
</NotesLayout>
