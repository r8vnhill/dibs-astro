---
import * as icons from "$icons";
import fs from "fs";
import { Enquote, P } from "~/components/semantics";
import Heading from "~/components/semantics/Heading.astro";
import { Table, TableBody, TableCell, TableHeader, TableRow } from "~/components/starwind/table";
import { Abstract, Definition, Explanation, Important, Info, More, Note, Tip } from "~/components/ui/callouts";
import { OutputBlock, PowerShellBlock, PowerShellInline } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import ToDo from "~/components/utils/ToDo";
import { NotesSection } from "~/layouts";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";

const newPersonPSCustomCode = fs.readFileSync(
    "src/fragments/notes/software-libraries/scripting/structured-output/New-Person.fragment.ps1",
    "utf8",
);
---

<NotesLayout
    title="Salida estructurada en PowerShell"
    description="Si estás leyendo esto es porque se me olvidó agregar la descripción. Se agradece si me lo recuerdas."
    timeMultiplier={1.5} git={{ repo: "dibs-scripts", user: "r8vnhill" }}
>
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-hash-tables">
        <Heading
            headingLevel="h2" Icon={icons.BracketsCurly}
            slot="heading"
        >
            Diccionarios
        </Heading>

        <Definition headingLevel="h3">
            <span slot="title">Diccionarios en PowerShell</span>

            <P>
                En PowerShell, los diccionarios se crean con la sintaxis
                <PowerShellInline code="@{ Clave = Valor }" />. Son tablas de hash que agrupan pares <I>clave–valor</I>
                y permiten acceder a cada valor por su nombre.
            </P>
        </Definition>

        <PowerShellBlock
            code={`
                #Requires -Version 7.5
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $FirstName,

                    [Parameter(Mandatory)]
                    [ValidateNotNullOrWhiteSpace()]
                    [string] $LastName
                )

                @{
                    FirstName = $FirstName
                    LastName  = $LastName
                }
            `}
        >
            <Fragment slot="title">Script que retorna un diccionario</Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" ref="6b3cbfeaf6820f6289c5f8f30db34c526797bf29"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <List>
                <ListItem icon={icons.BracketsCurly}>
                    La sintaxis es <PowerShellInline code="@{ Clave1 = Valor1; Clave2 = Valor2 }" />. Cada par está
                    separado por punto y coma o salto de línea.
                </ListItem>

                <ListItem icon={icons.Key}>
                    Las claves son únicas; si se repite una, su valor anterior se sobrescribe.
                </ListItem>

                <ListItem icon={icons.Warning}>
                    <I><B>No</B></I> se garantiza el orden de inserción de los elementos.
                </ListItem>
            </List>
        </Explanation>

        <Info headingLevel="h3" icon={icons.PlayCircle}>
            <span slot="title">Uso</span>

            <PowerShellBlock
                code={`
                    $result = ./New-Person.ps1 -FirstName Miles -LastName Edgeworth

                    # Acceder a los valores
                    $result.FirstName   # Miles
                    $result["LastName"] # Edgeworth

                    # Mutar el diccionario (agregar y modificar valores)
                    $result.Age = 25

                    # Mostrar el nuevo estado del diccionario
                    $result
                `}
            >
                <Fragment slot="title">Desde <Mono>dibs/scripts/models/</Mono></Fragment>
                <span slot="footer">
                    Los diccionarios en PowerShell son <I>mutables</I>: puedes agregar, modificar o eliminar pares
                    <I>clave–valor</I> en cualquier momento.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h3">
                <List>
                    <ListItem icon={icons.Code}>
                        <B>Tipo:</B> el resultado es un <PowerShellInline code="[hashtable]" />, que almacena los pares
                        <I>clave–valor</I>.
                    </ListItem>

                    <ListItem icon={icons.CursorClick}>
                        <B>Acceso:</B> usa <PowerShellInline code="$h.Clave" /> o <PowerShellInline
                            code='$h["Clave"]'
                        /> para leer valores.
                    </ListItem>

                    <ListItem icon={icons.Pencil}>
                        <B>Mutabilidad:</B> puedes agregar o modificar elementos con <PowerShellInline
                            code="$h.Clave = Valor"
                        /> (incluso si <I>no existe</I>) y eliminarlos con <PowerShellInline
                            code='Remove-Item -Key "Clave"'
                        />.
                    </ListItem>
                </List>
            </Explanation>
        </Info>

        <NotesSection id="h3-splatting-dictionaries">
            <Heading
                headingLevel="h3" Icon={icons.ArrowsLeftRight}
                slot="heading"
            >
                Splatting: pasar diccionarios como parámetros
            </Heading>

            <P>
                En PowerShell puedes <Enquote>desempaquetar</Enquote> un
                <PowerShellInline code="[hashtable]" /> como parámetros nombrados usando el operador <PowerShellInline
                    code="@"
                /> (<I>splatting</I>). Esto mejora legibilidad, evita líneas largas y facilita mantener scripts.
            </P>

            <PowerShellBlock
                code={`
                    # Diccionario de parámetros
                    $copyParams = @{
                        Path        = './data/input.txt'
                        Destination = './backup'
                        Force       = $true
                        Verbose     = $true
                    }

                    # Splatting: pasa las claves como parámetros nombrados
                    Copy-Item @copyParams

                    # Mutabilidad: se puede modificar antes de reutilizar
                    $copyParams.Recurse = $true
                    Copy-Item @copyParams
                `}
            >
                <Fragment slot="title">Diccionario → parámetros</Fragment>
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose
                Copy-Item -Path './data/input.txt' -Destination './backup' -Force -Verbose -Recurse
            `}
            >
                <Fragment slot="title">Equivalencia</Fragment>
                <span slot="footer">
                    Splatting y parámetros explícitos ejecutan lo mismo; cambia sólo la forma de escribirlo. Nota como
                    reducimos la duplicación de código y hacemos las líneas más cortas.
                </span>
            </PowerShellBlock>

            <Explanation headingLevel="h4">
                <List>
                    <ListItem icon={icons.BracketsCurly}>
                        <PowerShellInline code="@{ Clave = Valor }" /> crea un diccionario (<PowerShellInline
                            code="[hashtable]"
                        />).
                    </ListItem>
                    <ListItem icon={icons.ArrowsLeftRight}>
                        <PowerShellInline code="@diccionario" /> aplica sus pares como parámetros nombrados del cmdlet.
                    </ListItem>
                    <ListItem icon={icons.Info}>
                        Los valores <PowerShellInline code="[bool]" /> se interpretan como <I>switches</I> de presencia
                        o ausencia.
                    </ListItem>
                </List>
            </Explanation>

            <Important headingLevel="h4">
                Usaremos <I>diccionarios</I> para valores transitorios y <I>splatting</I>. Para salida estructurada,
                preferiremos <PowerShellInline code="[PSCustomObject]" />.
            </Important>

            <More headingLevel="h4">
                <span slot="title">Continuación de líneas con <PowerShellInline code={"`"} /></span>

                <P>
                    Una alternativa a usar <I>splatting</I> para separar líneas largas es usar el carácter de <Enquote
                    >escape</Enquote> (<PowerShellInline code={"`"} />) al final de la línea. Sin embargo, esto
                    <B>no se recomienda</B> fuera de casos muy puntuales, ya que es propenso a errores difíciles de
                    detectar. El caracter especial <PowerShellInline code={"`"} /> <B>debe ser</B> el último de la
                    línea.
                </P>

                <PowerShellBlock
                    code={`
                        # Esto funciona
                        Write-Output \`
                            "Hello, World!"
                        # Pero...
                        Write-Output \` # ...esto ya no
                            "Hello, World!"
                    `}
                >
                    <span slot="title">Ejemplos de continuación de línea válido e inválido</span>
                    <span slot="footer">
                        El espacio después del <PowerShellInline code={"`"} /> (y antes de <PowerShellInline
                            code={`#`}
                        />) en la segunda llamada hace que falle.
                    </span>
                </PowerShellBlock>

                <P>
                    PowerShell recomienda otras formas de continuar líneas, puedes encontrar más información en la
                    <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing#line-continuation"
                    >documentación oficial</Link>.
                </P>
            </More>
        </NotesSection>
    </NotesSection>

    <NotesSection id="h2-pscustomobject">
        <Heading
            headingLevel="h2" Icon={icons.Table}
            slot="heading"
        >
            Objetos personalizados
        </Heading>

        <PowerShellBlock code={newPersonPSCustomCode}>
            <Fragment slot="title">
                Crear un objeto fuertemente tipado con <PowerShellInline code={`[PSCustomObject]`} />
            </Fragment>
            <DibsSourceLink
                slot="source" file="models/New-Person.ps1"
                repo="scripts" line={13}
                ref="a4dfcdd1f7950134079eeb1e3fafdba682947b76"
            />
        </PowerShellBlock>

        <Explanation headingLevel="h3">
            <B><PowerShellInline code={`[PSCustomObject]@{ ... }`} />:</B> Es un <Enquote>type
                accelerator</Enquote><FootnoteRef index={1} /> que convierte un <PowerShellInline
                code={`[hashtable]`}
            /> en una instancia de <PowerShellInline code={`[PSCustomObject]`} />. Observa que lo único que cambia
            respecto del ejemplo con un diccionario es el prefijo <PowerShellInline code={`[PSCustomObject]`} />. Dentro
            sigues declarando <I>propiedades</I> con pares <PowerShellInline code={`Nombre = Valor`} />. El resultado es
            un objeto con propiedades reales (no solo entradas en un diccionario), apto para mostrarse en tabla y para
            interoperar con el ecosistema de cmdlets de salida.
        </Explanation>

        <NotesSection id="h3-pscustomobject-benefits">
            <Heading
                headingLevel="h3" Icon={icons.GridFour}
                slot="heading"
            >
                Beneficios de <PowerShellInline code="[PSCustomObject]" /> frente a <PowerShellInline
                    code="[hashtable]"
                /><FootnoteRef index={2} />
            </Heading>

            <P>
                Aunque las <PowerShellInline code="[hashtable]" /> son útiles como estructuras clave–valor,
                <PowerShellInline code="[PSCustomObject]" /> ofrece ventajas importantes al generar salida estructurada
                o devolver datos desde cmdlets. Además, encaja mejor con el modelo de encadenamiento de comandos
                (pipeline) que veremos más adelante.
            </P>

            <List>
                <ListItem icon={icons.Table}>
                    <I>Salida tabular predecible:</I> las propiedades se muestran como columnas y conservan el orden en
                    que fueron declaradas.

                    <PowerShellBlock
                        code={`
                            # Hashtable: mapa clave–valor (no tiene propiedades reales)
                            $pokemonHT = @{
                                Name  = "Toxtricity"
                                Types = @("Electric", "Poison")
                            }
                            # Intentar seleccionar columnas por nombre no produce el resultado esperado
                            Format-Table -Property Name, Types -InputObject $pokemonHT

                            # PSCustomObject: convierte claves en propiedades reales (ideal para salida)
                            $pokemonPSCO = [PSCustomObject]$pokemonHT

                            # Ahora sí: columnas y valores aparecen como se espera
                            Format-Table -Property Name, Types -InputObject $pokemonPSCO
                        `}
                    >
                        <span slot="title">
                            Diferencia práctica: <PowerShellInline code="[hashtable]" /> vs <PowerShellInline
                                code="[PSCustomObject]"
                            />
                        </span>
                        <span slot="footer">
                            Este comportamiento coincide con lo descrito por la comunidad: un <I>hashtable</I> no se
                            comporta como un objeto con propiedades al formatear columnas específicas; convertir a
                            <PowerShellInline code={`[PSCustomObject]`} /> evita esa sorpresa.
                        </span>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.Tag}>
                    <I>Control de presentación (TypeNames y propiedades por defecto):</I> a los
                    <PowerShellInline code="[PSCustomObject]" /> se les puede asignar un <I>TypeName</I> y definir qué
                    propiedades se muestran por defecto, mejorando la legibilidad sin perder datos. Para más detalles
                    sobre cómo el sistema de tipos extiende estos comportamientos, consulta:
                    <PowerShellBlock code={`
                        Get-Help about_Types.ps1xml
                    `}>
                        <Fragment slot="title">Explorar cómo utilizar <Mono>Types.ps1xml</Mono></Fragment>
                    </PowerShellBlock>
                </ListItem>

                <ListItem icon={icons.Pipe}>
                    <I>Compatibilidad con el pipeline:</I> muchos comandos esperan objetos con propiedades claras para
                    seleccionar campos por nombre y aplicar formateadores. Los <PowerShellInline
                        code="[PSCustomObject]"
                    /> están pensados para encajar en ese modelo. No entraremos en detalles aquí; basta con saber que
                    más adelante esta elección facilita el flujo de trabajo.
                </ListItem>
            </List>
        </NotesSection>

        <Important headingLevel="h3">
            En este curso utilizaremos <PowerShellInline code="[PSCustomObject]" /> para mantener la simplicidad y
            centrarnos en la forma de los datos. Si necesitas reglas más estrictas, métodos, herencia o contratos de
            tipos más claros para herramientas y módulos, considera migrar a <I>clases</I>.
        </Important>

        <More headingLevel="h3">
            <span slot="title">Clases y salida tipada</span>

            <P>
                PowerShell permite definir <I>clases</I> para modelar datos con propiedades y métodos, aprovechando
                conceptos conocidos de OOP (encapsulación y herencia). Usarlas mejora el autocompletado del editor y
                ayuda a detectar errores de tipos al escribir. Para describir el tipo de salida de una <I>función</I>
                existe el atributo <PowerShellInline code="[OutputType()]" /> (útil para documentación y tooling), pero
                a nivel de <I>script</I> no podemos declarar un tipo de salida explícito (esta es una ventaja de usar
                funciones o módulos que puedes considerar más adelante).
            </P>

            <P>
                A continuación definimos una clase <PowerShellInline code={`[Person]`} /> en un módulo (<Mono
                >.psm1</Mono>) y luego la usamos desde un script (<Mono>.ps1</Mono>) para crear y devolver un objeto.
            </P>

            <PowerShellBlock
                code={`
                    class Person {
                        [string] $FirstName
                        [string] $LastName

                        Person([string] $first, [string] $last) {
                            $this.FirstName = $first
                            $this.LastName  = $last
                        }

                        [string] ToString() {
                            return '{0} {1}' -f $this.FirstName, $this.LastName
                        }
                    }
                `}
            >
                <span slot="title">Definir un tipo de datos con <code>class</code> (módulo .psm1)</span>
                <span slot="footer">
                    Un archivo <Mono>.psm1</Mono> es un <I>módulo</I> de PowerShell: puede exportar tipos (clases),
                    funciones u otros elementos para ser reutilizados. Aquí sólo definimos la clase <PowerShellInline
                        code={`[Person]`}
                    />.
                    <br />
                    A diferencia de los scripts y funciones, los <I>métodos</I> deben tener un <PowerShellInline
                        code={`return`}
                    /> explícito para devolver valores.
                </span>
                <DibsSourceLink
                    slot="source" file="models/Person.psm1"
                    repo="scripts"
                />
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                    using module ./Person.psm1

                    #Requires -Version 7.5
                    param(
                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $FirstName,

                        [Parameter(Mandatory)]
                        [ValidateNotNullOrWhiteSpace()]
                        [string] $LastName
                    )

                    # Función local al script (no se exporta): deja el flujo claro y permite reutilizar internamente.
                    function Script:New-Person {
                        [OutputType([Person])]
                        param ()

                        [Person]::new($FirstName, $LastName)
                    }

                    # Devolver la instancia tipada como salida del script
                    New-Person
                `}
            >
                <span slot="title">Usar el módulo y devolver una instancia tipada (script <Mono>.ps1</Mono>)</span>

                <span slot="footer">
                    <B>Notas breves:</B>
                    <ul style="list-style-type: disc; margin-left: 1.5rem">
                        <li>
                            <PowerShellInline code={`using module ./Person.psm1`} /> carga el módulo con la clase
                            <PowerShellInline code={`[Person]`} />.
                        </li>
                        <li>
                            El prefijo <PowerShellInline code={`Script:`} /> hace que <PowerShellInline
                                code={`New-Person`}
                            /> sea <I>local</I> al script (no se exporta).
                        </li>
                        <li>La salida del script es el objeto <PowerShellInline code={`[Person]`} /> recién creado.</li>
                    </ul>
                </span>
                <DibsSourceLink
                    slot="source" file="models/New-PersonClass.ps1"
                    repo="scripts"
                />
            </PowerShellBlock>

            <PowerShellBlock
                code={`
                    $person = ./New-PersonClass.ps1 -FirstName Naoki -LastName Urasawa
                    $person.ToString()  # "Naoki Urasawa"
                    $person.FirstName   # "Naoki"
                    $person.LastName    # "Urasawa"
                `}
            >
                <span slot="title">Desde <Mono>scripts/models/</Mono></span>
            </PowerShellBlock>

            <P>
                Para aprender más consulta la documentación oficial:
            </P>

            <PowerShellBlock code={`Get-Help about_Classes`}>
                <Fragment slot="title">Explorar la documentación de clases</Fragment>
            </PowerShellBlock>
        </More>
    </NotesSection>

    <Footnotes>
        <Footnote index={1}>
            Los <I>type accelerators</I> son atajos definidos por PowerShell que permiten instanciar tipos .NET sin
            escribir su nombre completo. Por ejemplo, <PowerShellInline code="[PSCustomObject]" /> es un acelerador de
            <PowerShellInline code="[System.Management.Automation.PSObject]" />. Existen muchos otros, como
            <PowerShellInline code="[hashtable]" /> para <PowerShellInline code="[System.Collections.Hashtable]" /> o
            <PowerShellInline code="[ValidateSet]" /> para <PowerShellInline
                code="[System.Management.Automation.ValidateSetAttribute]"
            />. Puedes aprender más sobre ellos con:
            <PowerShellBlock
                code={`
                    # Mostrar la lista completa de type accelerators disponibles
                    [PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get

                    # Obtener documentación adicional
                    Get-Help about_Type_Accelerators
                `}
            >
                <Fragment slot="title">Explorar los type accelerators</Fragment>
            </PowerShellBlock>
        </Footnote>

        <Footnote index={2}>
            Discusión de referencia: <Link href="https://forums.powershell.org/t/why-ps-custom-object/10826/2"
            >Why PS Custom Object?</Link>
        </Footnote>
    </Footnotes>

    {
        /*

        <NotesSection id="h2-compare">
            <Heading
                headingLevel="h2" Icon={icons.ArrowsLeftRight}
                slot="heading"
            >
                Diferencias y usos
            </Heading>

            <Explanation>
                <Table>
                    <TableHeader>
                        <TableRow>
                            <TableCell>Aspecto</TableCell>
                            <TableCell>Hash table</TableCell>
                            <TableCell>PSCustomObject</TableCell>
                        </TableRow>
                    </TableHeader>

                    <TableBody>
                        <TableRow>
                            <TableCell>Tipo</TableCell>
                            <TableCell>[hashtable]</TableCell>
                            <TableCell>[pscustomobject]</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Acceso</TableCell>
                            <TableCell>$h['Clave']</TableCell>
                            <TableCell>$o.Propiedad</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Orden</TableCell>
                            <TableCell>Desordenado (usa [ordered] para mantenerlo)</TableCell>
                            <TableCell>Ordenado por defecto</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Mutabilidad</TableCell>
                            <TableCell>Mutable (puedes agregar o quitar claves)</TableCell>
                            <TableCell>Generalmente inmutable</TableCell>
                        </TableRow>
                        <TableRow>
                            <TableCell>Ideal para</TableCell>
                            <TableCell>Configuraciones, parámetros o diccionarios</TableCell>
                            <TableCell>Datos tabulares, reportes o exportación</TableCell>
                        </TableRow>
                    </TableBody>
                </Table>
            </Explanation>
        </NotesSection>

        <NotesSection id="h2-apply">
            <Heading
                headingLevel="h2" Icon={icons.Wrench}
                slot="heading"
            >
                Aplicaciones prácticas
            </Heading>

            <List>
                <ListItem icon={icons.FileText}>
                    Crear reportes:
                    <PowerShellInline code="[pscustomobject]@{ Nombre = $n; Estado = $e; Fecha = Get-Date }" />.
                </ListItem>

                <ListItem icon={icons.Export}>
                    Exportar resultados:
                    <PowerShellInline code="$data | Export-Csv -Path './salida.csv' -NoTypeInformation" />.
                </ListItem>

                <ListItem icon={icons.Code}>
                    Definir configuraciones o parámetros con
                    <PowerShellInline code="@{ }" /> y pasarlos mediante
                    <I>splatting</I>:
                    <PowerShellInline code="Invoke-Script @config" />.
                </ListItem>
            </List>
        </NotesSection>

        <ConclusionsLayout>
            <P slot="conclusions">
                La <B>salida estructurada</B> convierte scripts en herramientas que pueden interoperar: en lugar de texto,
                producen datos reutilizables. Las hash tables son útiles para agrupar pares clave–valor, mientras que los
                objetos personalizados permiten entregar resultados consistentes y exportables.
            </P>

            <Fragment slot="key-points">
                <ListItem icon={icons.BracketsCurly}>
                    Usa <PowerShellInline code="@{ }" /> para agrupar claves y valores.
                </ListItem>
                <ListItem icon={icons.Table}>
                    Convierte esa tabla en un objeto legible con
                    <PowerShellInline code="[pscustomobject]" />.
                </ListItem>
                <ListItem icon={icons.Export}>
                    Aprovecha su formato tabular para exportar fácilmente a CSV o JSON.
                </ListItem>
            </Fragment>
        </ConclusionsLayout>
            */
    }
</NotesLayout>
