---
import * as icons from "~/assets/img/icons";
import NotesLayout from "~/layouts/NotesLayout.astro";
import ToDo from "~/components/utils/ToDo.tsx";
import { Abstract, Definition, More, Tip } from "~/components/ui/callouts";
import { InlineBash, InlinePowerShell, Terminals } from "~/components/ui/code";
import { FootnoteRef, Footnotes, Footnote } from "~/components/ui/footnotes";
import { List, ListItem } from "~/components/ui/list";
import NotesSection from "~/layouts/NotesSection.astro";
import Heading from "~/components/semantics/Heading.astro";
import { DibsSourceLink, Link } from "~/components/ui/links";
---

<NotesLayout title="Scripting para automatización de tareas básicas">
  <Abstract>
    <ToDo
      client:only="react"
      metadata={{
        tasks: ["..."],
      }}
    />
  </Abstract>

  <NotesSection id="task-automation">
    <Heading headingLevel="h2" Icon={icons.Gear}
      >Automatización de tareas</Heading
    >

    La automatización convierte actividades repetitivas en procesos <em
      >predecibles, rápidos y auditables</em
    >. En bibliotecas de software esto impacta directamente en la calidad de los
    lanzamientos, la confianza de quienes contribuyen y la velocidad de
    iteración.

    <Definition>
      <Fragment slot="title">¿Qué entendemos por “tarea”?</Fragment>
      Una tarea es una unidad de trabajo con <strong>entrada</strong> conocida, <strong
        >pasos</strong
      > definidos y <strong>salida</strong> verificable. Automatizar es describir
      esa unidad de forma que cualquier persona del equipo pueda ejecutarla con el
      mismo resultado en cualquier entorno.
    </Definition>

    <NotesSection id="why-automate">
      <Heading headingLevel="h3" Icon={icons.Lightbulb}>
        ¿Por qué automatizar?
      </Heading>

      <p>
        Automatizar evita errores humanos en tareas repetitivas y libera tiempo
        que, acumulado, puede ser significativo. Además, estandariza procesos,
        asegurando que todas las personas trabajen bajo las mismas reglas y con
        resultados consistentes.
      </p>

      <p>
        Esto no solo mejora la calidad del software, sino que también facilita
        la colaboración en equipo, permitiendo concentrarse en el diseño y
        evolución de la biblioteca en lugar de en pasos mecánicos.
      </p>
    </NotesSection>

    <NotesSection id="...">
    <Heading headingLevel="h3" Icon={icons.PuzzlePiece}
      >¿Por qué es importante para bibliotecas de software?</Heading
    >
    <ToDo
    <List>
      <ListItem icon={icons.Broom}
        >Formateo y estilo: mantener el código consistente sin discusiones.</ListItem
      >
      <ListItem icon={icons.MagnifyingGlass}
        >Revisión estática y pruebas: validar calidad antes de integrar cambios.</ListItem
      >
      <ListItem icon={icons.Package}
        >Construcción y empaquetado: generar artefactos listos para publicar.</ListItem
      >
      <ListItem icon={icons.Notebook}
        >Documentación: generar y verificar ejemplos de uso de forma continua.</ListItem
      >
      <ListItem icon={icons.Tag}
        >Versionado y notas de lanzamiento: aplicar reglas claras (semánticas) y
        producir changelog.</ListItem
      >
      <ListItem icon={icons.CloudArrowUp}
        >Publicación: distribuir la biblioteca de forma segura y trazable.</ListItem
      >
    </List>
    </NotesSection>

    <Heading headingLevel="h3" Icon={icons.Sliders}
      >Niveles de automatización</Heading
    >
    <List>
      <ListItem icon={icons.Hand}
        >Manual guiado: checklist claro y pasos documentados (base mínima).</ListItem
      >
      <ListItem icon={icons.Terminal}
        >Automatización local: comandos encapsulados y repetibles en el entorno
        del desarrollador.</ListItem
      >
      <ListItem icon={icons.Cpu}
        >Orquestación: herramientas que definen dependencias, orden y resultados
        esperados (incluye cacheo e incrementalidad).</ListItem
      >
      <ListItem icon={icons.Rocket}
        >Integración y entrega continuas: ejecuta tareas en cada cambio y
        consolida artefactos y reportes.</ListItem
      >
    </List>

    <Heading headingLevel="h3" Icon={icons.Compass}
      >Principios de diseño</Heading
    >
    <List>
      <ListItem icon={icons.Target}>
        <strong>Idempotencia</strong>: ejecutar varias veces produce el mismo
        estado final.
      </ListItem>
      <ListItem icon={icons.Eye}>
        <strong>Ensayo seguro</strong>: modo “simular” para ver acciones antes
        de aplicarlas.
      </ListItem>
      <ListItem icon={icons.Path}>
        <strong>Rutas y entornos deterministas</strong>: no depender de estados
        “misteriosos” en la máquina.
      </ListItem>
      <ListItem icon={icons.FileMagnifyingGlass}>
        <strong>Observabilidad</strong>: logs útiles, códigos de salida claros y
        artefactos verificables.
      </ListItem>
      <ListItem icon={icons.ArrowsLeftRight}>
        <strong>Composición</strong>: tareas pequeñas que se combinan en flujos
        más grandes.
      </ListItem>
      <ListItem icon={icons.GlobeHemisphereWest}>
        <strong>Portabilidad</strong>: mismas instrucciones para todos los
        sistemas del equipo.
      </ListItem>
    </List>

    <Heading headingLevel="h3" Icon={icons.MapTrifold}
      >Cómo pensar una tarea</Heading
    >
    <List>
      <ListItem icon={icons.PlayCircle}
        ><strong>Disparador</strong>: ¿cuándo corre? (local, pre-commit, en CI,
        antes de publicar).</ListItem
      >
      <ListItem icon={icons.FolderOpen}
        ><strong>Entradas/salidas</strong>: archivos, rutas, artefactos; qué se
        produce y dónde queda.</ListItem
      >
      <ListItem icon={icons.WarningCircle}
        ><strong>Precondiciones</strong>: requisitos que deben cumplirse antes
        de ejecutar.</ListItem
      >
      <ListItem icon={icons.Checks}
        ><strong>Criterios de éxito</strong>: cómo sabrás que terminó bien (y
        qué hacer si no).</ListItem
      >
      <ListItem icon={icons.Gauge}
        ><strong>Performance</strong>: incrementalidad, cache y paralelismo
        cuando tenga sentido.</ListItem
      >
    </List>

    <Tip class="my-4">
      <Fragment slot="title">Resultado esperado</Fragment>
      Al terminar este módulo tendrás un vocabulario común y un mapa mental para
      identificar qué automatizar, por qué y con qué nivel de rigurosidad. En la
      siguiente sección usaremos estas ideas para estructurar procesos de construcción
      y publicación de forma práctica.
    </Tip>
  </NotesSection>

  <NotesSection id="scripting-101">
    <Heading headingLevel="h2" Icon={icons.Terminal}
      >Scripting 101: PowerShell y Bash</Heading
    >

    <Definition>
      <Fragment slot="title">El patrón de ensayo seguro</Fragment>
      <p>
        Siempre que un script <em>cambie cosas</em>, ensaya primero: en
        PowerShell con
        <InlinePowerShell code="-WhatIf" /> y en Bash activando <InlineBash
          code="DRY_RUN=true"
        />. Así ves lo que haría sin tocar nada.<FootnoteRef index={101} />
      </p>
    </Definition>

    <Terminals
      powerShellCode={`
# PowerShell — script esqueleto con ensayo seguro
#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess, ConfirmImpact='Medium')]
param(
  [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string] $Target
)

$ErrorActionPreference = 'Stop'

if (-not (Test-Path -LiteralPath $Target -PathType Container)) {
  if ($PSCmdlet.ShouldProcess($Target, 'Create directory')) {
    New-Item -ItemType Directory -Path $Target -Force | Out-Null
  }
}

Write-Verbose "All good at '$Target'"
    `}
      bashCode={`#!/usr/bin/env bash
# Bash — script esqueleto con DRY_RUN
set -euo pipefail

TARGET="\${1:-}"
if [[ -z "\${TARGET}" ]]; then
  echo "Usage: scaffold.sh <target-dir>" >&2
  exit 1
fi

run () {
  if [[ "\${DRY_RUN:-false}" == "true" ]]; then
    echo "[dry-run] $*"
  else
    eval "$@"
  fi
}

[[ -d "\${TARGET}" ]] || run "mkdir -p \"\${TARGET}\""
echo "All good at '\${TARGET}'"
    `}
    >
      <Fragment slot="powershell-title"
        >Plantilla mínima de PowerShell (con <code>-WhatIf</code>)</Fragment
      >
      <Fragment slot="powershell-explanation">
        <icons.List>
          <ListItem icon={icons.Info}>
            <InlinePowerShell code="[CmdletBinding(SupportsShouldProcess)]" /> convierte
            el script en
            <em>cmdlet avanzado</em> y habilita <InlinePowerShell
              code="-WhatIf"
            /> /
            <InlinePowerShell code="-Confirm" />.
          </ListItem>
          <ListItem icon={icons.FolderPlus}>
            <InlinePowerShell
              code="Test-Path -LiteralPath ... -PathType Container"
            /> comprueba la carpeta sin interpretar comodines. <InlinePowerShell
              code="$PSCmdlet.ShouldProcess"
            /> anuncia y controla la acción (puedes simular con <InlinePowerShell
              code="-WhatIf"
            />).
          </ListItem>
          <ListItem icon={icons.SpeakerHigh}>
            <InlinePowerShell code="Write-Verbose" /> aparece al ejecutar con <InlinePowerShell
              code="-Verbose"
            />.
          </ListItem>
        </icons.List>
      </Fragment>

      <Fragment slot="bash-title"
        >Plantilla mínima de Bash (con <code>DRY_RUN</code>)</Fragment
      >
      <Fragment slot="bash-explanation">
        <icons.List>
          <ListItem icon={icons.Bug}>
            <InlineBash code="set -euo pipefail" /> endurece el script:
            <icons.List>
              <ListItem icon={icons.WarningCircle}
                ><InlineBash code="-e" /> aborta si un comando falla.</ListItem
              >
              <ListItem icon={icons.Question}
                ><InlineBash code="-u" /> falla si usas variables sin definir.</ListItem
              >
              <ListItem icon={icons.ArrowsLeftRight}
                ><InlineBash code="-o pipefail" /> propaga errores en <em
                  >pipelines</em
                >.</ListItem
              >
            </icons.List>
          </ListItem>
          <ListItem icon={icons.Function}>
            <InlineBash code="run(){ ... }" /> centraliza ejecución real o simulada
            con <InlineBash code="DRY_RUN=true" />.
          </ListItem>
          <ListItem icon={icons.WarningCircle}>
            Validación de argumentos: <InlineBash
              code='if [[ -z "${1:-}" ]]; then ... fi'
            /> imprime <em>usage</em> en <InlineBash code="stderr" /> y sale.
          </ListItem>
        </icons.List>
      </Fragment>
    </Terminals>

    <Heading headingLevel="h3" Icon={icons.Path}>Rutas y portabilidad</Heading>
    <Terminals
      powerShellCode={`
# Normalizar una ruta relativa con base en el directorio actual
$root = if ([IO.Path]::IsPathRooted($ProjectRoot)) { $ProjectRoot }
        else { Join-Path -Path $PWD.Path -ChildPath $ProjectRoot }

Write-Verbose "Root: $root"
    `}
      bashCode={`#!/usr/bin/env bash
set -euo pipefail

PROJECT_ROOT="\${1:-}"
case "\${PROJECT_ROOT}" in
  /*|?:/*) ROOT="\${PROJECT_ROOT}" ;;     # absoluta (Unix) o "C:/..." (Windows/MSYS)
  *)       ROOT="\${PWD}/\${PROJECT_ROOT}" ;;
esac
echo "Root: \${ROOT}"
    `}
    >
      <Fragment slot="powershell-title"
        >PowerShell: normalización de rutas</Fragment
      >
      <Fragment slot="powershell-explanation">
        <icons.List>
          <ListItem icon={icons.Path}
            ><InlinePowerShell code="Join-Path $PWD.Path ..." /> convierte rutas
            relativas en absolutas.</ListItem
          >
          <ListItem icon={icons.Hash}
            ><InlinePowerShell code="$PWD" /> es el directorio actual.</ListItem
          >
        </icons.List>
      </Fragment>

      <Fragment slot="bash-title">Bash: normalización de rutas</Fragment>
      <Fragment slot="bash-explanation">
        <icons.List>
          <ListItem icon={icons.Path}
            ><InlineBash code="$PWD" /> es el directorio actual.</ListItem
          >
          <ListItem icon={icons.Terminal}>
            <InlineBash code="case ... in ... esac" /> compara texto con patrones;
            usamos
            <InlineBash code="/*|?:/*" /> para rutas absolutas, y el comodín <InlineBash
              code="*"
            /> para relativas.
          </ListItem>
        </icons.List>
      </Fragment>
    </Terminals>

    <Heading headingLevel="h3" Icon={icons.Rocket}
      >Ejecutar herramientas de forma segura</Heading
    >
    <Terminals
      powerShellCode={`
# Localizar el ejecutable correcto y ejecutar con argumentos
$gradle = (Get-Command gradle -ErrorAction Stop).Source
& $gradle -p $root init @GradleOptions
if ($LASTEXITCODE) { throw "Gradle exited with code $LASTEXITCODE." }
    `}
      bashCode={`#!/usr/bin/env bash
set -euo pipefail

command -v gradle >/dev/null 2>&1 || { echo "Gradle not found" >&2; exit 127; }
gradle -p "\${ROOT}" init "\${GRADLE_OPTS[@]}"
    `}
    >
      <Fragment slot="powershell-title"
        >PowerShell: localizar y ejecutar</Fragment
      >
      <Fragment slot="powershell-explanation">
        <icons.List>
          <ListItem icon={icons.MagnifyingGlass}
            ><InlinePowerShell code="Get-Command ... .Source" /> obtiene la ruta
            real del ejecutable (evita alias).</ListItem
          >
          <ListItem icon={icons.Terminal}
            ><InlinePowerShell code="&" /> es el <em>call operator</em> (ejecuta
            la ruta). <InlinePowerShell code="@Args" /> = <em>splatting</em> de arrays.</ListItem
          >
          <ListItem icon={icons.WarningCircle}
            ><InlinePowerShell code="$LASTEXITCODE" /> contiene el código de salida
            del último proceso nativo (0 = OK).</ListItem
          >
        </icons.List>
      </Fragment>

      <Fragment slot="bash-title">Bash: validar y ejecutar</Fragment>
      <Fragment slot="bash-explanation">
        <icons.List>
          <ListItem icon={icons.MagnifyingGlass}
            ><InlineBash code="command -v gradle" /> valida que exista en <InlineBash
              code="$PATH"
            />.</ListItem
          >
          <ListItem icon={icons.Code}
            ><InlineBash code='"${GRADLE_OPTS[@]}"' /> preserva cada flag como elemento
            (no rompe espacios).</ListItem
          >
        </icons.List>
      </Fragment>
    </Terminals>

    <Heading headingLevel="h3" Icon={icons.Gear}
      >Buenas prácticas express</Heading
    >
    <icons.List>
      <ListItem icon={icons.CheckCircle}>
        <strong>Siempre ensaya</strong>: <InlinePowerShell code="-WhatIf" /> o <InlineBash
          code="DRY_RUN=true"
        />.
      </ListItem>
      <ListItem icon={icons.CheckCircle}>
        <strong>Valida entradas</strong>: parámetros obligatorios (PS) / <InlineBash
          code="if [[ -z ... ]]"
        /> (Bash).
      </ListItem>
      <ListItem icon={icons.CheckCircle}>
        <strong>Falla rápido</strong>: <InlinePowerShell
          code="$ErrorActionPreference='Stop'"
        /> /
        <InlineBash code="set -euo pipefail" />.
      </ListItem>
      <ListItem icon={icons.CheckCircle}>
        <strong>Rutas seguras</strong>: <InlinePowerShell code="Join-Path" /> y <InlineBash
          code="$PWD"
        /> para absolutas.
      </ListItem>
      <ListItem icon={icons.CheckCircle}>
        <strong>Mensajería útil</strong>: usa <InlinePowerShell
          code="Write-Verbose"
        /> y escribe <em>usage</em> a <InlineBash code="stderr" />.
      </ListItem>
    </icons.List>

    <More>
      <Fragment slot="title">Reutilizar utilidades</Fragment>
      <p>
        Extrae helpers a archivos reutilizables para mantener los scripts
        simples. Ej.: un
        <InlineBash code="run.sh" /> que encapsule ejecución real o simulada con
        <InlineBash code="DRY_RUN" />, y un módulo de PowerShell que exporte
        funciones con <InlinePowerShell code="SupportsShouldProcess" />.
      </p>
      <Terminals
        powerShellCode={`
# Module.psm1 (extracto)
function Invoke-Safely {
  [CmdletBinding(SupportsShouldProcess)]
  param([Parameter(Mandatory)][string]$Action,[Parameter(Mandatory)][scriptblock]$Do)
  if ($PSCmdlet.ShouldProcess($Action)) { & $Do }
}
Export-ModuleMember -Function Invoke-Safely
      `}
        bashCode={`#!/usr/bin/env bash
# run.sh — reutilizable
set -euo pipefail
if [[ "\${DRY_RUN:-false}" == "true" ]]; then echo "[dry-run] $*"; else eval "$@"; fi
      `}
      >
        <Fragment slot="powershell-title"
          >PowerShell: helper reutilizable</Fragment
        >
        <Fragment slot="bash-title">Bash: runner reutilizable</Fragment>
      </Terminals>
    </More>

    <Footnotes>
      <Footnote index={101}>
        <p class="mb-2">
          Ejemplo de <strong>error detectado por el ensayo</strong> al no normalizar
          ruta en PowerShell:
        </p>
        <pre
          class="bg-base-200 text-xs rounded p-3 overflow-x-auto">
What if: Performing the operation "Create Directory" on target "Destination: C:\Users\usuario\veritas".
What if: Performing the operation "gradle init" on target "C:\Users\usuario\veritas".
      </pre>
        <p class="mt-2">
          La corrección fue usar <InlinePowerShell
            code="Join-Path -Path $PWD.Path -ChildPath ..."
          /> para anclar al directorio actual. En Bash el equivalente práctico es
          anteponer <InlineBash code="$PWD" />.
        </p>
      </Footnote>
    </Footnotes>
  </NotesSection>
  <NotesSection id="...">
    <Heading headingLevel="h2" Icon={icons.GitBranch}
      >Inicializa y versiona con GitLab (ensayo primero)</Heading
    >

    <p class="mb-4">
      Si quieres versionar tu estructura desde el inicio, automatiza la creación
      del repo local y remoto en GitLab.
      <strong>Primero ensaya</strong> con <InlinePowerShell code="-WhatIf" /> (PowerShell)
      o
      <InlineBash code="--dry-run" /> (Bash) para ver qué ocurrirá sin realizar cambios.
    </p>

    <Terminals
      powerShellCode={`
#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
param(
  [ValidateNotNullOrEmpty()]
  [Parameter(Mandatory)]
  [string] $User,

  [ValidateNotNullOrEmpty()]
  [string] $RepositoryDirectory = $PWD.Path,

  [string] $RepositoryName,
  [string] $Prefix
)

$ErrorActionPreference = 'Stop'

# Normalizar y validar carpeta destino (acepta relativa)
$RepositoryDirectory = (Resolve-Path -LiteralPath $RepositoryDirectory -ErrorAction Stop).Path
$repoDirInfo = Get-Item -LiteralPath $RepositoryDirectory
if (-not $repoDirInfo.PSIsContainer) {
  throw "The path '$RepositoryDirectory' is not a directory."
}

# Derivar nombre/prefijo si faltan
if (-not $RepositoryName -or [string]::IsNullOrWhiteSpace($RepositoryName)) {
  $RepositoryName = $repoDirInfo.Name.ToLower()
}
if (-not $Prefix -and $repoDirInfo.Parent) {
  $Prefix = $repoDirInfo.Parent.Name.ToLower()
}

# Nombre final remoto
$target = if ([string]::IsNullOrWhiteSpace($Prefix)) { $RepositoryName } else { "$Prefix-$RepositoryName" }

# Crear remoto en GitLab (ensayable con -WhatIf/-Confirm)
if ($PSCmdlet.ShouldProcess($target, 'Create GitLab repository')) {
  Push-Location -LiteralPath $repoDirInfo.FullName
  try {
    git init
    glab repo create $target --public
    if ($LASTEXITCODE) { throw "glab exited with code $LASTEXITCODE." }
    git remote add origin "https://gitlab.com/$User/$target.git"
  }
  finally {
    Pop-Location
  }
}
  `}
      bashCode={`#!/usr/bin/env bash
set -euo pipefail

USER=""
REPO_DIR="$(pwd)"
REPO_NAME=""
PREFIX=""
DRY_RUN=false

usage() {
  echo "Usage: $0 -u <user> [-d <directory>] [-n <repo_name>] [-p <prefix>] [--dry-run]"
  exit 1
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -u|--user) USER="$2"; shift 2 ;;
    -d|--dir) REPO_DIR="$2"; shift 2 ;;
    -n|--name) REPO_NAME="$2"; shift 2 ;;
    -p|--prefix) PREFIX="$2"; shift 2 ;;
    --dry-run) DRY_RUN=true; shift ;;
    *) usage ;;
  esac
done

[[ -n "$USER" ]] || { echo "Error: user is required"; usage; }
[[ -d "$REPO_DIR" ]] || { echo "Error: '$REPO_DIR' is not a directory"; exit 1; }

# Derivar nombre/prefijo si faltan
if [[ -z "$REPO_NAME" ]]; then
  REPO_NAME="$(basename "$REPO_DIR" | tr '[:upper:]' '[:lower:]')"
fi
if [[ -z "$PREFIX" ]]; then
  PARENT="$(dirname "$REPO_DIR")"
  PREFIX="$(basename "$PARENT" | tr '[:upper:]' '[:lower:]')"
fi

TARGET="$REPO_NAME"
if [[ -n "$PREFIX" ]]; then
  TARGET="$PREFIX-$REPO_NAME"
fi

echo "Repositorio remoto: $TARGET"

run() {
  if $DRY_RUN; then
    echo "[dry-run] $*"
  else
    eval "$@"
  fi
}

(
  cd "$REPO_DIR"
  run "git init"
  run "glab repo create $TARGET --public"
  run "git remote add origin https://gitlab.com/$USER/$TARGET.git"
)
  `}
    >
      <Fragment slot="powershell-title"
        >PowerShell: crear repo local + remoto en GitLab (con <code
          >-WhatIf</code
        >)</Fragment
      >
      <DibsSourceLink
        repo="scripts"
        file="ps1/New-GitLabRepository.ps1"
        slot="powershell-source"
      />
      <Fragment slot="powershell-explanation">
        <List>
          <ListItem icon={icons.Info}>
            <InlinePowerShell
              code="[CmdletBinding(SupportsShouldProcess, ConfirmImpact='Medium')]"
            /> habilita
            <InlinePowerShell code="-WhatIf" />/<InlinePowerShell
              code="-Confirm"
            /> para ensayar cambios antes de aplicarlos.
          </ListItem>
          <ListItem icon={icons.Path}>
            <InlinePowerShell code="Resolve-Path -LiteralPath" /> normaliza rutas
            y evita comodines; luego se valida que sea carpeta con <InlinePowerShell
              code="Get-Item"
            />.
          </ListItem>
          <ListItem icon={icons.TextB}>
            Si faltan <InlinePowerShell code="$RepositoryName" /> o <InlinePowerShell
              code="$Prefix"
            />, se derivan del árbol de carpetas.
          </ListItem>
          <ListItem icon={icons.CloudArrowUp}>
            <InlinePowerShell code="glab repo create $target --public" /> crea el
            remoto; si falla (<InlinePowerShell code="$LASTEXITCODE" /> ≠ 0) se aborta
            con mensaje claro.
          </ListItem>
        </List>
      </Fragment>

      <Fragment slot="bash-title"
        >Bash/Zsh: crear repo local + remoto en GitLab (con <code
          >--dry-run</code
        >)</Fragment
      >
      <DibsSourceLink
        repo="scripts"
        file="sh/new-gitlab-repository.sh"
        slot="bash-source"
      />
      <Fragment slot="bash-explanation">
        <List>
          <ListItem icon={icons.Bug}>
            <InlineBash code="set -euo pipefail" />: aborta en errores,
            variables no definidas y fallos en pipelines.
          </ListItem>
          <ListItem icon={icons.Terminal}>
            Flags: <InlineBash code="-u/--user" />, <InlineBash
              code="-d/--dir"
            />, <InlineBash code="-n/--name" />,
            <InlineBash code="-p/--prefix" />, <InlineBash code="--dry-run" />.
          </ListItem>
          <ListItem icon={icons.Eye}>
            <InlineBash code="DRY_RUN=true" /> imprime acciones (no las ejecuta).
            Quita <InlineBash code="--dry-run" /> para aplicar.
          </ListItem>
          <ListItem icon={icons.TextB}>
            Deriva <InlineBash code="TARGET" /> como <code>prefix-name</code> si
            hay prefijo; útil para estandarizar nombres.
          </ListItem>
        </List>
      </Fragment>
    </Terminals>

    <Heading headingLevel="h3" Icon={icons.ListChecks}
      >Flujo sugerido (ensayo → aplicar)</Heading
    >

    <Terminals
      powerShellCode={`
Set-Location 'dibs'
$gitlabUser = '<TU-USUARIO>'  # <- reemplaza aquí
.\scripts\ps1\New-GitLabRepository.ps1 -User $gitlabUser -RepositoryDirectory .\scripts -WhatIf
.\scripts\ps1\New-GitLabRepository.ps1 -User $gitlabUser -RepositoryName index -Prefix dibs -WhatIf
# Si el ensayo luce bien, repite sin -WhatIf
  `}
      bashCode={`
cd dibs
GITLAB_USER="<TU-USUARIO>"  # <- reemplaza aquí
./scripts/sh/new-gitlab-repository.sh -u "$GITLAB_USER" -d ./scripts --dry-run
./scripts/sh/new-gitlab-repository.sh -u "$GITLAB_USER" -n index -p dibs --dry-run
# Si el ensayo luce bien, repite sin --dry-run
  `}
    >
      <Fragment slot="powershell-explanation">
        <p>
          Elige <strong>no</strong> crear carpeta local adicional cuando el asistente
          de <InlinePowerShell code="glab" /> lo pregunte; el script ya opera dentro
          de tu estructura.
        </p>
      </Fragment>
      <Fragment slot="bash-explanation">
        <p>
          Revisa la salida de <InlineBash code="DRY_RUN" />. Si todo se ve bien,
          ejecuta de nuevo sin <InlineBash code="--dry-run" />.
        </p>
      </Fragment>
    </Terminals>

    <Tip class="my-4">
      <Fragment slot="title">.gitignore</Fragment>
      Genera un <code>.gitignore</code> adecuado para cada repo; útil:
      <Link href="https://www.toptal.com/developers/gitignore/"
        >toptal.com/developers/gitignore</Link
      >.
    </Tip>

    <Terminals
      powerShellCode={`
# Commit del repo 'dibs/scripts' y subirlo. Luego agregarlo como submódulo en 'dibs/index'.
Push-Location '.\scripts'
git add .
git commit -m "chore(scripts): initial scaffolding and GitLab integration utilities"
git push -u origin main
Pop-Location

git submodule add "https://gitlab.com/$gitlabUser/dibs-scripts.git" scripts
git add .gitmodules scripts
git commit -m "chore(index): add scripts as submodule"
git push -u origin main
  `}
      bashCode={`
# Commit del repo 'dibs/scripts' y subirlo. Luego agregarlo como submódulo en 'dibs/index'.
(
  cd scripts
  git add .
  git commit -m "chore(scripts): initial scaffolding and GitLab integration utilities"
  git push -u origin main
)

git submodule add "https://gitlab.com/$GITLAB_USER/dibs-scripts.git" scripts
git add .gitmodules scripts
git commit -m "chore(index): add scripts as submodule"
git push -u origin main
  `}
    >
      <Fragment slot="powershell-title"
        >Versionar y añadir como submódulo (PowerShell)</Fragment
      >
      <Fragment slot="bash-title"
        >Versionar y añadir como submódulo (Bash/Zsh)</Fragment
      >
    </Terminals>
  </NotesSection>
</NotesLayout>
