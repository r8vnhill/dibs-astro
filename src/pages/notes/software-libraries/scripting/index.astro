---
import * as icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Definition, Explanation, Important, More, Note, Tip, Warning } from "~/components/ui/callouts";
import {
    BashScript,
    InlineBash,
    InlinePowerShell,
    OutputBlock,
    PowerShellBlock,
    PowerShellInline,
} from "~/components/ui/code";
import B from "~/components/ui/font/B.astro";
import I from "~/components/ui/font/I.astro";
import Mono from "~/components/ui/font/Mono.astro";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, LangLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, Book, References } from "~/components/ui/references";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import LinksLayout from "~/layouts/LinksLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Scripting 101: Introducción a PowerShell" description="...">
    <Abstract>
        Esta lección introduce el <B>scripting</B> con <B>PowerShell 7+</B> como herramienta multiplataforma para
        automatizar tareas de forma <I>repetible</I> y <I>confiable</I>. Explica por qué conviene trabajar con
        <B>objetos en la pipeline</B> en lugar de texto, cómo los cmdlets integrados simplifican tareas comunes y cómo
        organizar un <I>workspace</I> inicial. También muestra la creación de un primer script con parámetros tipados,
        incorporando validaciones y mensajes de diagnóstico que sientan las bases para escribir scripts claros y
        reutilizables en PowerShell.
    </Abstract>

    <NotesSection id="h2-scripting-powershell">
        <Heading headingLevel="h2" Icon={icons.Terminal}>
            Scripting con PowerShell
        </Heading>

        <Definition>
            <Fragment slot="title">¿Qué es scripting?</Fragment>

            <p>
                Por <B>scripting</B> entendemos la práctica de escribir pequeños programas destinados a
                <I>automatizar tareas repetitivas</I>. A diferencia de una aplicación completa, un script suele ser
                breve, orientado a ejecutar comandos del sistema, manipular archivos o coordinar herramientas ya
                existentes. Su valor está en reducir pasos manuales y hacer procesos
                <I>repetibles y confiables</I>.
            </p>
            <p class="mt-3">
                Una ventaja importante de los <B>lenguajes de scripting</B> frente a los lenguajes de propósito general
                es que, al tener un <I>alcance más acotado</I>, ofrecen una sintaxis más simple y una
                <B>librería estándar especializada</B> en automatización y manipulación del entorno. Esto permite
                escribir soluciones concisas sin necesidad de definir estructuras o configuraciones complejas.
            </p>
        </Definition>

        <p class="mb-3">
            En este curso utilizaremos <B>PowerShell 7+</B> como lenguaje de scripting único en
            <I>Windows, macOS y Linux</I>. Esta decisión simplifica el material, elimina distracciones y te permite
            concentrarte en lo esencial: <B>automatizar y construir con las mismas herramientas</B> en cualquier sistema
            operativo.
        </p>

        <Tip>
            <span slot="title">¿Por qué elegimos PowerShell?</span>

            <p class="mb-2">
                Adoptar <B>un solo lenguaje</B> para todo el curso reduce la carga cognitiva y facilita el mantenimiento
                del material: solo debemos actualizar ejemplos y explicaciones de PowerShell.
            </p>

            <List class="mt-2">
                <ListItem icon={icons.Globe}>
                    <B>Multiplataforma</B>: PowerShell 7+ funciona en Windows, macOS y Linux. Un único lenguaje para
                    todos los ejemplos y ejercicios del curso.
                </ListItem>

                <ListItem icon={icons.Lightning}>
                    <B>Más expresivo en este contexto</B>: su <I>pipeline</I> pasa <I>objetos</I><FootnoteRef
                        index={1}
                    />&nbsp; fuertemente tipados (no solo texto), lo que facilita filtrar, ordenar y transformar datos
                    sin depender de múltiples utilidades externas.
                </ListItem>

                <ListItem icon={icons.Sparkle}>
                    <B>Más simple</B>: muchas tareas comunes (JSON, XML, archivos, procesos) están cubiertas por
                    cmdlets<FootnoteRef index={2} /> y tipos .NET integrados, reduciendo dependencias y evitando el
                    <I>trabajo manual de conexión</I> típico de otros entornos (como parsear texto o encadenar
                    utilidades).
                </ListItem>

                <ListItem icon={icons.Target}>
                    <B>Enfoque y coherencia</B>: un único lenguaje implica una sola ruta de instalación, una sola
                    sintaxis y ejemplos consistentes a lo largo de todo el curso.
                </ListItem>
            </List>
        </Tip>

        <Important>
            PowerShell no es un reemplazo absoluto de Bash. Ambos son entornos de scripting potentes con filosofías
            distintas. La elección entre uno u otro depende siempre del <I>contexto</I> y de las <I>necesidades
                específicas</I>. En este curso priorizamos PowerShell por su carácter multiplataforma y expresividad,
            pero Bash sigue siendo la herramienta estándar en muchos entornos Unix.
        </Important>
    </NotesSection>

    <NotesSection id="h2-workspace-scaffold">
        <Heading
            headingLevel="h2" Icon={icons.FolderOpen}
            slot="heading"
        >
            Estructura base del “workspace”
        </Heading>

        <p>
            Comencemos creando una organización básica para los proyectos del curso. Esta carpeta puede compartirse
            entre varios proyectos; si decides no usarla, solo tendrás que adaptar las rutas en los comandos
            posteriores.
        </p>

        <p class="mb-4">
            Este puede ser tu primer contacto con PowerShell. Haremos un repaso mínimo de su sintaxis, asumiendo que ya
            conoces conceptos generales como <I>condicionales, bucles, funciones y objetos</I>.
        </p>

        <PowerShellBlock
            code={`
                $dibs        = 'dibs'          # raíz de proyectos del curso
                $scripts     = 'scripts'       # scripts de terminal
                $scriptsPath = Join-Path $dibs $scripts

                New-Item -ItemType Directory -Path $scriptsPath | Out-Null
            `}
        >
            <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.TextT}>
                    Asignación con <InlinePowerShell code="$nombre = 'valor'" />. Las variables comienzan con
                    <InlinePowerShell code="$" /> y pueden almacenar strings, números u objetos.
                </ListItem>

                <ListItem icon={icons.ArrowsMerge}>
                    <InlinePowerShell code="Join-Path" /> compone rutas de forma portable, evitando preocuparse por
                    separadores de sistema como <InlinePowerShell code="\\" /> o
                    <InlinePowerShell code="/" />.
                </ListItem>

                <ListItem icon={icons.FlowArrow}>
                    <B>Pipelines en PowerShell</B>: el operador <InlinePowerShell code="|" /> pasa <I>objetos</I> al
                    siguiente comando. Aquí usamos <InlinePowerShell code="| Out-Null" /> para descartar la salida y
                    mantener la terminal limpia.

                    <More>
                        <Fragment slot="title">Alternativas</Fragment>
                        <p>
                            También se puede suprimir la salida con <InlinePowerShell code="(comando) >$null" /> o
                            <InlinePowerShell code="$null = (comando)" />. Si bien no significan exactamente lo mismo,
                            todos logran el mismo efecto de no mostrar salida en la terminal.
                        </p>
                        <PowerShellBlock
                            code={`
                                New-Item -ItemType Directory -Path $scriptsPath -Force >$null
                                $null = New-Item -ItemType Directory -Path $scriptsPath -Force
                            `}
                        >
                            <Fragment slot="title">Otras formas de suprimir salida</Fragment>
                        </PowerShellBlock>
                    </More>

                    <More>
                        <Fragment slot="title">Pipelines: mini-ejemplo</Fragment>

                        <p>
                            Si bien veremos pipelines más adelante, es conveniente tener una idea básica de lo que son:
                            una serie de comandos conectados donde la salida de uno es la entrada del siguiente.
                        </p>

                        <PowerShellBlock
                            code={`
                                # Lista objetos de tipo FileSystemInfo y luego filtra por carpetas
                                Get-ChildItem -Path $dibs |
                                    Where-Object -FilterScript { $_.PSIsContainer } |
                                    Select-Object -Property Name
                            `}
                        >
                            <Fragment slot="title">Encadenar comandos con objetos</Fragment>
                        </PowerShellBlock>

                        <p class="mt-2">
                            En este ejemplo cada comando del pipeline recibe y devuelve <em>objetos</em>, no texto
                            plano:
                        </p>

                        <List>
                            <ListItem icon={icons.FolderOpen}>
                                <InlinePowerShell code="Get-ChildItem $dibs" /> produce objetos
                                <code>FileSystemInfo</code> con propiedades como
                                <InlinePowerShell code="Name" /> y
                                <InlinePowerShell code="PSIsContainer" />.
                            </ListItem>

                            <ListItem icon={icons.Funnel}>
                                <InlinePowerShell code="Where-Object -FilterScript { $_.PSIsContainer }" /> filtra y
                                deja pasar solo carpetas. Fuera de un contexto de pipeline o de un bloque que reciba
                                desde el pipeline, <InlinePowerShell code="$_" /> no tiene significado.
                            </ListItem>

                            <ListItem icon={icons.ListBullets}>
                                <InlinePowerShell code="Select-Object -Property Name" /> proyecta la propiedad
                                <InlinePowerShell code="Name" /> para mostrar únicamente el nombre de cada carpeta.
                            </ListItem>
                        </List>

                        <p class="mt-2">
                            Puedes pensarlo como una “tabla” de objetos: cada fila es un archivo/carpeta y cada columna
                            una propiedad. <InlinePowerShell code="Where-Object" /> filtra filas según una condición
                            sobre el
                            <InlinePowerShell code="$_" /> actual, y
                            <InlinePowerShell code="Select-Object" /> elige qué columnas mostrar. Al operar con objetos
                            (y no con strings), el pipeline es más expresivo y menos propenso a errores.
                        </p>
                    </More>
                </ListItem>
            </List>
        </Explanation>

        <More>
            <Fragment slot="title">Aliases</Fragment>

            <p>
                PowerShell incluye <I>aliases</I> que hacen que la experiencia sea más parecida a Bash o CMD (por
                ejemplo, <InlinePowerShell code="cat" /> en lugar de <InlinePowerShell code="Get-Content" />). Son
                útiles para escribir rápido en la terminal, pero <B>no los usaremos en este apunte</B> porque en scripts
                y documentación las formas completas son más claras, predecibles y fáciles de leer.
            </p>
            <Warning>
                <span slot="title">Compatibilidad entre sistemas</span>
                Los <I>aliases</I> pueden variar entre sistemas operativos: algunos están disponibles solo en Windows o
                solo en macOS/Linux. Por eso, confiar en ellos puede hacer que un script funcione en una plataforma pero
                falle en otra.
            </Warning>

            <PowerShellBlock code={`Get-Alias -Definition Set-Location`}>
                <Fragment slot="title">Desde la terminal</Fragment>
                <span slot="footer">Inspeccionando aliases de <InlinePowerShell code="Set-Location" /></span>
            </PowerShellBlock>

            <p class="mt-2">
                En este caso, <InlinePowerShell code="Set-Location" /> (que cambia el directorio actual) tiene dos
                aliases disponibles:
            </p>

            <OutputBlock
                code={`
                    CommandType     Name                  Version    Source
                    -----------     ----                  -------    ------
                    Alias           chdir -> Set-Location
                    Alias           sl    -> Set-Location
                `}
            />
        </More>
    </NotesSection>

    <NotesSection id="h2-help-and-discovery">
        <Heading
            headingLevel="h2" Icon={icons.Question}
            slot="heading"
        >
            Descubrir comandos y aprender desde la terminal
        </Heading>

        <p class="mb-3">
            PowerShell incluye herramientas integradas para <B>explorar</B> cmdlets, <B>aprender su uso</B> y
            <B>autodescubrir</B> la plataforma sin salir de la terminal. Aquí verás cómo encontrar comandos, leer su
            ayuda y revisar ejemplos rápidamente. En este apunte omitiremos la documentación formal de nuestros scripts;
            en un entorno real, conviene incluir comentarios y ayuda integrada (ver <I>Comment-Based Help</I> más
            abajo).
        </p>

        <PowerShellBlock
            code={`
      # Buscar comandos por nombre o verbo/sustantivo
      Get-Command Get-ChildItem
      Get-Command -Verb Get -Noun *Item

      # Ayuda rápida (resumen, parámetros y ejemplos)
      Get-Help Get-ChildItem
      Get-Help Get-ChildItem -Detailed
      Get-Help Get-ChildItem -Examples

      # Abrir documentación en el navegador (si está disponible)
      Get-Help Get-ChildItem -Online

      # Explorar temas conceptuales ("about_*")
      Get-Help about_Comparison_Operators
      Get-Help about_Aliases

      # Cuando no recuerdes el nombre exacto:
      Get-Help *child*        # comodines
      Get-Command *location*  # también funciona para encontrar candidatos
    `}
        >
            <Fragment slot="title">Búsqueda y ayuda integrada</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.Magnifier}>
                    <B>Get-Command</B> te dice <I>qué existe</I> (por nombre, verbo o sustantivo). Úsalo para descubrir
                    cmdlets.
                </ListItem>
                <ListItem icon={icons.BookOpen}>
                    <B>Get-Help</B> te enseña <I>cómo usarlo</I>: resumen, parámetros, ejemplos y enlaces <I
                    >-Online</I>.
                </ListItem>
                <ListItem icon={icons.Code}>
                    <B>about_*</B> son capítulos conceptuales (operadores, alias, pipeline, etc.).
                </ListItem>
                <ListItem icon={icons.Beaker}>
                    <B>Truco</B>: combina <Mono>Get-Command</Mono> + <Mono>Get-Help</Mono> para pasar de “no sé el
                    nombre” a “sé exactamente cómo llamarlo” en segundos.
                </ListItem>
            </List>
        </Explanation>

        <More>
            <span slot="title">Ayuda local, objetos y documentación en tus scripts</span>

            <PowerShellBlock
                code={`
        # Actualizar o descargar ayuda local (puede requerir permisos)
        # Útil para habilitar Get-Help sin conexión (-Online abre web).
        Update-Help -UICulture en-US -Force

        # Investigar la forma real de los objetos que pasan por el pipeline
        Get-ChildItem | Get-Member  # propiedades y métodos disponibles

        # Plantilla mínima de Comment-Based Help para tus propios scripts
        <#
        .SYNOPSIS
        Inicializa un repositorio local (idempotente).
        .DESCRIPTION
        Ejecuta 'git init' si no es repo y fija HEAD a 'main' sin crear commits.
        .PARAMETER LiteralPath
        Ruta de la carpeta del repositorio.
        .EXAMPLE
        .\\Initialize-Repository.ps1 -LiteralPath .\\dibs
        .NOTES
        Ver guía oficial: about_Comment_Based_Help
        #>
        param([string]$LiteralPath)
      `}
            >
                <Fragment slot="title">Buenas prácticas sin salir de la terminal</Fragment>
                <span slot="footer">
                    Documentación oficial: <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help/"
                    >about_Comment_Based_Help</Link>
                </span>
            </PowerShellBlock>

            <Tip>
                <span slot="title">Consejo</span>
                Si un cmdlet no abre <I>-Online</I>, usa <Mono>Get-Help NOMBRE -Full</Mono> o busca el tema
                <Mono>about_*</Mono> relacionado. Para inspeccionar lo que <I>realmente</I> fluye por el pipeline, añade
                <Mono>| Get-Member</Mono> al final.
            </Tip>
        </More>
    </NotesSection>

    <NotesSection id="first-script">
        <Heading headingLevel="h2" Icon={icons.FileText}>
            Primer script: generar un <code>README.md</code> básico
        </Heading>

        <p>
            Hasta ahora hemos trabajado ejecutando comandos de forma directa en la terminal. El siguiente paso es
            encapsular esa lógica en un <em>script</em>
            sencillo y reutilizable, guardado dentro de <code>dibs/scripts</code>. Nuestro ejemplo genera el contenido
            inicial de un <code>README.md</code>
            para un proyecto. Incluye parámetros obligatorios y una opción de <em>verbosity</em> para mostrar mensajes
            adicionales durante la ejecución. Te recomiendo editar y mantener estos scripts en un entorno cómodo como
            <strong>VS Code</strong>, que ofrece resaltado de sintaxis, integración con terminal y depuración básica.
        </p>

        <PowerShellBlock
            code={`
        #Requires -Version 7.0
        [CmdletBinding()]
        [OutputType([string])]
        param(
            [Parameter(Mandatory)]
            [ValidateNotNullOrEmpty()]
            [string] $Name
        )

        Write-Verbose "Creating README.md for project '$Name'"

        return @"
        # $Name

        Project initialized on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss').

        Learn more about READMEs at https://www.makeareadme.com/.
        "@
      `}
        >
            <Fragment slot="title">Generar <code>README.md</code> con PowerShell</Fragment>
            <DibsSourceLink
                repo="scripts" file="New-Readme.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.Hash}>
                    <InlinePowerShell code="#Requires -Version 7.0" />: asegura que el script se ejecute con
                    PowerShell&nbsp;7+.<FootnoteRef index={3} />
                </ListItem>

                <ListItem icon={icons.Info}>
                    <InlinePowerShell code="[CmdletBinding()]" /> convierte el script en un
                    <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute"
                    >cmdlet avanzado</Link>. Esto agrega características extra, como permitir el uso de
                    <InlinePowerShell code="-Verbose" /> para mostrar mensajes de diagnóstico opcionales al ejecutar el
                    script. Luego, <InlinePowerShell code="Write-Verbose" /> emite esos mensajes solo si se invoca con
                    <InlinePowerShell code="-Verbose" />.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <InlinePowerShell code="[OutputType([string])]" /> declara que el script devuelve una cadena. Esto
                    no cambia la ejecución, pero sirve como documentación y ayuda a herramientas de análisis y
                    autocompletado a entender mejor el resultado esperado (puedes pensarlo como los type-hints de
                    Python).
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    El bloque <InlinePowerShell code="param(...)" /> define los parámetros del script. La sintaxis
                    <InlinePowerShell code="[Atributo1][Atributo2][Tipo] $Parametro" /> aplica metadatos y validaciones
                    sobre cada parámetro:
                    <List>
                        <ListItem icon={icons.WarningCircle}>
                            <InlinePowerShell code="[Parameter(Mandatory)]" /> indica que el argumento es obligatorio y
                            debe proporcionarse al invocar la función.
                        </ListItem>
                        <ListItem icon={icons.Prohibit}>
                            <InlinePowerShell code="[ValidateNotNullOrEmpty()]" /> asegura que no se acepte un valor
                            vacío o <InlinePowerShell code="$null" />.
                        </ListItem>
                        <ListItem icon={icons.TextT}>
                            <InlinePowerShell code="[string]" /> define el tipo estático del parámetro, lo que mejora la
                            validación y el autocompletado.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.FileText}>
                    Usa un <em>here-string</em> para devolver texto multilínea listo para escribir a archivo. La
                    sintaxis con <InlinePowerShell code='@" ... "@' /> define una cadena que preserva saltos de línea e
                    interpolación de variables y expresiones (por ejemplo, <InlinePowerShell code="$Name" /> o
                    <InlinePowerShell code="$(Get-Date ...)" />). También existe la variante <InlinePowerShell
                        code="@' ... '@"
                    /> que no expande variables, tratándolas como texto literal.
                </ListItem>
            </List>
        </Explanation>

        <PowerShellBlock
            code={`
        # Desde dibs/scripts:
        .\\New-Readme.ps1 -Name 'Utility Scripts - DIBS' -Verbose | 
            Set-Content -Path README.md -Encoding UTF8 -Force
      `}
        >
            <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.FolderOpen}>
                    <InlinePowerShell code="Set-Location -Path $scriptsPath" /> cambia el directorio actual a <code
                    >dibs/scripts</code>, donde vive el script.
                </ListItem>

                <ListItem icon={icons.PlayCircle}>
                    <InlinePowerShell code=".\\New-Readme.ps1 -Name '...'" /> ejecuta el script en la carpeta actual. El
                    parámetro <InlinePowerShell code="-Name" /> es obligatorio.
                </ListItem>

                <ListItem icon={icons.Info}>
                    <InlinePowerShell code="-Verbose" /> muestra mensajes de diagnóstico (habilitado por
                    <InlinePowerShell code="[CmdletBinding()]" /> dentro del script).
                </ListItem>

                <ListItem icon={icons.FlowArrow}>
                    El resultado (texto del README) se envía por <em>pipeline</em> a
                    <InlinePowerShell code="Set-Content" />, que escribe el archivo en disco.
                </ListItem>

                <ListItem icon={icons.FileText}>
                    <InlinePowerShell code="Set-Content -Path README.md -Encoding UTF8 -Force" /> crea o sobrescribe
                    <code>README.md</code> con codificación UTF-8.
                </ListItem>
            </List>
        </Explanation>

        <Note>
            Por simplicidad omitiremos la documentación formal de los scripts, pero en un entorno real conviene incluir
            comentarios y ayuda integrados. Revisa
            <Link
                href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help"
            >Comment-Based Help</Link>.
        </Note>
    </NotesSection>

    <ConclusionsLayout><Fragment slot="conclusions">
            En esta lección introdujimos la idea de scripting como una forma de automatizar tareas repetitivas mediante
            programas breves y prácticos. Vimos por qué PowerShell 7+ resulta una buena elección para el curso: funciona
            en múltiples plataformas, ofrece una tubería basada en objetos y resuelve de forma integrada muchas
            necesidades comunes. Además, dimos los primeros pasos creando un espacio de trabajo y escribiendo un script
            sencillo para generar un <code>README.md</code>.</Fragment>

        <Fragment slot="key-points"><ListItem icon={icons.GearSix}
            >El scripting permite automatizar tareas y hacer procesos más repetibles y confiables.</ListItem>

            <ListItem icon={icons.Devices}
            >PowerShell 7+ es multiplataforma y su pipeline transmite objetos fuertemente tipados.</ListItem>

            <ListItem icon={icons.Code}
            >Los cmdlets reducen la necesidad de utilidades externas y hacen el código más expresivo.</ListItem>

            <ListItem icon={icons.FileCode}
            >Configuramos un workspace inicial y escribimos un primer script con parámetros y salida
                tipada.</ListItem></Fragment>

        <Fragment slot="takeaways"
        >Aprender scripting no se trata solo de memorizar comandos, sino de adoptar una mentalidad de <em
            >automatización</em>. A partir de ahora podrás pensar en tareas repetitivas como oportunidades para escribir
            pequeños programas que te ahorren tiempo y reduzcan errores. Este es apenas el inicio: con práctica, tus
            scripts evolucionarán en herramientas valiosas y reutilizables que apoyarán tu trabajo cotidiano y el
            desarrollo de bibliotecas más complejas.</Fragment></ConclusionsLayout>

    <LinksLayout>
        <LangLink
            href="/notes/software-libraries/scripting/nushell/"
            src="https://upload.wikimedia.org/wikipedia/commons/7/7d/Logo_of_nushell_shell.svg"
            name="nushell"
        />
    </LinksLayout>

    <References><Fragment slot="recommended"><Book
                chapter="Improving your parameterized script"
                bookTitle="Learn PowerShell in a month of lunches, fourth edition: Covers Windows, Linux, and MacOS"
                pages={[249, 258]}
            ><AuthorList slot="authors" authors={[{ firstName: "Travis", lastName: "Plunk" }]} />

                <Fragment slot="description"
                >Capítulo práctico sobre cómo llevar un script parametrizado de PowerShell “de básico a sólido”. Parte
                    desde un ejemplo funcional (<PowerShellInline code={`Get-DiskInventory`} />) con ayuda embebida y
                    dos parámetros, y muestra por qué conviene <strong>emitir objetos</strong> con
                    <PowerShellInline code={`Select-Object`} /> en lugar de salida formateada, permitiendo usar
                    <PowerShellInline code={`Format-Table`} /> o exportar a CSV sin cambios. Con
                    <PowerShellInline code={`[CmdletBinding()]`} /> se vuelve “avanzado” y habilita
                    <PowerShellInline code={`-Verbose`} /> para <strong>trazas activables</strong>. También introduce
                    mejoras en la <strong>definición de parámetros</strong>: obligatorios con
                    <PowerShellInline code={`[Parameter(Mandatory=$true)]`} />, <strong>alias</strong> con
                    <PowerShellInline code={`[Alias('host')]`} /> y <strong>validaciones</strong> con
                    <PowerShellInline code={`[ValidateSet(...)]`} />. Aunque centrado en
                    <strong>Windows</strong>, los principios son transferibles. El capítulo introduce <strong>conceptos
                        más avanzados</strong> que se explicarán más adelante o que quedan fuera del alcance de este
                    curso, pero resulta ideal para quienes buscan crear scripts en PowerShell que sean profesionales,
                    reutilizables y claros.</Fragment></Book></Fragment>

        <!--
            <Fragment slot="additional">
              ...
            </Fragment>
        --></References>

    <Footnotes><Footnote index={1}
        >A diferencia de los shells tradicionales, PowerShell trata todo como objetos de .NET. Esto habilita capacidades
            como composición, herencia, manejo de excepciones y tipado más estricto, lo que acerca la experiencia a la
            de un lenguaje de programación completo. Además, permite cierto nivel de compatibilidad con C#, lo que
            facilita integrar scripts con bibliotecas y funcionalidades del ecosistema .NET para resolver tareas más
            complejas.</Footnote>

        <Footnote index={2}
        >Un <strong>cmdlet</strong> es un comando ligero de PowerShell diseñado para realizar una única tarea bien
            definida. Suelen seguir la convención <em>Verbo-Sustantivo</em> (por ejemplo,
            <InlinePowerShell code="Get-Process" /> o <InlinePowerShell code="New-Item" />), lo que los hace más
            expresivos y fáciles de entender que muchos comandos en Bash. A diferencia de los ejecutables tradicionales,
            los cmdlets devuelven
            <em>objetos .NET</em>, lo que permite combinarlos en pipelines potentes y consistentes.</Footnote>

        <Footnote index={3}
        >Puedes ajustar <InlinePowerShell code="#Requires" /> a otra versión, pero no garantizamos compatibilidad con
            PowerShell anterior.</Footnote></Footnotes></NotesLayout>
