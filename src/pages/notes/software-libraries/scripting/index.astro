---
import * as icons from "~/assets/img/icons";
import Heading from "~/components/semantics/Heading.astro";
import { Abstract, Definition, Explanation, Important, More, Note, Tip } from "~/components/ui/callouts";
import {
    BashScript,
    InlineBash,
    InlinePowerShell,
    OutputBlock,
    PowerShellBlock,
    PowerShellInline,
} from "~/components/ui/code";
import { Footnote, FootnoteRef, Footnotes } from "~/components/ui/footnotes";
import { DibsSourceLink, LangLink, Link } from "~/components/ui/links";
import { List, ListItem } from "~/components/ui/list";
import { AuthorList, Book, References } from "~/components/ui/references";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import LinksLayout from "~/layouts/LinksLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout title="Scripting 101: Introducción a PowerShell"><Abstract>
        Esta lección introduce el <strong>scripting</strong> con <strong>PowerShell 7+</strong> como herramienta
        multiplataforma para automatizar tareas de forma <em>repetible</em> y
        <em>confiable</em>. Explica por qué conviene trabajar con
        <strong>objetos en la pipeline</strong> en lugar de texto, cómo los cmdlets integrados simplifican tareas
        comunes y cómo organizar un
        <em>workspace</em> inicial. También muestra la creación de un primer script con parámetros y salida tipada,
        incorporando validaciones y mensajes de diagnóstico que sientan las bases para escribir scripts claros y
        reutilizables en PowerShell.</Abstract>

    <NotesSection id="h2-scripting-powershell">
        <Heading headingLevel="h2" Icon={icons.Terminal}>
            Scripting con PowerShell
        </Heading>

        <Definition>
            <Fragment slot="title">¿Qué es scripting?</Fragment>
            Por <strong>scripting</strong> entendemos la práctica de escribir pequeños programas destinados a <em
            >automatizar tareas repetitivas</em>. A diferencia de una aplicación completa, un script suele ser breve,
            orientado a ejecutar comandos del sistema, manipular archivos o coordinar herramientas ya existentes. Su
            valor está en reducir pasos manuales y hacer procesos <em>repetibles y confiables</em>.
        </Definition>

        <p class="mb-3">
            En este curso usaremos <strong>PowerShell 7+</strong> como lenguaje de scripting único en <em>Windows, macOS
                y Linux</em>. Esta decisión simplifica el material, reduce el ruido y te permite concentrarte en lo
            importante: construir y automatizar con un mismo conjunto de herramientas en cualquier sistema.
        </p>

        <Tip>
            <span slot="title">¿Por qué elegimos PowerShell?</span>

            <p class="mb-2">
                Elegir <strong>un solo lenguaje</strong> para todo el curso reduce la carga cognitiva y facilita el
                mantenimiento del material: solo tenemos que actualizar ejemplos y explicaciones de PowerShell.
            </p>

            <List class="mt-2">
                <ListItem icon={icons.Globe}>
                    <strong>Multiplataforma</strong>: PowerShell 7+ funciona en Windows, macOS y Linux. Un único
                    lenguaje para todos los ejemplos y ejercicios del curso.
                </ListItem>

                <ListItem icon={icons.Lightning}>
                    <strong>“Más poderoso” en este contexto</strong>: la <em>pipeline</em>
                    pasa <em>objetos</em><FootnoteRef index={1} />&nbsp;fuertemente tipados (no solo texto), lo que
                    facilita filtrar, ordenar y transformar sin recurrir a múltiples utilidades externas.
                </ListItem>

                <ListItem icon={icons.Sparkle}>
                    <strong>Más simple</strong>: muchas tareas comunes (JSON, XML, archivos, procesos) ya vienen
                    resueltas con cmdlets<FootnoteRef index={2} /> y tipos .NET, reduciendo dependencias y evitando <em
                    >trabajo manual de conexión</em>
                    (parsear texto, encadenar utilidades externas, etc.).
                </ListItem>

                <ListItem icon={icons.Target}>
                    <strong>Enfoque y mantenimiento</strong>: usar un solo lenguaje simplifica explicaciones y
                    actualizaciones del material: mantenemos
                    <em>una sola</em> ruta de instalación, sintaxis y ejemplos coherentes.
                </ListItem>
            </List>
        </Tip>

        <Note>
            <span slot="title">Un vistazo a la ventaja “orientada a objetos”</span>

            <p class="mb-2">
                En PowerShell, lo que fluye por la tubería son objetos. Por ejemplo, listar procesos, filtrar por
                memoria y proyectar columnas legibles (no es necesario que entiendas todo el comando):
            </p>

            <PowerShellBlock
                code={`
          Get-Process |
              Where-Object { $_.WorkingSet64 -gt 200MB } |
              Sort-Object -Property WorkingSet64 -Descending |
              Select-Object -First 20 -Property Name, Id, @{
                  Name       = 'RAM(MB)';
                  Expression = { [math]::Round($_.WorkingSet64 / 1MB) }
              } |
              Format-Table -AutoSize
        `}
            >
                <span slot="title">Pipeline con objetos (ejemplo)</span>
            </PowerShellBlock>

            <p class="mt-2">
                No hace falta encadenar múltiples herramientas para parsear texto: trabajas con propiedades y tipos
                directamente.
            </p>

            <More title="¿Y Bash?">
                <p>
                    Podríamos lograr esto mismo en Bash, pero el resultado suele ser más complejo y dependiente de
                    utilidades externas <strong>no nativas de Bash</strong> (<code>ps</code>, <code>awk</code>, <code
                    >head</code>). Además, sus flags pueden variar entre distribuciones Linux y macOS/BSD.
                </p>

                <p class="mt-2">
                    En contraste, el código en <strong>PowerShell</strong> tiende a ser más
                    <em>expresivo y legible</em>: opera directamente sobre objetos y propiedades en lugar de cadenas de
                    texto. Además, los cmdlets siguen la convención
                    <em>verbo-sustantivo</em> (<InlinePowerShell code="Get-Process" />, <InlinePowerShell
                        code="Sort-Object"
                    />), lo que los hace más autoexplicativos y fáciles de recordar que comandos abreviados como
                    <InlineBash code="ps" /> o <InlineBash code="awk" />.
                </p>

                <BashScript
                    code={`
            ps -eo pid,comm,rss --sort=-rss | \\
                awk 'NR==1 {print "Name\\tId\\tRAM(MB)"; next} 
                    {printf "%s\\t%s\\t%d\\n", $2, $1, $3/1024}' | \\
                head -20
          `}
                >
                    <span slot="title">Pipeline con texto (ejemplo)</span>
                </BashScript>
            </More>
        </Note>

        <Important>
            PowerShell no es un reemplazo absoluto de Bash. Ambos son entornos de scripting potentes con filosofías
            distintas. La elección entre uno u otro depende siempre del <em>contexto</em> y de las <em>necesidades
                específicas</em>. En este curso priorizamos PowerShell por su carácter multiplataforma y expresividad,
            pero Bash sigue siendo la herramienta estándar en muchos entornos Unix.
        </Important>
    </NotesSection>

    <NotesSection id="h2-workspace-scaffold">
        <Heading headingLevel="h2" Icon={icons.FolderOpen}>
            Estructura base del “workspace”
        </Heading>

        <p>
            Comencemos creando una organización básica para los proyectos del curso. Esta carpeta puede compartirse
            entre varios proyectos; si decides no usarla, solo tendrás que adaptar las rutas en los comandos
            posteriores.
        </p>

        <p class="mb-4">
            Este puede ser tu primer contacto con PowerShell. Haremos un repaso mínimo de sintaxis pensando en que ya
            conoces conceptos generales (condicionales, bucles, funciones, objetos).
        </p>

        <PowerShellBlock
            code={`
        $dibs         = 'dibs'           # raíz de proyectos del curso
        $scripts      = 'scripts'        # scripts de terminal
        $scriptsPath  = Join-Path $dibs $scripts

        New-Item -ItemType Directory -Path $scriptsPath -Force | Out-Null
      `}
        >
            <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.TextT}>
                    Asignación con <InlinePowerShell code="$nombre = 'valor'" />. Las variables comienzan con
                    <InlinePowerShell code="$" /> y pueden contener strings, números u objetos.
                </ListItem>

                <ListItem icon={icons.ArrowsMerge}>
                    <InlinePowerShell code="Join-Path" /> compone rutas de forma portable (evita preocuparte por
                    <InlinePowerShell code="\\" /> vs
                    <InlinePowerShell code="/" />).
                </ListItem>

                <ListItem icon={icons.FolderPlus}>
                    <InlinePowerShell code="New-Item -ItemType Directory -Path ..." />
                    crea carpetas. Usar <InlinePowerShell code="-Force" /> permite repetir el comando sin error si ya
                    existen, lo cual es importante para respetar el principio de <span class="font-black"
                    >idempotencia</span>.
                </ListItem>

                <ListItem icon={icons.FlowArrow}>
                    <strong>Pipelines en PowerShell</strong>: el operador
                    <InlinePowerShell code="|" /> pasa <em>objetos</em> al siguiente comando. Aquí usamos
                    <InlinePowerShell code="| Out-Null" /> para descartar la salida y mantener la terminal limpia.
                </ListItem>
            </List>

            <More>
                <Fragment slot="title">Alternativas</Fragment>
                <p>
                    También se puede suprimir la salida con <InlinePowerShell code="(comando) >$null" /> o
                    <InlinePowerShell code="$null = (comando)" />. En este apunte preferimos <InlinePowerShell
                        code="| Out-Null"
                    /> por ser explícito y fácil de leer.
                </p>
                <PowerShellBlock
                    code={`
                New-Item -ItemType Directory -Path $scriptsPath -Force >$null
                $null = New-Item -ItemType Directory -Path $scriptsPath -Force
              `}
                >
                    <Fragment slot="title">Otras formas de suprimir salida</Fragment>
                </PowerShellBlock>
            </More>

            <More>
                <Fragment slot="title">Pipelines: mini-ejemplo</Fragment>
                <PowerShellBlock
                    code={`
                  # Lista objetos de tipo FileSystemInfo y luego filtra por carpetas
                  Get-ChildItem -Path $dibs |
                    Where-Object -FilterScript { $PSItem.PSIsContainer } |
                    Select-Object -Property Name
                `}
                >
                    <Fragment slot="title">Encadenar comandos con objetos</Fragment>
                </PowerShellBlock>

                <p class="mt-2">
                    En este ejemplo cada comando del pipeline recibe y devuelve <em>objetos</em>, no texto plano:
                </p>

                <List>
                    <ListItem icon={icons.FolderOpen}>
                        <InlinePowerShell code="Get-ChildItem $dibs" /> produce objetos
                        <code>FileSystemInfo</code> con propiedades como
                        <InlinePowerShell code="Name" /> y
                        <InlinePowerShell code="PSIsContainer" />.
                    </ListItem>

                    <ListItem icon={icons.Funnel}>
                        <InlinePowerShell code="Where-Object -FilterScript { $PSItem.PSIsContainer }" /> filtra y deja
                        pasar solo carpetas. Fuera de un contexto de pipeline o de un bloque que reciba desde el
                        pipeline, <InlinePowerShell code="$PSItem" /> no tiene significado.
                    </ListItem>

                    <ListItem icon={icons.ListBullets}>
                        <InlinePowerShell code="Select-Object -Property Name" /> proyecta la propiedad
                        <InlinePowerShell code="Name" /> para mostrar únicamente el nombre de cada carpeta.
                    </ListItem>
                </List>

                <p class="mt-2">
                    Puedes pensarlo como una “tabla” de objetos: cada fila es un archivo/carpeta y cada columna una
                    propiedad. <InlinePowerShell code="Where-Object" /> filtra filas según una condición sobre el
                    <InlinePowerShell code="$PSItem" /> actual, y
                    <InlinePowerShell code="Select-Object" /> elige qué columnas mostrar. Al operar con objetos (y no
                    con strings), el pipeline es más expresivo y menos propenso a errores.
                </p>
            </More>

            <More>
                <Fragment slot="title">Aliases</Fragment>

                PowerShell incluye <em>alias</em> que hacen que la experiencia sea más parecida a Bash o CMD (por
                ejemplo,
                <InlinePowerShell code="cat" /> en vez de
                <InlinePowerShell code="Get-Content" />). Son útiles para escribir rápido en la terminal, pero <span
                    class="font-black"
                >no los usaremos en este apunte</span> ya que en scripts y documentación las formas completas son más
                claras y fáciles de leer.

                <PowerShellBlock
                    code={`
            # Buscar los aliases que apuntan a un comando específico
            Get-Alias -Definition Set-Location
          `}
                >
                    <Fragment slot="title">Inspeccionando aliases de Set-Location</Fragment>
                </PowerShellBlock>

                <p class="mt-2">
                    En este caso <InlinePowerShell code="Set-Location" /> (que cambia el directorio actual) tiene 2
                    aliases disponibles:
                </p>

                <OutputBlock
                    code={`
            CommandType     Name                  Version    Source
            -----------     ----                  -------    ------
            Alias           chdir -> Set-Location
            Alias           sl    -> Set-Location
          `}
                />
            </More>
        </Explanation>
    </NotesSection>

    <NotesSection id="first-script">
        <Heading headingLevel="h2" Icon={icons.FileText}>
            Primer script: generar un <code>README.md</code> básico
        </Heading>

        <p>
            Hasta ahora hemos trabajado ejecutando comandos de forma directa en la terminal. El siguiente paso es
            encapsular esa lógica en un <em>script</em>
            sencillo y reutilizable, guardado dentro de <code>dibs/scripts</code>. Nuestro ejemplo genera el contenido
            inicial de un <code>README.md</code>
            para un proyecto. Incluye parámetros obligatorios y una opción de <em>verbosity</em> para mostrar mensajes
            adicionales durante la ejecución. Te recomiendo editar y mantener estos scripts en un entorno cómodo como
            <strong>VS Code</strong>, que ofrece resaltado de sintaxis, integración con terminal y depuración básica.
        </p>

        <PowerShellBlock
            code={`
        #Requires -Version 7.0
        [CmdletBinding()]
        [OutputType([string])]
        param(
            [Parameter(Mandatory)]
            [ValidateNotNullOrEmpty()]
            [string] $Name
        )

        Write-Verbose "Creating README.md for project '$Name'"

        return @"
        # $Name

        Project initialized on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss').

        Learn more about READMEs at https://www.makeareadme.com/.
        "@
      `}
        >
            <Fragment slot="title">Generar <code>README.md</code> con PowerShell</Fragment>
            <DibsSourceLink
                repo="scripts" file="New-Readme.ps1"
                slot="source"
            />
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.Hash}>
                    <InlinePowerShell code="#Requires -Version 7.0" />: asegura que el script se ejecute con
                    PowerShell&nbsp;7+.<FootnoteRef index={3} />
                </ListItem>

                <ListItem icon={icons.Info}>
                    <InlinePowerShell code="[CmdletBinding()]" /> convierte el script en un
                    <Link
                        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute"
                    >cmdlet avanzado</Link>. Esto agrega características extra, como permitir el uso de
                    <InlinePowerShell code="-Verbose" /> para mostrar mensajes de diagnóstico opcionales al ejecutar el
                    script. Luego, <InlinePowerShell code="Write-Verbose" /> emite esos mensajes solo si se invoca con
                    <InlinePowerShell code="-Verbose" />.
                </ListItem>

                <ListItem icon={icons.TextT}>
                    <InlinePowerShell code="[OutputType([string])]" /> declara que el script devuelve una cadena. Esto
                    no cambia la ejecución, pero sirve como documentación y ayuda a herramientas de análisis y
                    autocompletado a entender mejor el resultado esperado (puedes pensarlo como los type-hints de
                    Python).
                </ListItem>

                <ListItem icon={icons.SlidersHorizontal}>
                    El bloque <InlinePowerShell code="param(...)" /> define los parámetros del script. La sintaxis
                    <InlinePowerShell code="[Atributo1][Atributo2][Tipo] $Parametro" /> aplica metadatos y validaciones
                    sobre cada parámetro:
                    <List>
                        <ListItem icon={icons.WarningCircle}>
                            <InlinePowerShell code="[Parameter(Mandatory)]" /> indica que el argumento es obligatorio y
                            debe proporcionarse al invocar la función.
                        </ListItem>
                        <ListItem icon={icons.Prohibit}>
                            <InlinePowerShell code="[ValidateNotNullOrEmpty()]" /> asegura que no se acepte un valor
                            vacío o <InlinePowerShell code="$null" />.
                        </ListItem>
                        <ListItem icon={icons.TextT}>
                            <InlinePowerShell code="[string]" /> define el tipo estático del parámetro, lo que mejora la
                            validación y el autocompletado.
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.FileText}>
                    Usa un <em>here-string</em> para devolver texto multilínea listo para escribir a archivo. La
                    sintaxis con <InlinePowerShell code='@" ... "@' /> define una cadena que preserva saltos de línea e
                    interpolación de variables y expresiones (por ejemplo, <InlinePowerShell code="$Name" /> o
                    <InlinePowerShell code="$(Get-Date ...)" />). También existe la variante <InlinePowerShell
                        code="@' ... '@"
                    /> que no expande variables, tratándolas como texto literal.
                </ListItem>
            </List>
        </Explanation>

        <PowerShellBlock
            code={`
        # Desde dibs/scripts:
        .\\New-Readme.ps1 -Name 'Utility Scripts - DIBS' -Verbose | 
            Set-Content -Path README.md -Encoding UTF8 -Force
      `}
        >
            <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
        </PowerShellBlock>

        <Explanation>
            <List>
                <ListItem icon={icons.FolderOpen}>
                    <InlinePowerShell code="Set-Location -Path $scriptsPath" /> cambia el directorio actual a <code
                    >dibs/scripts</code>, donde vive el script.
                </ListItem>

                <ListItem icon={icons.PlayCircle}>
                    <InlinePowerShell code=".\\New-Readme.ps1 -Name '...'" /> ejecuta el script en la carpeta actual. El
                    parámetro <InlinePowerShell code="-Name" /> es obligatorio.
                </ListItem>

                <ListItem icon={icons.Info}>
                    <InlinePowerShell code="-Verbose" /> muestra mensajes de diagnóstico (habilitado por
                    <InlinePowerShell code="[CmdletBinding()]" /> dentro del script).
                </ListItem>

                <ListItem icon={icons.FlowArrow}>
                    El resultado (texto del README) se envía por <em>pipeline</em> a
                    <InlinePowerShell code="Set-Content" />, que escribe el archivo en disco.
                </ListItem>

                <ListItem icon={icons.FileText}>
                    <InlinePowerShell code="Set-Content -Path README.md -Encoding UTF8 -Force" /> crea o sobrescribe
                    <code>README.md</code> con codificación UTF-8.
                </ListItem>
            </List>
        </Explanation>

        <Note>
            Por simplicidad omitiremos la documentación formal de los scripts, pero en un entorno real conviene incluir
            comentarios y ayuda integrados. Revisa
            <Link
                href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help"
            >Comment-Based Help</Link>.
        </Note>
    </NotesSection>

    <ConclusionsLayout><Fragment slot="conclusions">
            En esta lección introdujimos la idea de scripting como una forma de automatizar tareas repetitivas mediante
            programas breves y prácticos. Vimos por qué PowerShell 7+ resulta una buena elección para el curso: funciona
            en múltiples plataformas, ofrece una tubería basada en objetos y resuelve de forma integrada muchas
            necesidades comunes. Además, dimos los primeros pasos creando un espacio de trabajo y escribiendo un script
            sencillo para generar un <code>README.md</code>.</Fragment>

        <Fragment slot="key-points"><ListItem icon={icons.GearSix}
            >El scripting permite automatizar tareas y hacer procesos más repetibles y confiables.</ListItem>

            <ListItem icon={icons.Devices}
            >PowerShell 7+ es multiplataforma y su pipeline transmite objetos fuertemente tipados.</ListItem>

            <ListItem icon={icons.Code}
            >Los cmdlets reducen la necesidad de utilidades externas y hacen el código más expresivo.</ListItem>

            <ListItem icon={icons.FileCode}
            >Configuramos un workspace inicial y escribimos un primer script con parámetros y salida
                tipada.</ListItem></Fragment>

        <Fragment slot="takeaways"
        >Aprender scripting no se trata solo de memorizar comandos, sino de adoptar una mentalidad de <em
            >automatización</em>. A partir de ahora podrás pensar en tareas repetitivas como oportunidades para escribir
            pequeños programas que te ahorren tiempo y reduzcan errores. Este es apenas el inicio: con práctica, tus
            scripts evolucionarán en herramientas valiosas y reutilizables que apoyarán tu trabajo cotidiano y el
            desarrollo de bibliotecas más complejas.</Fragment></ConclusionsLayout>

    <LinksLayout>
        <LangLink
            href="/notes/software-libraries/scripting/nushell/"
            src="https://upload.wikimedia.org/wikipedia/commons/7/7d/Logo_of_nushell_shell.svg"
            name="nushell"
        />
    </LinksLayout>

    <References><Fragment slot="recommended"><Book
                chapter="Improving your parameterized script"
                bookTitle="Learn PowerShell in a month of lunches, fourth edition: Covers Windows, Linux, and MacOS"
                pages={[249, 258]}
            ><AuthorList slot="authors" authors={[{ firstName: "Travis", lastName: "Plunk" }]} />

                <Fragment slot="description"
                >Capítulo práctico sobre cómo llevar un script parametrizado de PowerShell “de básico a sólido”. Parte
                    desde un ejemplo funcional (<PowerShellInline code={`Get-DiskInventory`} />) con ayuda embebida y
                    dos parámetros, y muestra por qué conviene <strong>emitir objetos</strong> con
                    <PowerShellInline code={`Select-Object`} /> en lugar de salida formateada, permitiendo usar
                    <PowerShellInline code={`Format-Table`} /> o exportar a CSV sin cambios. Con
                    <PowerShellInline code={`[CmdletBinding()]`} /> se vuelve “avanzado” y habilita
                    <PowerShellInline code={`-Verbose`} /> para <strong>trazas activables</strong>. También introduce
                    mejoras en la <strong>definición de parámetros</strong>: obligatorios con
                    <PowerShellInline code={`[Parameter(Mandatory=$true)]`} />, <strong>alias</strong> con
                    <PowerShellInline code={`[Alias('host')]`} /> y <strong>validaciones</strong> con
                    <PowerShellInline code={`[ValidateSet(...)]`} />. Aunque centrado en
                    <strong>Windows</strong>, los principios son transferibles. El capítulo introduce <strong>conceptos
                        más avanzados</strong> que se explicarán más adelante o que quedan fuera del alcance de este
                    curso, pero resulta ideal para quienes buscan crear scripts en PowerShell que sean profesionales,
                    reutilizables y claros.</Fragment></Book></Fragment>

        <!--
            <Fragment slot="additional">
              ...
            </Fragment>
        --></References>

    <Footnotes><Footnote index={1}
        >A diferencia de los shells tradicionales, PowerShell trata todo como objetos de .NET. Esto habilita capacidades
            como composición, herencia, manejo de excepciones y tipado más estricto, lo que acerca la experiencia a la
            de un lenguaje de programación completo. Además, permite cierto nivel de compatibilidad con C#, lo que
            facilita integrar scripts con bibliotecas y funcionalidades del ecosistema .NET para resolver tareas más
            complejas.</Footnote>

        <Footnote index={2}
        >Un <strong>cmdlet</strong> es un comando ligero de PowerShell diseñado para realizar una única tarea bien
            definida. Suelen seguir la convención <em>Verbo-Sustantivo</em> (por ejemplo,
            <InlinePowerShell code="Get-Process" /> o <InlinePowerShell code="New-Item" />), lo que los hace más
            expresivos y fáciles de entender que muchos comandos en Bash. A diferencia de los ejecutables tradicionales,
            los cmdlets devuelven
            <em>objetos .NET</em>, lo que permite combinarlos en pipelines potentes y consistentes.</Footnote>

        <Footnote index={3}
        >Puedes ajustar <InlinePowerShell code="#Requires" /> a otra versión, pero no garantizamos compatibilidad con
            PowerShell anterior.</Footnote></Footnotes></NotesLayout>
