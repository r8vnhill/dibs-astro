---
import * as icons from "~/assets/img/icons";
import NotesLayout from "~/layouts/NotesLayout.astro";
import {
  Abstract,
  Definition,
  Explanation,
  Important,
  More,
  Note,
  Tip,
} from "~/components/ui/callouts";
import {
  BashScript,
  InlineBash,
  InlinePowerShell,
  OutputBlock,
  PowerShellBlock,
  PowerShellInline,
} from "~/components/ui/code";
import { FootnoteRef, Footnotes, Footnote } from "~/components/ui/footnotes";
import { List, ListItem } from "~/components/ui/list";
import NotesSection from "~/layouts/NotesSection.astro";
import Heading from "~/components/semantics/Heading.astro";
import { DibsSourceLink, Link } from "~/components/ui/links";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import {
  AuthorList,
  Book,
  References,
} from "~/components/ui/references";
---

<NotesLayout title="Scripting 101: Introducción a PowerShell"
  ><Abstract>
    Esta lección introduce el <strong>scripting</strong> con <strong
      >PowerShell 7+</strong
    > como herramienta multiplataforma para automatizar tareas de forma <em
      >repetible</em
    > y
    <em>confiable</em>. Explica por qué conviene trabajar con
    <strong>objetos en la pipeline</strong> en lugar de texto, cómo los cmdlets integrados
    simplifican tareas comunes y cómo organizar un
    <em>workspace</em> inicial. También muestra la creación de un primer script con
    parámetros y salida tipada, incorporando validaciones y mensajes de diagnóstico
    que sientan las bases para escribir scripts claros y reutilizables en PowerShell.</Abstract
  >

  <NotesSection id="h2-scripting-powershell">
    <Heading headingLevel="h2" Icon={icons.Terminal}>
      Scripting con PowerShell
    </Heading>

    <Definition>
      <Fragment slot="title">¿Qué es scripting?</Fragment>
      Por <strong>scripting</strong> entendemos la práctica de escribir pequeños
      programas destinados a <em>automatizar tareas repetitivas</em>. A
      diferencia de una aplicación completa, un script suele ser breve,
      orientado a ejecutar comandos del sistema, manipular archivos o coordinar
      herramientas ya existentes. Su valor está en reducir pasos manuales y
      hacer procesos <em>repetibles y confiables</em>.
    </Definition>

    <p class="mb-3">
      En este curso usaremos <strong>PowerShell 7+</strong> como lenguaje de scripting
      único en <em>Windows, macOS y Linux</em>. Esta decisión simplifica el
      material, reduce el ruido y te permite concentrarte en lo importante:
      construir y automatizar con un mismo conjunto de herramientas en cualquier
      sistema.
    </p>

    <Tip>
      <span slot="title">¿Por qué elegimos PowerShell?</span>

      <p class="mb-2">
        Elegir <strong>un solo lenguaje</strong> para todo el curso reduce la carga
        cognitiva y facilita el mantenimiento del material: solo tenemos que actualizar
        ejemplos y explicaciones de PowerShell.
      </p>

      <List class="mt-2">
        <ListItem icon={icons.Globe}>
          <strong>Multiplataforma</strong>: PowerShell 7+ funciona en Windows,
          macOS y Linux. Un único lenguaje para todos los ejemplos y ejercicios
          del curso.
        </ListItem>

        <ListItem icon={icons.Lightning}>
          <strong>“Más poderoso” en este contexto</strong>: la <em>pipeline</em>
          pasa <em>objetos</em><FootnoteRef index={1} />&nbsp;fuertemente
          tipados (no solo texto), lo que facilita filtrar, ordenar y
          transformar sin recurrir a múltiples utilidades externas.
        </ListItem>

        <ListItem icon={icons.Sparkle}>
          <strong>Más simple</strong>: muchas tareas comunes (JSON, XML,
          archivos, procesos) ya vienen resueltas con cmdlets<FootnoteRef
            index={2}
          /> y tipos .NET, reduciendo dependencias y evitando <em
            >trabajo manual de conexión</em
          >
          (parsear texto, encadenar utilidades externas, etc.).
        </ListItem>

        <ListItem icon={icons.Target}>
          <strong>Enfoque y mantenimiento</strong>: usar un solo lenguaje
          simplifica explicaciones y actualizaciones del material: mantenemos
          <em>una sola</em> ruta de instalación, sintaxis y ejemplos coherentes.
        </ListItem>
      </List>
    </Tip>

    <Note>
      <span slot="title">Un vistazo a la ventaja “orientada a objetos”</span>

      <p class="mb-2">
        En PowerShell, lo que fluye por la tubería son objetos. Por ejemplo,
        listar procesos, filtrar por memoria y proyectar columnas legibles (no
        es necesario que entiendas todo el comando):
      </p>

      <PowerShellBlock
        code={`
          Get-Process |
              Where-Object { $_.WorkingSet64 -gt 200MB } |
              Sort-Object -Property WorkingSet64 -Descending |
              Select-Object -First 20 -Property Name, Id, @{
                  Name       = 'RAM(MB)';
                  Expression = { [math]::Round($_.WorkingSet64 / 1MB) }
              } |
              Format-Table -AutoSize
        `}
      >
        <span slot="title">Pipeline con objetos (ejemplo)</span>
      </PowerShellBlock>

      <p class="mt-2">
        No hace falta encadenar múltiples herramientas para parsear texto:
        trabajas con propiedades y tipos directamente.
      </p>

      <More title="¿Y Bash?">
        <p>
          Podríamos lograr esto mismo en Bash, pero el resultado suele ser más
          complejo y dependiente de utilidades externas <strong
            >no nativas de Bash</strong
          > (<code>ps</code>, <code>awk</code>, <code>head</code>). Además, sus
          flags pueden variar entre distribuciones Linux y macOS/BSD.
        </p>

        <p class="mt-2">
          En contraste, el código en <strong>PowerShell</strong> tiende a ser más
          <em>expresivo y legible</em>: opera directamente sobre objetos y
          propiedades en lugar de cadenas de texto. Además, los cmdlets siguen
          la convención
          <em>verbo-sustantivo</em> (<InlinePowerShell code="Get-Process" />, <InlinePowerShell
            code="Sort-Object"
          />), lo que los hace más autoexplicativos y fáciles de recordar que
          comandos abreviados como <InlineBash code="ps" /> o <InlineBash
            code="awk"
          />.
        </p>

        <BashScript
          code={`
            ps -eo pid,comm,rss --sort=-rss | \\
                awk 'NR==1 {print "Name\\tId\\tRAM(MB)"; next} 
                    {printf "%s\\t%s\\t%d\\n", $2, $1, $3/1024}' | \\
                head -20
          `}
        >
          <span slot="title">Pipeline con texto (ejemplo)</span>
        </BashScript>
      </More>
    </Note>

    <Important>
      PowerShell no es un reemplazo absoluto de Bash. Ambos son entornos de
      scripting potentes con filosofías distintas. La elección entre uno u otro
      depende siempre del <em>contexto</em> y de las <em
        >necesidades específicas</em
      >. En este curso priorizamos PowerShell por su carácter multiplataforma y
      expresividad, pero Bash sigue siendo la herramienta estándar en muchos
      entornos Unix.
    </Important>
  </NotesSection>

  <NotesSection id="h2-workspace-scaffold">
    <Heading headingLevel="h2" Icon={icons.FolderOpen}>
      Estructura base del “workspace”
    </Heading>

    <p>
      Comencemos creando una organización básica para los proyectos del curso.
      Esta carpeta puede compartirse entre varios proyectos; si decides no
      usarla, solo tendrás que adaptar las rutas en los comandos posteriores.
    </p>

    <p class="mb-4">
      Este puede ser tu primer contacto con PowerShell. Haremos un repaso mínimo
      de sintaxis pensando en que ya conoces conceptos generales (condicionales,
      bucles, funciones, objetos).
    </p>

    <PowerShellBlock
      code={`
        $dibs         = 'dibs'           # raíz de proyectos del curso
        $scripts      = 'scripts'        # scripts de terminal
        $scriptsPath  = Join-Path $dibs $scripts

        New-Item -ItemType Directory -Path $scriptsPath -Force | Out-Null
      `}
    >
      <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
    </PowerShellBlock>

    <Explanation>
      <List>
        <ListItem icon={icons.TextT}>
          Asignación con <InlinePowerShell code="$nombre = 'valor'" />. Las
          variables comienzan con <InlinePowerShell code="$" /> y pueden contener
          strings, números u objetos.
        </ListItem>

        <ListItem icon={icons.ArrowsMerge}>
          <InlinePowerShell code="Join-Path" /> compone rutas de forma portable (evita
          preocuparte por <InlinePowerShell code="\\" /> vs
          <InlinePowerShell code="/" />).
        </ListItem>

        <ListItem icon={icons.FolderPlus}>
          <InlinePowerShell code="New-Item -ItemType Directory -Path ..." />
          crea carpetas. Usar <InlinePowerShell code="-Force" /> permite repetir
          el comando sin error si ya existen, lo cual es importante para respetar
          el principio de <span class="font-black">idempotencia</span>.
        </ListItem>

        <ListItem icon={icons.FlowArrow}>
          <strong>Pipelines en PowerShell</strong>: el operador
          <InlinePowerShell code="|" /> pasa <em>objetos</em> al siguiente comando.
          Aquí usamos <InlinePowerShell code="| Out-Null" /> para descartar la salida
          y mantener la terminal limpia.
        </ListItem>
      </List>

      <More>
        <Fragment slot="title">Alternativas</Fragment>
        <p>
          También se puede suprimir la salida con <InlinePowerShell
            code="(comando) >$null"
          /> o
          <InlinePowerShell code="$null = (comando)" />. En este apunte
          preferimos <InlinePowerShell code="| Out-Null" /> por ser explícito y fácil
          de leer.
        </p>
        <PowerShellBlock
          code={`
                New-Item -ItemType Directory -Path $scriptsPath -Force >$null
                $null = New-Item -ItemType Directory -Path $scriptsPath -Force
              `}
        >
          <Fragment slot="title">Otras formas de suprimir salida</Fragment>
        </PowerShellBlock>
      </More>

      <More>
        <Fragment slot="title">Pipelines: mini-ejemplo</Fragment>
        <PowerShellBlock
          code={`
                  # Lista objetos de tipo FileSystemInfo y luego filtra por carpetas
                  Get-ChildItem -Path $dibs |
                    Where-Object -FilterScript { $PSItem.PSIsContainer } |
                    Select-Object -Property Name
                `}
        >
          <Fragment slot="title">Encadenar comandos con objetos</Fragment>
        </PowerShellBlock>

        <p class="mt-2">
          En este ejemplo cada comando del pipeline recibe y devuelve <em
            >objetos</em
          >, no texto plano:
        </p>

        <List>
          <ListItem icon={icons.FolderOpen}>
            <InlinePowerShell code="Get-ChildItem $dibs" /> produce objetos
            <code>FileSystemInfo</code> con propiedades como
            <InlinePowerShell code="Name" /> y
            <InlinePowerShell code="PSIsContainer" />.
          </ListItem>

          <ListItem icon={icons.Funnel}>
            <InlinePowerShell
              code="Where-Object -FilterScript { $PSItem.PSIsContainer }"
            /> filtra y deja pasar solo carpetas. Fuera de un contexto de pipeline
            o de un bloque que reciba desde el pipeline, <InlinePowerShell
              code="$PSItem"
            /> no tiene significado.
          </ListItem>

          <ListItem icon={icons.ListBullets}>
            <InlinePowerShell code="Select-Object -Property Name" /> proyecta la
            propiedad
            <InlinePowerShell code="Name" /> para mostrar únicamente el nombre de
            cada carpeta.
          </ListItem>
        </List>

        <p class="mt-2">
          Puedes pensarlo como una “tabla” de objetos: cada fila es un
          archivo/carpeta y cada columna una propiedad. <InlinePowerShell
            code="Where-Object"
          /> filtra filas según una condición sobre el <InlinePowerShell
            code="$PSItem"
          /> actual, y
          <InlinePowerShell code="Select-Object" /> elige qué columnas mostrar. Al
          operar con objetos (y no con strings), el pipeline es más expresivo y menos
          propenso a errores.
        </p>
      </More>

      <More>
        <Fragment slot="title">Aliases</Fragment>

        PowerShell incluye <em>alias</em> que hacen que la experiencia sea más parecida
        a Bash o CMD (por ejemplo,
        <InlinePowerShell code="cat" /> en vez de
        <InlinePowerShell code="Get-Content" />). Son útiles para escribir
        rápido en la terminal, pero <span class="font-black"
          >no los usaremos en este apunte</span
        > ya que en scripts y documentación las formas completas son más claras y
        fáciles de leer.

        <PowerShellBlock
          code={`
            # Buscar los aliases que apuntan a un comando específico
            Get-Alias -Definition Set-Location
          `}
        >
          <Fragment slot="title"
            >Inspeccionando aliases de Set-Location</Fragment
          >
        </PowerShellBlock>

        <p class="mt-2">
          En este caso <InlinePowerShell code="Set-Location" /> (que cambia el directorio
          actual) tiene 2 aliases disponibles:
        </p>

        <OutputBlock
          code={`
            CommandType     Name                  Version    Source
            -----------     ----                  -------    ------
            Alias           chdir -> Set-Location
            Alias           sl    -> Set-Location
          `}
        />
      </More>
    </Explanation>
  </NotesSection>

  <NotesSection id="first-script">
    <Heading headingLevel="h2" Icon={icons.FileText}>
      Primer script: generar un <code>README.md</code> básico
    </Heading>

    <p>
      Hasta ahora hemos trabajado ejecutando comandos de forma directa en la
      terminal. El siguiente paso es encapsular esa lógica en un <em>script</em>
      sencillo y reutilizable, guardado dentro de <code>dibs/scripts</code>.
      Nuestro ejemplo genera el contenido inicial de un <code>README.md</code>
      para un proyecto. Incluye parámetros obligatorios y una opción de <em
        >verbosity</em
      > para mostrar mensajes adicionales durante la ejecución. Te recomiendo editar
      y mantener estos scripts en un entorno cómodo como <strong>VS Code</strong
      >, que ofrece resaltado de sintaxis, integración con terminal y depuración
      básica.
    </p>

    <PowerShellBlock
      code={`
        #Requires -Version 7.0
        [CmdletBinding()]
        [OutputType([string])]
        param(
            [Parameter(Mandatory)]
            [ValidateNotNullOrEmpty()]
            [string] $Name
        )

        Write-Verbose "Creating README.md for project '$Name'"

        return @"
        # $Name

        Project initialized on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss').

        Learn more about READMEs at https://www.makeareadme.com/.
        "@
      `}
    >
      <Fragment slot="title"
        >Generar <code>README.md</code> con PowerShell</Fragment
      >
      <DibsSourceLink repo="scripts" file="New-Readme.ps1" slot="source" />
    </PowerShellBlock>

    <Explanation>
      <List>
        <ListItem icon={icons.Hash}>
          <InlinePowerShell code="#Requires -Version 7.0" />: asegura que el
          script se ejecute con PowerShell&nbsp;7+.<FootnoteRef index={3} />
        </ListItem>

        <ListItem icon={icons.Info}>
          <InlinePowerShell code="[CmdletBinding()]" /> convierte el script en un
          <Link
            href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute"
            >cmdlet avanzado</Link
          >. Esto agrega características extra, como permitir el uso de <InlinePowerShell
            code="-Verbose"
          /> para mostrar mensajes de diagnóstico opcionales al ejecutar el script.
          Luego, <InlinePowerShell code="Write-Verbose" /> emite esos mensajes solo
          si se invoca con <InlinePowerShell code="-Verbose" />.
        </ListItem>

        <ListItem icon={icons.TextT}>
          <InlinePowerShell code="[OutputType([string])]" /> declara que el script
          devuelve una cadena. Esto no cambia la ejecución, pero sirve como documentación
          y ayuda a herramientas de análisis y autocompletado a entender mejor el
          resultado esperado (puedes pensarlo como los type-hints de Python).
        </ListItem>

        <ListItem icon={icons.SlidersHorizontal}>
          El bloque <InlinePowerShell code="param(...)" /> define los parámetros
          del script. La sintaxis <InlinePowerShell
            code="[Atributo1][Atributo2][Tipo] $Parametro"
          /> aplica metadatos y validaciones sobre cada parámetro:
          <List>
            <ListItem icon={icons.WarningCircle}>
              <InlinePowerShell code="[Parameter(Mandatory)]" /> indica que el argumento
              es obligatorio y debe proporcionarse al invocar la función.
            </ListItem>
            <ListItem icon={icons.Prohibit}>
              <InlinePowerShell code="[ValidateNotNullOrEmpty()]" /> asegura que
              no se acepte un valor vacío o <InlinePowerShell code="$null" />.
            </ListItem>
            <ListItem icon={icons.TextT}>
              <InlinePowerShell code="[string]" /> define el tipo estático del parámetro,
              lo que mejora la validación y el autocompletado.
            </ListItem>
          </List>
        </ListItem>

        <ListItem icon={icons.FileText}>
          Usa un <em>here-string</em> para devolver texto multilínea listo para escribir
          a archivo. La sintaxis con <InlinePowerShell code='@" ... "@' /> define
          una cadena que preserva saltos de línea e interpolación de variables y
          expresiones (por ejemplo, <InlinePowerShell code="$Name" /> o
          <InlinePowerShell code="$(Get-Date ...)" />). También existe la
          variante <InlinePowerShell code="@' ... '@" /> que no expande variables,
          tratándolas como texto literal.
        </ListItem>
      </List>
    </Explanation>

    <PowerShellBlock
      code={`
        # Desde dibs/scripts:
        .\\New-Readme.ps1 -Name 'Utility Scripts - DIBS' -Verbose | 
            Set-Content -Path README.md -Encoding UTF8 -Force
      `}
    >
      <Fragment slot="title">Desde la terminal de PowerShell</Fragment>
    </PowerShellBlock>

    <Explanation>
      <List>
        <ListItem icon={icons.FolderOpen}>
          <InlinePowerShell code="Set-Location -Path $scriptsPath" /> cambia el directorio
          actual a <code>dibs/scripts</code>, donde vive el script.
        </ListItem>

        <ListItem icon={icons.PlayCircle}>
          <InlinePowerShell code=".\\New-Readme.ps1 -Name '...'" /> ejecuta el script
          en la carpeta actual. El parámetro <InlinePowerShell code="-Name" /> es
          obligatorio.
        </ListItem>

        <ListItem icon={icons.Info}>
          <InlinePowerShell code="-Verbose" /> muestra mensajes de diagnóstico (habilitado
          por <InlinePowerShell code="[CmdletBinding()]" /> dentro del script).
        </ListItem>

        <ListItem icon={icons.FlowArrow}>
          El resultado (texto del README) se envía por <em>pipeline</em> a
          <InlinePowerShell code="Set-Content" />, que escribe el archivo en
          disco.
        </ListItem>

        <ListItem icon={icons.FileText}>
          <InlinePowerShell
            code="Set-Content -Path README.md -Encoding UTF8 -Force"
          /> crea o sobrescribe <code>README.md</code> con codificación UTF-8.
        </ListItem>
      </List>
    </Explanation>

    <Note>
      Por simplicidad omitiremos la documentación formal de los scripts, pero en
      un entorno real conviene incluir comentarios y ayuda integrados. Revisa
      <Link
        href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help"
        >Comment-Based Help</Link
      >.
    </Note>
  </NotesSection>

  <ConclusionsLayout
    ><Fragment slot="conclusions">
      En esta lección introdujimos la idea de scripting como una forma de
      automatizar tareas repetitivas mediante programas breves y prácticos.
      Vimos por qué PowerShell 7+ resulta una buena elección para el curso:
      funciona en múltiples plataformas, ofrece una tubería basada en objetos y
      resuelve de forma integrada muchas necesidades comunes. Además, dimos los
      primeros pasos creando un espacio de trabajo y escribiendo un script
      sencillo para generar un <code>README.md</code>.</Fragment
    >

    <Fragment slot="key-points"
      ><ListItem icon={icons.GearSix}
        >El scripting permite automatizar tareas y hacer procesos más repetibles
        y confiables.</ListItem
      >

      <ListItem icon={icons.Devices}
        >PowerShell 7+ es multiplataforma y su pipeline transmite objetos
        fuertemente tipados.</ListItem
      >

      <ListItem icon={icons.Code}
        >Los cmdlets reducen la necesidad de utilidades externas y hacen el
        código más expresivo.</ListItem
      >

      <ListItem icon={icons.FileCode}
        >Configuramos un workspace inicial y escribimos un primer script con
        parámetros y salida tipada.</ListItem
      ></Fragment
    >

    <Fragment slot="takeaways"
      >Aprender scripting no se trata solo de memorizar comandos, sino de
      adoptar una mentalidad de <em>automatización</em>. A partir de ahora
      podrás pensar en tareas repetitivas como oportunidades para escribir
      pequeños programas que te ahorren tiempo y reduzcan errores. Este es
      apenas el inicio: con práctica, tus scripts evolucionarán en herramientas
      valiosas y reutilizables que apoyarán tu trabajo cotidiano y el desarrollo
      de bibliotecas más complejas.</Fragment
    ></ConclusionsLayout
  >

  <References
    ><Fragment slot="recommended"
      ><Book
        chapter="Improving your parameterized script"
        bookTitle="Learn PowerShell in a month of lunches, fourth edition"
        pages={[249, 258]}
        ><AuthorList
          slot="authors"
          authors={[{ firstName: "Travis", lastName: "Plunk" }]}
        />

        <Fragment slot="description"
          >Capítulo práctico sobre cómo llevar un script parametrizado de
          PowerShell “de básico a sólido”. Parte desde un ejemplo funcional (<PowerShellInline
            code={`Get-DiskInventory`}
          />) con ayuda embebida y dos parámetros, y muestra por qué conviene <strong
            >emitir objetos</strong
          > con
          <PowerShellInline code={`Select-Object`} /> en lugar de salida formateada,
          permitiendo usar <PowerShellInline code={`Format-Table`} /> o exportar
          a CSV sin cambios. Con
          <PowerShellInline code={`[CmdletBinding()]`} /> se vuelve “avanzado” y
          habilita
          <PowerShellInline code={`-Verbose`} /> para <strong
            >trazas activables</strong
          >. También introduce mejoras en la <strong
            >definición de parámetros</strong
          >: obligatorios con
          <PowerShellInline code={`[Parameter(Mandatory=$true)]`} />, <strong
            >alias</strong
          > con
          <PowerShellInline code={`[Alias('host')]`} /> y <strong
            >validaciones</strong
          > con
          <PowerShellInline code={`[ValidateSet(...)]`} />. Aunque centrado en
          <strong>Windows</strong>, los principios son transferibles. El
          capítulo introduce <strong>conceptos más avanzados</strong> que se explicarán
          más adelante o que quedan fuera del alcance de este curso, pero resulta
          ideal para quienes buscan crear scripts en PowerShell que sean profesionales,
          reutilizables y claros.</Fragment
        ></Book
      ></Fragment
    >

    <!--<Fragment slot="additional">
        ...
      </Fragment> --></References
  >

  <Footnotes
    ><Footnote index={1}
      >A diferencia de los shells tradicionales, PowerShell trata todo como
      objetos de .NET. Esto habilita capacidades como composición, herencia,
      manejo de excepciones y tipado más estricto, lo que acerca la experiencia
      a la de un lenguaje de programación completo. Además, permite cierto nivel
      de compatibilidad con C#, lo que facilita integrar scripts con bibliotecas
      y funcionalidades del ecosistema .NET para resolver tareas más complejas.</Footnote
    >

    <Footnote index={2}
      >Un <strong>cmdlet</strong> es un comando ligero de PowerShell diseñado para
      realizar una única tarea bien definida. Suelen seguir la convención <em
        >Verbo-Sustantivo</em
      > (por ejemplo,
      <InlinePowerShell code="Get-Process" /> o <InlinePowerShell
        code="New-Item"
      />), lo que los hace más expresivos y fáciles de entender que muchos
      comandos en Bash. A diferencia de los ejecutables tradicionales, los
      cmdlets devuelven
      <em>objetos .NET</em>, lo que permite combinarlos en pipelines potentes y
      consistentes.</Footnote
    >

    <Footnote index={3}
      >Puedes ajustar <InlinePowerShell code="#Requires" /> a otra versión, pero
      no garantizamos compatibilidad con PowerShell anterior.</Footnote
    ></Footnotes
  ></NotesLayout
>

<!-- <NotesSection id="scripting-101">
      <Heading headingLevel="h2" Icon={icons.Terminal}
        >Scripting 101: PowerShell y Bash</Heading
      >

      <Definition>
        <Fragment slot="title">El patrón de ensayo seguro</Fragment>
        <p>
          Siempre que un script <em>cambie cosas</em>, ensaya primero: en
          PowerShell con
          <InlinePowerShell code="-WhatIf" /> y en Bash activando <InlineBash
            code="DRY_RUN=true"
          />. Así ves lo que haría sin tocar nada.<FootnoteRef index={101} />
        </p>
      </Definition>

      <Terminals
        powerShellCode={`
# PowerShell — script esqueleto con ensayo seguro
#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess, ConfirmImpact='Medium')]
param(
  [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string] $Target
)

$ErrorActionPreference = 'Stop'

if (-not (Test-Path -LiteralPath $Target -PathType Container)) {
  if ($PSCmdlet.ShouldProcess($Target, 'Create directory')) {
    New-Item -ItemType Directory -Path $Target -Force | Out-Null
  }
}

Write-Verbose "All good at '$Target'"
    `}
        bashCode={`#!/usr/bin/env bash
# Bash — script esqueleto con DRY_RUN
set -euo pipefail

TARGET="\${1:-}"
if [[ -z "\${TARGET}" ]]; then
  echo "Usage: scaffold.sh <target-dir>" >&2
  exit 1
fi

run () {
  if [[ "\${DRY_RUN:-false}" == "true" ]]; then
    echo "[dry-run] $*"
  else
    eval "$@"
  fi
}

[[ -d "\${TARGET}" ]] || run "mkdir -p \"\${TARGET}\""
echo "All good at '\${TARGET}'"
    `}
      >
        <Fragment slot="powershell-title"
          >Plantilla mínima de PowerShell (con <code>-WhatIf</code>)</Fragment
        >
        <Fragment slot="powershell-explanation">
          <icons.List>
            <ListItem icon={icons.Info}>
              <InlinePowerShell code="[CmdletBinding(SupportsShouldProcess)]" />
              convierte el script en
              <em>cmdlet avanzado</em> y habilita <InlinePowerShell
                code="-WhatIf"
              /> /
              <InlinePowerShell code="-Confirm" />.
            </ListItem>
            <ListItem icon={icons.FolderPlus}>
              <InlinePowerShell
                code="Test-Path -LiteralPath ... -PathType Container"
              /> comprueba la carpeta sin interpretar comodines. <InlinePowerShell
                code="$PSCmdlet.ShouldProcess"
              /> anuncia y controla la acción (puedes simular con <InlinePowerShell
                code="-WhatIf"
              />).
            </ListItem>
            <ListItem icon={icons.SpeakerHigh}>
              <InlinePowerShell code="Write-Verbose" /> aparece al ejecutar con <InlinePowerShell
                code="-Verbose"
              />.
            </ListItem>
          </icons.List>
        </Fragment>

        <Fragment slot="bash-title"
          >Plantilla mínima de Bash (con <code>DRY_RUN</code>)</Fragment
        >
        <Fragment slot="bash-explanation">
          <icons.List>
            <ListItem icon={icons.Bug}>
              <InlineBash code="set -euo pipefail" /> endurece el script:
              <icons.List>
                <ListItem icon={icons.WarningCircle}
                  ><InlineBash code="-e" /> aborta si un comando falla.</ListItem
                >
                <ListItem icon={icons.Question}
                  ><InlineBash code="-u" /> falla si usas variables sin definir.</ListItem
                >
                <ListItem icon={icons.ArrowsLeftRight}
                  ><InlineBash code="-o pipefail" /> propaga errores en <em
                    >pipelines</em
                  >.</ListItem
                >
              </icons.List>
            </ListItem>
            <ListItem icon={icons.Function}>
              <InlineBash code="run(){ ... }" /> centraliza ejecución real o simulada
              con <InlineBash code="DRY_RUN=true" />.
            </ListItem>
            <ListItem icon={icons.WarningCircle}>
              Validación de argumentos: <InlineBash
                code='if [[ -z "${1:-}" ]]; then ... fi'
              /> imprime <em>usage</em> en <InlineBash code="stderr" /> y sale.
            </ListItem>
          </icons.List>
        </Fragment>
      </Terminals>

      <Heading headingLevel="h3" Icon={icons.Path}>Rutas y portabilidad</Heading
      >
      <Terminals
        powerShellCode={`
# Normalizar una ruta relativa con base en el directorio actual
$root = if ([IO.Path]::IsPathRooted($ProjectRoot)) { $ProjectRoot }
        else { Join-Path -Path $PWD.Path -ChildPath $ProjectRoot }

Write-Verbose "Root: $root"
    `}
        bashCode={`#!/usr/bin/env bash
set -euo pipefail

PROJECT_ROOT="\${1:-}"
case "\${PROJECT_ROOT}" in
  /*|?:/*) ROOT="\${PROJECT_ROOT}" ;;     # absoluta (Unix) o "C:/..." (Windows/MSYS)
  *)       ROOT="\${PWD}/\${PROJECT_ROOT}" ;;
esac
echo "Root: \${ROOT}"
    `}
      >
        <Fragment slot="powershell-title"
          >PowerShell: normalización de rutas</Fragment
        >
        <Fragment slot="powershell-explanation">
          <icons.List>
            <ListItem icon={icons.Path}
              ><InlinePowerShell code="Join-Path $PWD.Path ..." /> convierte rutas
              relativas en absolutas.</ListItem
            >
            <ListItem icon={icons.Hash}
              ><InlinePowerShell code="$PWD" /> es el directorio actual.</ListItem
            >
          </icons.List>
        </Fragment>

        <Fragment slot="bash-title">Bash: normalización de rutas</Fragment>
        <Fragment slot="bash-explanation">
          <icons.List>
            <ListItem icon={icons.Path}
              ><InlineBash code="$PWD" /> es el directorio actual.</ListItem
            >
            <ListItem icon={icons.Terminal}>
              <InlineBash code="case ... in ... esac" /> compara texto con patrones;
              usamos
              <InlineBash code="/*|?:/*" /> para rutas absolutas, y el comodín <InlineBash
                code="*"
              /> para relativas.
            </ListItem>
          </icons.List>
        </Fragment>
      </Terminals>

      <Heading headingLevel="h3" Icon={icons.Rocket}
        >Ejecutar herramientas de forma segura</Heading
      >
      <Terminals
        powerShellCode={`
# Localizar el ejecutable correcto y ejecutar con argumentos
$gradle = (Get-Command gradle -ErrorAction Stop).Source
& $gradle -p $root init @GradleOptions
if ($LASTEXITCODE) { throw "Gradle exited with code $LASTEXITCODE." }
    `}
        bashCode={`#!/usr/bin/env bash
set -euo pipefail

command -v gradle >/dev/null 2>&1 || { echo "Gradle not found" >&2; exit 127; }
gradle -p "\${ROOT}" init "\${GRADLE_OPTS[@]}"
    `}
      >
        <Fragment slot="powershell-title"
          >PowerShell: localizar y ejecutar</Fragment
        >
        <Fragment slot="powershell-explanation">
          <icons.List>
            <ListItem icon={icons.MagnifyingGlass}
              ><InlinePowerShell code="Get-Command ... .Source" /> obtiene la ruta
              real del ejecutable (evita alias).</ListItem
            >
            <ListItem icon={icons.Terminal}
              ><InlinePowerShell code="&" /> es el <em>call operator</em> (ejecuta
              la ruta). <InlinePowerShell code="@Args" /> = <em>splatting</em> de
              arrays.</ListItem
            >
            <ListItem icon={icons.WarningCircle}
              ><InlinePowerShell code="$LASTEXITCODE" /> contiene el código de salida
              del último proceso nativo (0 = OK).</ListItem
            >
          </icons.List>
        </Fragment>

        <Fragment slot="bash-title">Bash: validar y ejecutar</Fragment>
        <Fragment slot="bash-explanation">
          <icons.List>
            <ListItem icon={icons.MagnifyingGlass}
              ><InlineBash code="command -v gradle" /> valida que exista en <InlineBash
                code="$PATH"
              />.</ListItem
            >
            <ListItem icon={icons.Code}
              ><InlineBash code='"${GRADLE_OPTS[@]}"' /> preserva cada flag como
              elemento (no rompe espacios).</ListItem
            >
          </icons.List>
        </Fragment>
      </Terminals>

      <Heading headingLevel="h3" Icon={icons.Gear}
        >Buenas prácticas express</Heading
      >
      <icons.List>
        <ListItem icon={icons.CheckCircle}>
          <strong>Siempre ensaya</strong>: <InlinePowerShell code="-WhatIf" /> o
          <InlineBash code="DRY_RUN=true" />.
        </ListItem>
        <ListItem icon={icons.CheckCircle}>
          <strong>Valida entradas</strong>: parámetros obligatorios (PS) / <InlineBash
            code="if [[ -z ... ]]"
          /> (Bash).
        </ListItem>
        <ListItem icon={icons.CheckCircle}>
          <strong>Falla rápido</strong>: <InlinePowerShell
            code="$ErrorActionPreference='Stop'"
          /> /
          <InlineBash code="set -euo pipefail" />.
        </ListItem>
        <ListItem icon={icons.CheckCircle}>
          <strong>Rutas seguras</strong>: <InlinePowerShell code="Join-Path" /> y
          <InlineBash code="$PWD" /> para absolutas.
        </ListItem>
        <ListItem icon={icons.CheckCircle}>
          <strong>Mensajería útil</strong>: usa <InlinePowerShell
            code="Write-Verbose"
          /> y escribe <em>usage</em> a <InlineBash code="stderr" />.
        </ListItem>
      </icons.List>

      <More>
        <Fragment slot="title">Reutilizar utilidades</Fragment>
        <p>
          Extrae helpers a archivos reutilizables para mantener los scripts
          simples. Ej.: un
          <InlineBash code="run.sh" /> que encapsule ejecución real o simulada con
          <InlineBash code="DRY_RUN" />, y un módulo de PowerShell que exporte
          funciones con <InlinePowerShell code="SupportsShouldProcess" />.
        </p>
        <Terminals
          powerShellCode={`
# Module.psm1 (extracto)
function Invoke-Safely {
  [CmdletBinding(SupportsShouldProcess)]
  param([Parameter(Mandatory)][string]$Action,[Parameter(Mandatory)][scriptblock]$Do)
  if ($PSCmdlet.ShouldProcess($Action)) { & $Do }
}
Export-ModuleMember -Function Invoke-Safely
      `}
          bashCode={`#!/usr/bin/env bash
# run.sh — reutilizable
set -euo pipefail
if [[ "\${DRY_RUN:-false}" == "true" ]]; then echo "[dry-run] $*"; else eval "$@"; fi
      `}
        >
          <Fragment slot="powershell-title"
            >PowerShell: helper reutilizable</Fragment
          >
          <Fragment slot="bash-title">Bash: runner reutilizable</Fragment>
        </Terminals>
      </More>

      <Footnotes>
        <Footnote index={101}>
          <p class="mb-2">
            Ejemplo de <strong>error detectado por el ensayo</strong> al no normalizar
            ruta en PowerShell:
          </p>
          <pre
            class="bg-base-200 text-xs rounded p-3 overflow-x-auto">
What if: Performing the operation "Create Directory" on target "Destination: C:\Users\usuario\veritas".
What if: Performing the operation "gradle init" on target "C:\Users\usuario\veritas".
      </pre>
          <p class="mt-2">
            La corrección fue usar <InlinePowerShell
              code="Join-Path -Path $PWD.Path -ChildPath ..."
            /> para anclar al directorio actual. En Bash el equivalente práctico
            es anteponer <InlineBash code="$PWD" />.
          </p>
        </Footnote>
      </Footnotes>
    </NotesSection>
    <NotesSection id="...">
      <Heading headingLevel="h2" Icon={icons.GitBranch}
        >Inicializa y versiona con GitLab (ensayo primero)</Heading
      >

      <p class="mb-4">
        Si quieres versionar tu estructura desde el inicio, automatiza la
        creación del repo local y remoto en GitLab.
        <strong>Primero ensaya</strong> con <InlinePowerShell code="-WhatIf" /> (PowerShell)
        o
        <InlineBash code="--dry-run" /> (Bash) para ver qué ocurrirá sin realizar
        cambios.
      </p>

      <Terminals
        powerShellCode={`
#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
param(
  [ValidateNotNullOrEmpty()]
  [Parameter(Mandatory)]
  [string] $User,

  [ValidateNotNullOrEmpty()]
  [string] $RepositoryDirectory = $PWD.Path,

  [string] $RepositoryName,
  [string] $Prefix
)

$ErrorActionPreference = 'Stop'

# Normalizar y validar carpeta destino (acepta relativa)
$RepositoryDirectory = (Resolve-Path -LiteralPath $RepositoryDirectory -ErrorAction Stop).Path
$repoDirInfo = Get-Item -LiteralPath $RepositoryDirectory
if (-not $repoDirInfo.PSIsContainer) {
  throw "The path '$RepositoryDirectory' is not a directory."
}

# Derivar nombre/prefijo si faltan
if (-not $RepositoryName -or [string]::IsNullOrWhiteSpace($RepositoryName)) {
  $RepositoryName = $repoDirInfo.Name.ToLower()
}
if (-not $Prefix -and $repoDirInfo.Parent) {
  $Prefix = $repoDirInfo.Parent.Name.ToLower()
}

# Nombre final remoto
$target = if ([string]::IsNullOrWhiteSpace($Prefix)) { $RepositoryName } else { "$Prefix-$RepositoryName" }

# Crear remoto en GitLab (ensayable con -WhatIf/-Confirm)
if ($PSCmdlet.ShouldProcess($target, 'Create GitLab repository')) {
  Push-Location -LiteralPath $repoDirInfo.FullName
  try {
    git init
    glab repo create $target --public
    if ($LASTEXITCODE) { throw "glab exited with code $LASTEXITCODE." }
    git remote add origin "https://gitlab.com/$User/$target.git"
  }
  finally {
    Pop-Location
  }
}
  `}
        bashCode={`#!/usr/bin/env bash
set -euo pipefail

USER=""
REPO_DIR="$(pwd)"
REPO_NAME=""
PREFIX=""
DRY_RUN=false

usage() {
  echo "Usage: $0 -u <user> [-d <directory>] [-n <repo_name>] [-p <prefix>] [--dry-run]"
  exit 1
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -u|--user) USER="$2"; shift 2 ;;
    -d|--dir) REPO_DIR="$2"; shift 2 ;;
    -n|--name) REPO_NAME="$2"; shift 2 ;;
    -p|--prefix) PREFIX="$2"; shift 2 ;;
    --dry-run) DRY_RUN=true; shift ;;
    *) usage ;;
  esac
done

[[ -n "$USER" ]] || { echo "Error: user is required"; usage; }
[[ -d "$REPO_DIR" ]] || { echo "Error: '$REPO_DIR' is not a directory"; exit 1; }

# Derivar nombre/prefijo si faltan
if [[ -z "$REPO_NAME" ]]; then
  REPO_NAME="$(basename "$REPO_DIR" | tr '[:upper:]' '[:lower:]')"
fi
if [[ -z "$PREFIX" ]]; then
  PARENT="$(dirname "$REPO_DIR")"
  PREFIX="$(basename "$PARENT" | tr '[:upper:]' '[:lower:]')"
fi

TARGET="$REPO_NAME"
if [[ -n "$PREFIX" ]]; then
  TARGET="$PREFIX-$REPO_NAME"
fi

echo "Repositorio remoto: $TARGET"

run() {
  if $DRY_RUN; then
    echo "[dry-run] $*"
  else
    eval "$@"
  fi
}

(
  cd "$REPO_DIR"
  run "git init"
  run "glab repo create $TARGET --public"
  run "git remote add origin https://gitlab.com/$USER/$TARGET.git"
)
  `}
      >
        <Fragment slot="powershell-title"
          >PowerShell: crear repo local + remoto en GitLab (con <code
            >-WhatIf</code
          >)</Fragment
        >
        <DibsSourceLink
          repo="scripts"
          file="ps1/New-GitLabRepository.ps1"
          slot="powershell-source"
        />
        <Fragment slot="powershell-explanation">
          <List>
            <ListItem icon={icons.Info}>
              <InlinePowerShell
                code="[CmdletBinding(SupportsShouldProcess, ConfirmImpact='Medium')]"
              /> habilita
              <InlinePowerShell code="-WhatIf" />/<InlinePowerShell
                code="-Confirm"
              /> para ensayar cambios antes de aplicarlos.
            </ListItem>
            <ListItem icon={icons.Path}>
              <InlinePowerShell code="Resolve-Path -LiteralPath" /> normaliza rutas
              y evita comodines; luego se valida que sea carpeta con <InlinePowerShell
                code="Get-Item"
              />.
            </ListItem>
            <ListItem icon={icons.TextB}>
              Si faltan <InlinePowerShell code="$RepositoryName" /> o <InlinePowerShell
                code="$Prefix"
              />, se derivan del árbol de carpetas.
            </ListItem>
            <ListItem icon={icons.CloudArrowUp}>
              <InlinePowerShell code="glab repo create $target --public" /> crea
              el remoto; si falla (<InlinePowerShell code="$LASTEXITCODE" /> ≠ 0)
              se aborta con mensaje claro.
            </ListItem>
          </List>
        </Fragment>

        <Fragment slot="bash-title"
          >Bash/Zsh: crear repo local + remoto en GitLab (con <code
            >--dry-run</code
          >)</Fragment
        >
        <DibsSourceLink
          repo="scripts"
          file="sh/new-gitlab-repository.sh"
          slot="bash-source"
        />
        <Fragment slot="bash-explanation">
          <List>
            <ListItem icon={icons.Bug}>
              <InlineBash code="set -euo pipefail" />: aborta en errores,
              variables no definidas y fallos en pipelines.
            </ListItem>
            <ListItem icon={icons.Terminal}>
              Flags: <InlineBash code="-u/--user" />, <InlineBash
                code="-d/--dir"
              />, <InlineBash code="-n/--name" />,
              <InlineBash code="-p/--prefix" />, <InlineBash
                code="--dry-run"
              />.
            </ListItem>
            <ListItem icon={icons.Eye}>
              <InlineBash code="DRY_RUN=true" /> imprime acciones (no las ejecuta).
              Quita <InlineBash code="--dry-run" /> para aplicar.
            </ListItem>
            <ListItem icon={icons.TextB}>
              Deriva <InlineBash code="TARGET" /> como <code>prefix-name</code> si
              hay prefijo; útil para estandarizar nombres.
            </ListItem>
          </List>
        </Fragment>
      </Terminals>

      <Heading headingLevel="h3" Icon={icons.ListChecks}
        >Flujo sugerido (ensayo → aplicar)</Heading
      >

      <Terminals
        powerShellCode={`
Set-Location 'dibs'
$gitlabUser = '<TU-USUARIO>'  # <- reemplaza aquí
.\scripts\ps1\New-GitLabRepository.ps1 -User $gitlabUser -RepositoryDirectory .\scripts -WhatIf
.\scripts\ps1\New-GitLabRepository.ps1 -User $gitlabUser -RepositoryName index -Prefix dibs -WhatIf
# Si el ensayo luce bien, repite sin -WhatIf
  `}
        bashCode={`
cd dibs
GITLAB_USER="<TU-USUARIO>"  # <- reemplaza aquí
./scripts/sh/new-gitlab-repository.sh -u "$GITLAB_USER" -d ./scripts --dry-run
./scripts/sh/new-gitlab-repository.sh -u "$GITLAB_USER" -n index -p dibs --dry-run
# Si el ensayo luce bien, repite sin --dry-run
  `}
      >
        <Fragment slot="powershell-explanation">
          <p>
            Elige <strong>no</strong> crear carpeta local adicional cuando el asistente
            de <InlinePowerShell code="glab" /> lo pregunte; el script ya opera dentro
            de tu estructura.
          </p>
        </Fragment>
        <Fragment slot="bash-explanation">
          <p>
            Revisa la salida de <InlineBash code="DRY_RUN" />. Si todo se ve
            bien, ejecuta de nuevo sin <InlineBash code="--dry-run" />.
          </p>
        </Fragment>
      </Terminals>

      <Tip class="my-4">
        <Fragment slot="title">.gitignore</Fragment>
        Genera un <code>.gitignore</code> adecuado para cada repo; útil:
        <Link href="https://www.toptal.com/developers/gitignore/"
          >toptal.com/developers/gitignore</Link
        >.
      </Tip>

      <Terminals
        powerShellCode={`
# Commit del repo 'dibs/scripts' y subirlo. Luego agregarlo como submódulo en 'dibs/index'.
Push-Location '.\scripts'
git add .
git commit -m "chore(scripts): initial scaffolding and GitLab integration utilities"
git push -u origin main
Pop-Location

git submodule add "https://gitlab.com/$gitlabUser/dibs-scripts.git" scripts
git add .gitmodules scripts
git commit -m "chore(index): add scripts as submodule"
git push -u origin main
  `}
        bashCode={`
# Commit del repo 'dibs/scripts' y subirlo. Luego agregarlo como submódulo en 'dibs/index'.
(
  cd scripts
  git add .
  git commit -m "chore(scripts): initial scaffolding and GitLab integration utilities"
  git push -u origin main
)

git submodule add "https://gitlab.com/$GITLAB_USER/dibs-scripts.git" scripts
git add .gitmodules scripts
git commit -m "chore(index): add scripts as submodule"
git push -u origin main
  `}
      >
        <Fragment slot="powershell-title"
          >Versionar y añadir como submódulo (PowerShell)</Fragment
        >
        <Fragment slot="bash-title"
          >Versionar y añadir como submódulo (Bash/Zsh)</Fragment
        >
      </Terminals>
    </NotesSection> -->
