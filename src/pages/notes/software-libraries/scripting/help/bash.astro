---
import * as icons from "~/assets/img/icons";
import { Heading, P } from "~/components/semantics";
import { Abstract, Explanation, More, Tip, Warning } from "~/components/ui/callouts";
import Question from "~/components/ui/callouts/Question.astro";
import { BashBlock, OutputBlock } from "~/components/ui/code";
import { B, I, Mono } from "~/components/ui/font";
import { List, ListItem } from "~/components/ui/list";
import ToDo from "~/components/utils/ToDo";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
---

<NotesLayout
    title="Bash: Descubrimiento y ayuda integrada"
    description="Si estás leyendo esto, es porque se me olvidó actualizar el meta description en el frontmatter."
>
    <Abstract>
        <ToDo
            client:only="react"
            metadata={{
                tasks: [
                    "...",
                ],
            }}
        />
    </Abstract>

    <NotesSection id="h2-discovery-bash">
        <Heading
            headingLevel="h2" Icon={icons.MagnifyingGlass}
            slot="heading"
        >
            Descubrir comandos en Bash
        </Heading>

        <P>
            En Bash no hay un índice único de comandos: se combinan varias utilidades. Úsalas en conjunto para cubrir lo
            que en PowerShell harías con un solo cmdlet de descubrimiento.
        </P>

        <BashBlock
            code={`
                printf "Comandos que contienen 'gradle' en el PATH:\\n"
                compgen -c | sort -u | grep -i gradle || printf "(ninguno)\\n"

                printf "\\nIntentos de localización rápida de 'gradle':\\n"
                which -a gradle 2>/dev/null || true
                whereis -b gradle
                command -v gradle 2>/dev/null || printf "gradle no está en PATH\\n"

                printf "\\nUbicaciones/implementaciones de 'ls':\\n"
                type -a ls
                command -v ls
                which -a ls 2>/dev/null
                whereis -b ls
                file "$(command -v ls)"

                printf "\\nBúsquedas en páginas de manual:\\n"
                whatis ls
                apropos gradle
                man -k '^ls '

                printf "\\nFunciones definidas en la sesión:\\n"
                declare -F | sed 's/declare -f //'

                printf "\\nAliases que incluyan 'ls' o 'grep':\\n"
                alias | grep -Ei '(^| )ls=|(^| )grep=' || printf "(ninguno)\\n"

                printf "\\nAlgunos builtins disponibles (compgen -b | head):\\n"
                compgen -b | sort -u | head

                printf "\\nAlgunos aliases disponibles (compgen -a | head):\\n"
                compgen -a | sort -u | head

                printf "\\nTodas las funciones (compgen -A function):\\n"
                compgen -A function | sort -u | head

            `}
        ></BashBlock>

        <OutputBlock code={`
            Comandos que contienen 'gradle' en el PATH:
            _gradle
            gradle
            ...

            Intentos de localización rápida de 'gradle':
            /home/uwuntu/.nix-profile/bin/gradle
            /home/uwuntu/.sdkman/candidates/gradle/current/bin/gradle
            /mnt/b/scoop/shims/gradle

            Ubicaciones/implementaciones de 'ls':
            ls is an alias for ls --color=tty
            ...
            ls: aliased to ls --color=tty
            /usr/bin/ls
            /bin/ls
            ...

            Búsquedas en páginas de manual:
            ls (1)               - list directory contents
            gradle: nothing appropriate.
            ^ls : nothing appropriate.

            Funciones definidas en la sesión:
            EPOCHREALTIME
            _POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=3.0000000000
            _POWERLEVEL9K_DIR_MIN_COMMAND_COLUMNS_PCT=50.0000000000
            ...

            Aliases que incluyan 'ls' o 'grep':
            grep='grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox,.venv,venv}'
            ls='ls --color=tty'

            Algunos builtins disponibles (compgen -b | head):
            -
            .
            :
            [
            alias
            autoload
            ...

            Algunos aliases disponibles (compgen -a | head):
            -
            1
            2
            ...

            Todas las funciones (compgen -A function):
            +vi-git-aheadbehind
            +vi-git-remotebranch
            ...
        `} />
        <Explanation>
            <List>
                <ListItem icon={icons.Sparkle}>
                    <B>Completado y comandos “descubiertos” por el shell</B><br />
                    <Mono>complete -p</Mono> — inspecciona reglas de autocompletado (útil para “aprender” opciones
                    comunes).<br />
                    <Mono>compgen -A function</Mono> — solo funciones; <Mono>compgen -A alias</Mono> — solo alias.
                </ListItem>
            </List>
        </Explanation>

        <Tip Icon={icons.Lightbulb}>
            <Fragment slot="title">Pista rápida de descubrimiento</Fragment>
            <P>
                Para tantear “qué hay de X”: <Mono>apropos X</Mono> (ideas), luego <Mono>type</Mono> para clasificar el
                candidato y finalmente <Mono>man</Mono>/<Mono>--help</Mono> para concretar sintaxis.
            </P>
        </Tip>
    </NotesSection>

    <NotesSection id="h2-help-bash">
        <Heading
            headingLevel="h2" Icon={icons.BookOpen}
            slot="heading"
        >
            Ayuda integrada en Bash (equivalente a “cómo se usa”)
        </Heading>

        <P>
            En Bash la ayuda depende del tipo de comando. Los <I>builtins</I> tienen su propia ayuda; los ejecutables
            suelen ofrecer <Mono>--help</Mono> y <Mono>man</Mono>. No hay un esquema uniforme de parámetros ni
            metadatos.
        </P>

        <Explanation>
            <List>
                <ListItem icon={icons.Cpu}>
                    <B>Builtins de Bash</B><br />
                    <Mono>help cd</Mono> / <Mono>help printf</Mono> — documentación breve del builtin.<br />
                    <Mono>help -d nombre</Mono> — resumen; <Mono>help -m nombre</Mono> — formato estilo <I>man</I>.
                </ListItem>

                <ListItem icon={icons.FileText}>
                    <B>Ejecutables del sistema</B><br />
                    <Mono>ls --help</Mono> — ayuda en línea de comandos (no estandarizada).<br />
                    <Mono>man 1 ls</Mono> — página de manual completa (secciones: 1=usuario, 2=sistema, 3=biblioteca,
                    etc.).<br />
                    <Mono>MANPAGER='less -p "^ *OPTIONS"' man grep</Mono> — abre <I>man</I> resaltando la sección de
                    opciones.
                </ListItem>

                <ListItem icon={icons.Bookmark}>
                    <B>Documentación extendida</B><br />
                    <Mono>info coreutils 'printf invocation'</Mono> — manuales <I>info</I> con más detalle y
                    navegación.<br />
                    <Mono>tldr tar</Mono> — resúmenes comunitarios (si instalas <I>tldr</I>); o <Mono>curl
                        cheat.sh/tar</Mono>.
                </ListItem>

                <ListItem icon={icons.Globe}>
                    <B>Ayuda online</B><br />
                    Muchas utilidades indican su URL en <Mono>--help</Mono> o la página <I>man</I>. Ej.: <I>GNU grep</I>
                    enlaza a su manual web.
                </ListItem>
            </List>
        </Explanation>

        <More>
            <Fragment slot="title">Ejemplos comparativos (solo Bash)</Fragment>
            <P><B>Encontrar comandos “de procesos”:</B> <Mono>apropos process | head</Mono></P>
            <P><B>Ver si <I>grep</I> es builtin, alias o binario y dónde vive:</B> <Mono>type -a grep</Mono></P>
            <P><B>Aprender uso mínimo de un builtin:</B> <Mono>help pushd</Mono></P>
            <P><B>Ver opciones y ejemplos cortos:</B> <Mono>tldr find</Mono> (o <Mono>man find</Mono> para el
                completo)</P>
            <P><B>Inspeccionar una función de shell que “descubriste”:</B> <Mono>type mi_funcion</Mono></P>
        </More>

        <Warning>
            <Fragment slot="title">Limitación clave vs PowerShell</Fragment>
            <P>
                En Bash no existen <I>conjuntos de parámetros</I> ni metadatos de tipado/validaciones accesibles de
                forma estándar. Cada programa define su sintaxis; no puedes inferir automáticamente tipos, posiciones o
                exclusividades como harías con la ayuda de un cmdlet.
            </P>
        </Warning>
    </NotesSection>

    <NotesSection id="h2-what-one-can-do">
        <Heading
            headingLevel="h2" Icon={icons.Scales}
            slot="heading"
        >
            ¿Qué se puede hacer en uno y no en el otro?
        </Heading>

        <Explanation>
            <List>
                <ListItem icon={icons.CheckCircle}>
                    <B>Solo (o mejor) en Bash</B>
                    <List class="mt-2">
                        <ListItem icon={icons.BracketsCurly}>
                            <I>Inspeccionar y editar</I> funciones de shell al vuelo: <Mono>type nombre</Mono> muestra
                            su cuerpo; puedes redefinirlas en la sesión sin herramientas externas.
                        </ListItem>
                        <ListItem icon={icons.Lightning}>
                            <I>Completado específico</I> de cada herramienta: muchos paquetes instalan reglas de <Mono
                            >complete</Mono>
                            que aportan pistas de uso (aunque no son metadatos formales).
                        </ListItem>
                    </List>
                </ListItem>

                <ListItem icon={icons.XCircle}>
                    <B>Solo (o mejor) en PowerShell</B>
                    <List class="mt-2">
                        <ListItem icon={icons.BookOpen}>
                            <I>Temas conceptuales</I> unificados (<Mono>about_*</Mono>) y <I>ayuda actualizable</I> sin
                            conexión para módulos.
                        </ListItem>
                        <ListItem icon={icons.Funnel}>
                            <I>Metadatos de parámetros</I> (tipos, posiciones, obligatoriedad, <I>parameter sets</I>) y
                            convención
                            <Mono>Verbo-Sustantivo</Mono> que facilita el descubrimiento sistemático.
                        </ListItem>
                    </List>
                </ListItem>
            </List>
        </Explanation>

        <Tip Icon={icons.Lightbulb}>
            <Fragment slot="title">Estrategia híbrida</Fragment>
            <P>
                En entornos mixtos, usa Bash para <I>interactuar con utilidades POSIX</I> y aprovechar su presencia
                universal; y apóyate en PowerShell cuando necesites <I>descubribilidad consistente</I> y <I
                >autodescripción de comandos</I>.
            </P>
        </Tip>
    </NotesSection>

    <Question>
        Usando <Mono>apropos</Mono> y <Mono>man</Mono>, encuentra una utilidad que convierta salida a HTML y revisa sus
        opciones principales. Luego clasifícala con <Mono>type -a</Mono> y comprueba si dispone de <Mono>--help</Mono>,
        <Mono>man</Mono> e <Mono>info</Mono>.
    </Question>

    <ConclusionsLayout>
        <Fragment slot="conclusions">
            Bash ofrece buenas rutas de <B>descubrimiento</B> (catálogo <I>man</I>, <Mono>apropos</Mono>, <Mono
            >type</Mono>,
            <Mono>compgen</Mono>), pero distribuidas y heterogéneas; PowerShell concentra la experiencia en comandos y
            metadatos unificados. Entender ambas filosofías te permite moverte con soltura entre ecosistemas.
        </Fragment>

        <Fragment slot="key-points">
            <ListItem icon={icons.MagnifyingGlass}>
                <Mono>apropos</Mono>/<Mono>man -k</Mono> y <Mono>type</Mono> cubren el “qué existe” en Bash; no hay un
                índice único.
            </ListItem>
            <ListItem icon={icons.BookOpen}>
                <Mono>help</Mono> (builtins), <Mono>--help</Mono> (ejecutables), <Mono>man</Mono>/<Mono>info</Mono>
                componen la ayuda.
            </ListItem>
            <ListItem icon={icons.WarningCircle}>
                No hay metadatos estandarizados de parámetros ni conjuntos de parámetros como en PowerShell.
            </ListItem>
            <ListItem icon={icons.BracketsCurly}>
                En Bash puedes inspeccionar el <I>código</I> de funciones de shell al instante (<Mono>type</Mono>).
            </ListItem>
        </Fragment>

        <Fragment slot="takeaways">
            Si vienes de PowerShell, piensa en Bash como un <I>“kit de piezas”</I> para descubrir y aprender: combina
            <Mono>apropos</Mono>, <Mono>type</Mono> y <Mono>man</Mono> según el caso. No esperes uniformidad; diseña tu
            propio flujo de descubrimiento. A cambio, ganarás portabilidad y cercanía al ecosistema POSIX.
        </Fragment>
    </ConclusionsLayout>
</NotesLayout>
