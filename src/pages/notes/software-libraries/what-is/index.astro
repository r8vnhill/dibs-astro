---
import Heading from "~/components/semantics/Heading.astro";
import NotesLayout from "~/layouts/NotesLayout.astro";
import NotesSection from "~/layouts/NotesSection.astro";
import * as icons from "~/assets/img/icons";
import { ListItem, List } from "~/components/ui/list";
import { Abstract, Important, Info, More, Tip } from "~/components/ui/callouts";
import { Link } from "~/components/ui/links";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "~/components/starwind/tooltip";
import JvmTooltip from "~/fragments/tooltips/JvmTooltip.astro";
import DotNetTooltip from "~/fragments/tooltips/DotNetTooltip.astro";
import ConclusionsLayout from "~/layouts/ConclusionsLayout.astro";
import { References, WebPage } from "~/components/ui/references";
---

<NotesLayout title="Bibliotecas de software">
  <Abstract>
    <p>
      Esta lección introduce el concepto de <strong
        >biblioteca de software</strong
      > como pieza central en el desarrollo moderno: colecciones de funciones, clases
      y componentes que encapsulan soluciones reutilizables. Exploramos qué significa
      tratarlas como <em>APIs</em>, por qué son fundamentales para acelerar el
      desarrollo y asegurar calidad, y cómo se diferencian —y relacionan— con <em
        >frameworks</em
      >, <em>servicios</em>, <em>paquetes</em>
      y <em>módulos</em>.
    </p>
    <p>
      También revisamos las principales <strong
        >categorías de bibliotecas</strong
      > (estáticas, dinámicas, de código fuente, de clases, de tiempo de ejecución
      y estándar del lenguaje), junto con ejemplos populares en distintos ecosistemas
      (Kotlin, Java, Python, C++, .NET). Estos elementos sientan las bases para nuestro
      siguiente paso: <strong>diseñar y publicar bibliotecas en Kotlin</strong> aplicando
      principios de buen diseño de APIs.
    </p>
  </Abstract>

  <NotesSection id="what-is">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Books}>
      ¿Qué es una biblioteca de software?
    </Heading>

    <p>
      Una <strong>biblioteca de software</strong> es un conjunto organizado de funciones,
      clases y componentes diseñados para resolver problemas específicos y reutilizarse
      en diferentes proyectos. A diferencia de una aplicación completa, una biblioteca
      no se ejecuta por sí sola: se integra en otros programas para <strong
        >ampliar sus capacidades</strong
      >.
    </p>

    <p>
      En esencia, una biblioteca encapsula <strong
        >soluciones reutilizables</strong
      >
      a tareas comunes —como manejar archivos, conectarse a redes o procesar datos—
      de manera que no tengamos que reinventarlas cada vez.
    </p>

    <NotesSection id="api">
      <Heading slot="heading" headingLevel="h3" Icon={icons.Plugs}>
        Interfaz de programación de aplicaciones (Application Programming
        Interface, API)
      </Heading>

      <p>
        Una <strong>API</strong> es el <em>contrato</em> que define <strong
          >qué</strong
        > puede hacer un componente (nombres, parámetros, tipos, errores, semántica),
        sin exponer
        <strong>cómo</strong> lo hace. Es la <em>superficie pública</em> con la que
        otras partes del sistema interactúan.
      </p>

      <Important>
        <Fragment slot="title">API ≠ biblioteca</Fragment>
        <p>
          Una <strong>biblioteca</strong> es una implementación reutilizable; <strong
            >expone</strong
          >
          una API. Pero una API también puede ser un servicio web, un sistema operativo,
          o las primitivas de un framework. Toda biblioteca tiene API, pero no toda
          API es una biblioteca.
        </p>
      </Important>

      <p>
        Considerar una <strong>biblioteca como una API</strong> nos permite razonar
        sobre su diseño desde la perspectiva de cómo será utilizada. En otras palabras,
        los
        <em>principios de diseño de buenas APIs</em> —claridad, consistencia, facilidad
        de uso, extensibilidad— también deben permear el diseño de bibliotecas. Estos
        principios se explorarán en una lección futura, y nos darán criterios concretos
        para evaluar y mejorar nuestras propias bibliotecas.
      </p>
    </NotesSection>
  </NotesSection>

  <NotesSection id="why-we-need">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Question}>
      ¿Por qué necesitamos bibliotecas de software?
    </Heading>

    <p>
      Las bibliotecas existen para <strong>no reinventar la rueda</strong>.
      Permiten reutilizar soluciones probadas y enfocarnos en el <strong
        >dominio del problema</strong
      >, no en la infraestructura repetitiva.
    </p>

    <List>
      <ListItem icon={icons.RocketLaunch}>
        <strong>Velocidad</strong>: aceleran el desarrollo al reutilizar
        componentes listos.
      </ListItem>
      <ListItem icon={icons.ShieldCheck}>
        <strong>Calidad y seguridad</strong>: concentran correcciones, pruebas y
        auditorías en un solo lugar.
      </ListItem>
      <ListItem icon={icons.Stack}>
        <strong>Consistencia</strong>: estandarizan prácticas (APIs, formatos,
        estilos).
      </ListItem>
      <ListItem icon={icons.Plugs}>
        <strong>Interoperabilidad</strong>: conectan sistemas (protocolos,
        formatos, drivers).
      </ListItem>
      <ListItem icon={icons.Wrench}>
        <strong>Mantenibilidad</strong>: actualizaciones y mejoras se propagan
        sin duplicar esfuerzos.
      </ListItem>
      <ListItem icon={icons.Scales}>
        <strong>Gestión de riesgos</strong>: delegan complejidad técnica en
        paquetes mantenidos por especialistas.
      </ListItem>
    </List>

    <Tip>
      <Fragment slot="title">Regla práctica</Fragment>
      Si un problema es <em>común</em> y la solución está bien entendida y mantenida,
      <strong>usa una biblioteca</strong>. Invierte desarrollo propio solo
      cuando la solución impacta tu <em>ventaja competitiva</em> o necesidades únicas.
    </Tip>

    <NotesSection id="open-source">
      <Heading
        slot="heading"
        headingLevel="h3"
        Icon={icons.GlobeHemisphereEast}
      >
        Open-source
      </Heading>

      <p>
        En el ecosistema abierto, las bibliotecas son el <strong
          >tejido base</strong
        > de la innovación: miles de proyectos que evolucionan en comunidad.
      </p>

      <List>
        <ListItem icon={icons.UsersThree}>
          <strong>Colaboración</strong>: correcciones y mejoras desde una base
          de contribuyentes diversa.
        </ListItem>
        <ListItem icon={icons.GitBranch}>
          <strong>Transparencia</strong>: código auditable (<em
            ><Link
              href="https://opensource.com/article/21/6/security-transparency"
              >security by transparency</Link
            ></em
          >).
        </ListItem>
        <ListItem icon={icons.ArrowsClockwise}>
          <strong>Ritmo de innovación</strong>: adopción rápida de estándares y
          mejores prácticas.
        </ListItem>
        <ListItem icon={icons.Certificate}>
          <strong>Licencias</strong>: elige licencias compatibles (MIT,
          Apache-2.0, MPL, GPL) según tu caso.
        </ListItem>
      </List>
    </NotesSection>

    <NotesSection id="proprietary">
      <Heading slot="heading" headingLevel="h3" Icon={icons.Factory}>
        Software propietario
      </Heading>

      <p>
        Aun en contextos cerrados, las bibliotecas son clave para <strong
          >reducir costos</strong
        >,
        <strong>acelerar entregas</strong> y <strong>proteger la calidad</strong
        >.
      </p>

      <List>
        <ListItem icon={icons.PuzzlePiece}>
          <strong>Modularidad interna</strong>: equipos independientes que se
          comunican mediante contratos (APIs) estables.
        </ListItem>
        <ListItem icon={icons.SealWarning}>
          <strong>Cumplimiento y riesgos</strong>: control de versiones,
          auditorías y trazabilidad.
        </ListItem>
        <ListItem icon={icons.CurrencyDollarSimple}>
          <strong
            >Retorno de la inversión (<em>Return on Investment</em>, <em>ROI</em
            >)</strong
          >: evita duplicación de esfuerzo y <Tooltip>
            <TooltipTrigger>
              <span style="text-decoration: underline; cursor: help;">
                deuda técnica
              </span>
            </TooltipTrigger>
            <TooltipContent>
              <p>
                Costos acumulados por mantener código propio ineficiente o mal
                diseñado.
              </p>
            </TooltipContent>
          </Tooltip> por soluciones ad-hoc.
        </ListItem>
      </List>

      <Info>
        <Fragment slot="title">Política interna recomendada</Fragment>
        Catálogo corporativo de bibliotecas aprobadas, registro de dependencias,
        ventanas de actualización, y guía de versionado.
      </Info>
    </NotesSection>

    <More>
      <Fragment slot="title">¿Cuándo construir y cuándo adoptar?</Fragment>
      <List>
        <ListItem icon={icons.Lightbulb}>
          <strong>Adopta</strong> si existe una biblioteca madura que cubre tu necesidad
          con soporte activo y licencia compatible.
        </ListItem>
        <ListItem icon={icons.Target}>
          <strong>Construye</strong> si tu caso es diferenciador, regulado, o requiere
          garantías que el ecosistema no ofrece (rendimiento, compliance, contratos).
        </ListItem>
        <ListItem icon={icons.FileLock}>
          <strong>Construye</strong> también si ninguna alternativa existente ofrece
          una licencia que se ajuste a los requisitos de tu proyecto (ej. uso comercial,
          distribución, copyleft).
        </ListItem>
      </List>
    </More>
  </NotesSection>
  <NotesSection>
    <Heading slot="heading" headingLevel="h2" Icon={icons.ShareNetwork}>
      ¿Cómo se relacionan las bibliotecas con otros conceptos?
    </Heading>

    <p>
      Una biblioteca es <strong>código reutilizable</strong> que expone una <em
        >API</em
      > y se integra en otras piezas de software. A partir de ahí, se conectan varios
      conceptos cercanos:
    </p>

    <List>
      <ListItem icon={icons.PuzzlePiece}>
        <strong>Framework</strong>: como una biblioteca, pero con <em
          >inversión de control</em
        >. En lugar de que tú llames a la biblioteca, el framework decide el
        flujo principal y llama a tu código en los lugares correctos.
        <em>Ejemplo:</em> un framework web define cómo se atienden las peticiones
        y solo te pide que rellenes las partes específicas (qué hacer en cada ruta).
      </ListItem>

      <ListItem icon={icons.Cloud}>
        <strong>Servicio</strong>: funcionalidad expuesta por red (p. ej.,
        HTTP/REST, gRPC). Se <em>consume</em> desde aplicaciones o bibliotecas clientes.
        <em>Ejemplo:</em> pedirle a un servicio de mapas que devuelva coordenadas
        de una dirección. Un <strong>Microservicio</strong> es un servicio <em
          >pequeño y autónomo</em
        >, que se despliega aparte y colabora con otros (por ejemplo, un
        servicio que solo maneja autenticación de usuarios).
      </ListItem>

      <ListItem icon={icons.Package}>
        <strong>Paquete</strong>: unidad de distribución que puede contener
        bibliotecas, herramientas o recursos.
        <em>Ejemplo:</em> descargar un paquete de utilidades de fechas para no tener
        que programarlas desde cero.
      </ListItem>

      <ListItem icon={icons.Stack}>
        <strong>Módulo</strong>: unidad de organización o compilación dentro de
        un proyecto.
        <em>Ejemplo:</em> dividir un sistema en un módulo <code>lib</code> con la
        lógica de negocio y otro módulo <code>app</code> que la utiliza (volveremos
        a esto).
      </ListItem>
    </List>

    <Info>
      <Fragment slot="title">Mapa mental rápido</Fragment>
      <List>
        <ListItem icon={icons.Plugs}>
          <strong>Biblioteca vs. Framework</strong>: <em>tú llamas</em> a la biblioteca;
          el framework <em>te llama</em> a ti.
        </ListItem>
        <ListItem icon={icons.Cloud}>
          <strong>Biblioteca vs. Servicio</strong>: la biblioteca es <em
            >composición en proceso</em
          >; el servicio es <em>comunicación por red</em>.
        </ListItem>
        <ListItem icon={icons.Package}>
          <strong>Paquete</strong>: cómo distribuyes; <strong>módulo</strong>:
          cómo organizas/compilas.
        </ListItem>
      </List>
    </Info>

    <More>
      <Fragment slot="title">Elección práctica</Fragment>
      <List>
        <ListItem icon={icons.Lightbulb}>
          <strong>Usa bibliotecas</strong> si quieres <em>control local</em>,
          pruebas unitarias simples y dependencia estática.
        </ListItem>
        <ListItem icon={icons.Target}>
          <strong>Usa servicios</strong> si necesitas <em
            >escalado independiente</em
          >, límites claros de despliegue o compartir funcionalidad entre
          múltiples apps.
        </ListItem>
        <ListItem icon={icons.PuzzlePiece}>
          <strong>Usa frameworks</strong> si aceptas su ciclo de vida e inversión
          de control a cambio de productividad y convenciones.
        </ListItem>
      </List>
    </More>
  </NotesSection>
  <NotesSection id="categories">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Folders}>
      Categorías de bibliotecas de software
    </Heading>

    <p>
      A lo largo de la historia se han definido distintas <strong
        >categorías de bibliotecas</strong
      >, según cómo se comparten, se vinculan o se consumen. No es necesario
      estudiarlas todas en detalle, pero conviene conocer las más relevantes
      para entender el ecosistema actual.
    </p>

    <List>
      <ListItem icon={icons.FileCode}>
        <strong>Estáticas</strong>: se <em>incluyen</em> en el programa en tiempo
        de compilación. Una vez compilado, el ejecutable no depende de archivos externos.
        <em>Ejemplo:</em> compilar un binario en C que ya lleva dentro todas las
        funciones de su librería matemática.
      </ListItem>

      <ListItem icon={icons.Link}>
        <strong>Dinámicas / Compartidas</strong>: se cargan en tiempo de
        ejecución. Varios programas pueden compartir la misma copia en memoria,
        reduciendo tamaño y facilitando actualizaciones.
        <em>Ejemplo:</em> las DLL en Windows o los .so en Linux.
      </ListItem>

      <ListItem icon={icons.Code}>
        <strong>De código fuente</strong>: distribuyen directamente el código
        (no compilado). Es el caso más común en <strong
          >ecosistemas modernos</strong
        >
        como Kotlin, donde las dependencias se publican como paquetes y se compilan
        en tu proyecto.
      </ListItem>

      <ListItem icon={icons.Cube}>
        <strong>De clases</strong>: colecciones de tipos y funciones organizadas
        en jerarquías (p. ej., JARs en Java). Son la base de lo que
        <em>diseñaremos en este curso</em>: bibliotecas orientadas a funciones y
        tipos en Kotlin.
      </ListItem>

      <ListItem icon={icons.Toolbox}>
        <strong>De tiempo de ejecución</strong>: exponen utilidades del entorno
        donde se ejecuta el programa (p. ej., manejo de memoria, hilos, E/S).
        Normalmente vienen con el compilador o la plataforma.
      </ListItem>

      <ListItem icon={icons.BookOpen}>
        <strong>Estándar del lenguaje</strong>: la colección oficial de
        funciones, clases y estructuras que acompaña a cada lenguaje.
      </ListItem>
    </List>
  </NotesSection>
  <NotesSection id="examples">
    <Heading slot="heading" headingLevel="h2" Icon={icons.Star}>
      Ejemplos de bibliotecas populares
    </Heading>

    <p>
      Cada ecosistema de programación tiene su propio conjunto de <strong
        >bibliotecas populares</strong
      >. Algunas vienen incluidas como parte de la biblioteca estándar del
      lenguaje, mientras que otras son desarrolladas por la comunidad para
      resolver problemas específicos. Conocerlas ayuda a entender cómo se
      diseñan, se distribuyen y se consumen.
    </p>

    <List>
      <ListItem icon={icons.BookOpen}>
        <strong>Bibliotecas estándar</strong>: cada lenguaje suele traer una
        colección oficial de funciones y clases.
        <em>Ejemplos:</em>
        <Link href="https://kotlinlang.org/api/core/kotlin-stdlib/"
          >Kotlin Standard Library</Link
        > en Kotlin, <Link
          href="https://docs.oracle.com/en/java/javase/24/core/java-core-libraries1.html"
          >Java Core Libraries</Link
        > en Java, <Link href="https://docs.python.org/3/library/index.html"
          >Python Standard Library</Link
        > en Python, <Link
          href="https://en.cppreference.com/w/cpp/standard_library.html"
          >C++ Standard Library</Link
        > en C++.
      </ListItem>

      <ListItem icon={icons.Stack}>
        <strong>Manejo de datos y colecciones</strong>: bibliotecas que amplían
        la capacidad de trabajar con estructuras de datos.
        <em>Ejemplos:</em>
        <Link href="https://github.com/google/guava/">Guava</Link> en Java, <Link
          href="https://pandas.pydata.org/">Pandas</Link
        > en Python,
        <Link href="https://arrow-kt.io/">Arrow</Link> en Kotlin.
      </ListItem>

      <ListItem icon={icons.Network}>
        <strong>Red y comunicación</strong>: facilitan conectarse a internet,
        hacer peticiones HTTP o trabajar con protocolos.
        <em>Ejemplos:</em>
        <Link href="https://square.github.io/okhttp/">OkHttp</Link> en la <JvmTooltip
        />, <Link href="https://requests.readthedocs.io/en/latest/"
          >Requests</Link
        > en Python, <Link href="https://axios-http.com/">Axios</Link> en JavaScript.
      </ListItem>

      <ListItem icon={icons.Lock}>
        <strong>Seguridad y criptografía</strong>: ofrecen primitivas para
        cifrado, autenticación y verificación de datos.
        <em>Ejemplos:</em>
        <Link href="https://www.bouncycastle.org">BouncyCastle</Link> en la <JvmTooltip
        /> y <DotNetTooltip />, <Link href="https://cryptography.io/en/latest/"
          >cryptography</Link
        > en Python,
        <Link href="https://openssl-library.org">OpenSSL</Link> en C/C++.
      </ListItem>

      <ListItem icon={icons.ChartBar}>
        <strong>Procesamiento científico y matemático</strong>: útiles para
        cálculos avanzados, análisis de datos o machine learning.
        <em>Ejemplos:</em>
        <Link href="https://numpy.org/">NumPy</Link> en Python, <Link
          href="https://scikit-learn.org/stable/">scikit-learn</Link
        > en Python,
        <Link href="https://ejml.org/wiki/index.php">EJML</Link> en la <JvmTooltip
        />.
      </ListItem>
    </List>
  </NotesSection>
  <ConclusionsLayout>
    <Fragment slot="conclusions">
      <p>
        En esta lección entendimos que una <strong>biblioteca</strong> es, ante todo,
        una <em>API</em> hecha para ser reutilizada. Esa mirada nos permite evaluar
        su diseño por cómo se <em>usa</em> (claridad, consistencia, estabilidad y
        extensibilidad) más que por cómo está implementada. Vimos también por qué
        las bibliotecas aceleran el desarrollo y elevan la calidad —tanto en open-source
        como en contextos propietarios— y cómo se relacionan con <em
          >frameworks</em
        >, <em>servicios</em>, <em>paquetes</em> y <em>módulos</em>. Finalmente,
        revisamos categorías históricas y actuales (estáticas,
        dinámicas/compartidas, de código fuente, de clases, runtime y estándar
        del lenguaje) para ubicar nuestro trabajo dentro del ecosistema.
      </p>
      <p>
        A partir de aquí, el foco del curso será <strong
          >diseñar bibliotecas de funciones y jerarquías de tipos en Kotlin</strong
        >, organizarlas en <em>paquetes y módulos</em> y publicarlas con <strong
          >Gradle</strong
        >, aplicando principios de buen diseño de APIs que veremos en detalle en
        la siguiente lección.
      </p>
    </Fragment>

    <Fragment slot="key-points">
      <ListItem icon={icons.Plugs}>
        <strong>Biblioteca = API + implementación</strong>: diseñamos para quien
        la usa, no para quien la escribe.
      </ListItem>
      <ListItem icon={icons.ShareNetwork}>
        <strong>Relación con otros conceptos</strong>: framework (invierte
        control), servicio (por red), paquete (distribuye), módulo
        (organiza/compila).
      </ListItem>
      <ListItem icon={icons.Folders}>
        <strong>Categorías relevantes</strong>: estáticas,
        dinámicas/compartidas, de código fuente, de clases, runtime y estándar.
      </ListItem>
      <ListItem icon={icons.RocketLaunch}>
        <strong>Razón práctica</strong>: reutilizar lo común para enfocarnos en
        el dominio y reducir riesgo y deuda técnica.
      </ListItem>
      <ListItem icon={icons.GitBranch}>
        <strong>Ecosistema</strong>: open-source acelera innovación; en
        propietario, estandariza y controla riesgos.
      </ListItem>
    </Fragment>

    <Fragment slot="takeaways">
      <p>
        Las bibliotecas son más que colecciones de código: son contratos de uso
        que moldean cómo pensamos y construimos software. Al verlas como APIs,
        entendemos que su valor está en la claridad y facilidad con que otros
        puedan adoptarlas. Diseñar bibliotecas es, en realidad, diseñar puntos
        de encuentro entre quienes escriben y quienes usan el código. Esta
        perspectiva será la brújula que guiará el resto del curso.
      </p>
    </Fragment>
  </ConclusionsLayout>

  <References>
    <Fragment slot="recommended">
      <WebPage
        title="Library (computing)"
        url="https://en.wikipedia.org/w/index.php?title=Library_(computing)"
        location="Wikipedia"
      >
        <Fragment slot="description">
          Este artículo ofrece una visión general de las bibliotecas en
          computación: qué son, cómo promueven la reutilización y la modularidad
          del software, y cómo se usan mediante APIs. Explica su evolución
          histórica, los mecanismos de enlazado (estático y dinámico), la idea
          de relocación y las principales categorías (estáticas, compartidas, de
          clases, de tiempo de ejecución, estándar del lenguaje, etc.).
          Complementa la lección al dar contexto histórico y técnico que ayuda a
          entender por qué las bibliotecas son un pilar central en el desarrollo
          de software.
        </Fragment>
      </WebPage>
    </Fragment>
  </References>
</NotesLayout>
